<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hashmancer Portal</title>
<link href="https://fonts.googleapis.com/css2?family=UnifrakturCook&display=swap" rel="stylesheet">
<style>
:root {
  --primary-color: #0f0;
  --bg-color: #000;
  --secondary-bg: #111;
  --border-color: #0f0;
  --error-color: #f44336;
  --warning-color: #ff8800;
  --success-color: #4caf50;
  --text-color: #0f0;
}

* {
  box-sizing: border-box;
}

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 10px;
  background: var(--bg-color);
  color: var(--text-color);
  line-height: 1.4;
}

h1 {
  color: var(--primary-color);
  text-align: center;
  font-family: 'UnifrakturCook', cursive;
  margin-bottom: 1rem;
}

h2 {
  color: var(--primary-color);
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.section {
  margin-bottom: 1.5rem;
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 1rem;
  position: relative;
}

.section.collapsed .section-content {
  display: none;
}

.section-toggle {
  background: none;
  border: none;
  color: var(--primary-color);
  cursor: pointer;
  font-size: 1rem;
  padding: 0;
}

.section-content {
  margin-top: 1rem;
}

/* Tables */
table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 0.5em;
}

th, td {
  border: 1px solid var(--border-color);
  padding: 8px;
  text-align: left;
}

th {
  background: var(--secondary-bg);
  font-weight: bold;
  position: sticky;
  top: 0;
}

tr:nth-child(even) {
  background: rgba(0, 255, 0, 0.05);
}

tr:hover {
  background: rgba(0, 255, 0, 0.1);
}

/* Form Elements */
input, textarea, select, button {
  background: var(--secondary-bg);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  padding: 8px;
  border-radius: 4px;
  font-family: inherit;
}

button {
  cursor: pointer;
  transition: all 0.2s;
  margin: 4px;
}

button:hover:not(:disabled) {
  background: var(--primary-color);
  color: var(--bg-color);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

button.danger {
  border-color: var(--error-color);
  color: var(--error-color);
}

button.danger:hover:not(:disabled) {
  background: var(--error-color);
  color: white;
}

/* Search and Filter */
.search-container {
  margin-bottom: 1rem;
  display: flex;
  gap: 0.5rem;
  align-items: center;
  flex-wrap: wrap;
}

.search-input {
  flex: 1;
  min-width: 200px;
}

/* Loading States */
.loading {
  position: relative;
  overflow: hidden;
}

.loading::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.2), transparent);
  animation: loading 1.5s infinite;
}

@keyframes loading {
  0% { left: -100%; }
  100% { left: 100%; }
}

.spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid var(--border-color);
  border-top: 2px solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-right: 0.5rem;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Status Indicators */
.status-indicator {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 0.5rem;
}

.status-idle { background: var(--success-color); }
.status-maintenance { background: var(--warning-color); }
.status-offline { background: var(--error-color); }

/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
}

.toast {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 1rem;
  margin-bottom: 0.5rem;
  min-width: 300px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  transform: translateX(100%);
  transition: transform 0.3s ease;
}

.toast.show {
  transform: translateX(0);
}

.toast.error {
  border-color: var(--error-color);
  background: rgba(244, 67, 54, 0.1);
}

.toast.success {
  border-color: var(--success-color);
  background: rgba(76, 175, 80, 0.1);
}

.toast.warning {
  border-color: var(--warning-color);
  background: rgba(255, 136, 0, 0.1);
}

/* Modal */
.modal-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal {
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 2rem;
  min-width: 300px;
  max-width: 90vw;
  max-height: 90vh;
  overflow-y: auto;
}

.modal h3 {
  margin-top: 0;
  color: var(--primary-color);
}

.modal-buttons {
  display: flex;
  gap: 0.5rem;
  justify-content: flex-end;
  margin-top: 1rem;
}

/* Login Overlay */
#login-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.9);
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 1001;
}

/* Header */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
  flex-wrap: wrap;
  gap: 1rem;
}

.header-controls {
  display: flex;
  gap: 0.5rem;
  align-items: center;
  flex-wrap: wrap;
}

.connection-status {
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 0.9rem;
}

.connection-status.connected {
  background: rgba(76, 175, 80, 0.2);
  border: 1px solid var(--success-color);
}

.connection-status.disconnected {
  background: rgba(244, 67, 54, 0.2);
  border: 1px solid var(--error-color);
}

/* Metrics Grid */
.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-bottom: 1rem;
}

.metric-card {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 1rem;
  text-align: center;
}

.metric-value {
  font-size: 2rem;
  font-weight: bold;
  color: var(--primary-color);
  display: block;
}

.metric-label {
  font-size: 0.9rem;
  opacity: 0.8;
  margin-top: 0.5rem;
}

/* ASCII Art */
#logo {
  border: none;
  background: none;
  margin: 0;
  font-family: monospace;
  white-space: pre;
  text-align: center;
  font-size: 0.8rem;
  opacity: 0.7;
}

/* Responsive Design */
@media (max-width: 768px) {
  body {
    padding: 5px;
  }
  
  h1 {
    font-size: 1.5rem;
  }
  
  .header {
    flex-direction: column;
    align-items: stretch;
  }
  
  .metrics-grid {
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  }
  
  table {
    font-size: 0.9rem;
  }
  
  th, td {
    padding: 4px;
  }
  
  .modal {
    margin: 1rem;
    padding: 1rem;
  }
  
  #logo {
    font-size: 0.6rem;
  }
  
  .search-container {
    flex-direction: column;
    align-items: stretch;
  }
}

@media (max-width: 480px) {
  .metrics-grid {
    grid-template-columns: 1fr;
  }
  
  .metric-value {
    font-size: 1.5rem;
  }
  
  table {
    font-size: 0.8rem;
  }
}

/* Rune Animation */
@keyframes runes {
  from { transform: translate(-10%, -10%) rotate(0deg); }
  to   { transform: translate(10%, 10%) rotate(360deg); }
}

body::before {
  content: "ᚠᚢᚦᚩᚱᚴ";
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: 'UnifrakturCook', cursive;
  font-size: 8rem;
  color: var(--primary-color);
  opacity: 0.03;
  pointer-events: none;
  animation: runes 40s linear infinite;
  z-index: -1;
}

/* Data Tables */
.data-table {
  overflow-x: auto;
}

.data-table table {
  min-width: 100%;
}

/* Progress Bars */
.progress-bar {
  width: 100%;
  height: 20px;
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--primary-color);
  transition: width 0.3s ease;
}

/* Keyboard shortcut hints */
.keyboard-hint {
  font-size: 0.8rem;
  opacity: 0.6;
  margin-left: 0.5rem;
}

/* Theme Toggle */
.theme-toggle {
  display: none; /* Will implement later */
}
</style>
</head>
<body>

<!-- Toast Container -->
<div class="toast-container" id="toast-container"></div>

<!-- Header -->
<div class="header">
  <h1>Hashmancer Portal</h1>
  <div class="header-controls">
    <div class="connection-status disconnected" id="connection-status">
      <span class="spinner" id="connection-spinner" style="display: none;"></span>
      <span id="connection-text">Connecting...</span>
    </div>
    <button onclick="location.href='/glyph'">Open Glyph</button>
    <button onclick="toggleAutoRefresh()" id="auto-refresh-btn">⏸️ Pause Updates</button>
    <button onclick="logout()">Logout</button>
  </div>
</div>

<!-- Login Overlay -->
<div id="login-overlay">
  <h2>Portal Login</h2>
  <input type="password" id="passkey" placeholder="Enter passkey" onkeypress="handleLoginKeypress(event)">
  <button onclick="submitPasskey()">Login</button>
  <div id="login-error" style="color: var(--error-color); margin-top: 4px;"></div>
</div>

<!-- Confirmation Modal -->
<div class="modal-overlay" id="confirmation-modal">
  <div class="modal">
    <h3 id="confirm-title">Confirm Action</h3>
    <p id="confirm-message">Are you sure you want to proceed?</p>
    <div class="modal-buttons">
      <button onclick="closeModal('confirmation-modal')">Cancel</button>
      <button class="danger" id="confirm-action-btn" onclick="confirmAction()">Confirm</button>
    </div>
  </div>
</div>

<!-- ASCII Logo -->
<pre id="logo">██╗  ██╗ █████╗ ███████╗██╗  ██╗███╗   ███╗ █████╗ ███╗   ██╗ ██████╗███████╗██████╗ 
██║  ██║██╔══██╗██╔════╝██║  ██║████╗ ████║██╔══██╗████╗  ██║██╔════╝██╔════╝██╔══██╗
███████║███████║███████╗███████║██╔████╔██║███████║██╔██╗ ██║██║     █████╗  ██████╔╝
██╔══██║██╔══██║╚════██║██╔══██║██║╚██╔╝██║██╔══██║██║╚██╗██║██║     ██╔══╝  ██╔══██╗
██║  ██║██║  ██║███████║██║  ██║██║ ╚═╝ ██║██║  ██║██║ ╚████║╚██████╗███████╗██║  ██║
╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝╚══════╝╚═╝  ╚═╝</pre>

<!-- Metrics Overview -->
<section class="section">
  <h2>
    System Overview
    <button class="section-toggle" onclick="toggleSection(this)">−</button>
  </h2>
  <div class="section-content">
    <div class="metrics-grid">
      <div class="metric-card">
        <span class="metric-value" id="workers">0</span>
        <div class="metric-label">Active Workers</div>
      </div>
      <div class="metric-card">
        <span class="metric-value" id="queue">0</span>
        <div class="metric-label">Queue Length</div>
      </div>
      <div class="metric-card">
        <span class="metric-value" id="results">0</span>
        <div class="metric-label">Found Results</div>
      </div>
      <div class="metric-card">
        <span class="metric-value" id="gpu-temps">N/A</span>
        <div class="metric-label">GPU Temps (°C)</div>
      </div>
    </div>
    <div id="last-updated" style="text-align: center; opacity: 0.7; margin-top: 1rem;">
      Last updated: <span id="updated-time">never</span>
    </div>
  </div>
</section>

<!-- Recent Found Results -->
<section class="section">
  <h2>
    Recent Found Results
    <button class="section-toggle" onclick="toggleSection(this)">−</button>
  </h2>
  <div class="section-content">
    <button onclick="loadAllFounds()" class="loading-btn" data-loading-text="Loading...">🔄 Refresh Results</button>
    <pre id="found-output" style="max-height: 300px; overflow-y: auto; margin-top: 1rem;"></pre>
  </div>
</section>

<!-- Import Hashes -->
<section class="section">
  <h2>
    Import Hashes
    <button class="section-toggle" onclick="toggleSection(this)">−</button>
  </h2>
  <div class="section-content">
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;">
      <div>
        <h4>Upload Hash File</h4>
        <input type="file" id="hash-file" accept=".txt,.hash">
        <input type="number" id="hash-mode" placeholder="Hash mode (e.g., 0 for MD5)" style="margin-top: 0.5rem;">
        <button onclick="uploadHashes()" class="loading-btn" data-loading-text="Uploading..." style="display: block; margin-top: 0.5rem;">📤 Upload Hashes</button>
      </div>
      <div>
        <h4>Add Single Hash</h4>
        <input type="text" id="single-hash" placeholder="Enter hash value">
        <input type="number" id="single-hash-mode" placeholder="Hash mode" style="margin-top: 0.5rem;">
        <button onclick="submitHash()" class="loading-btn" data-loading-text="Adding..." style="display: block; margin-top: 0.5rem;">➕ Add Hash</button>
      </div>
    </div>
  </div>
</section>

<!-- Workers Management -->
<section class="section">
  <h2>
    Workers <span id="worker-count-badge" class="metric-value" style="font-size: 1rem; margin-left: 0.5rem;">0</span>
    <button class="section-toggle" onclick="toggleSection(this)">−</button>
  </h2>
  <div class="section-content">
    <div class="search-container">
      <input type="text" class="search-input" id="worker-search" placeholder="🔍 Search workers..." onkeyup="filterTable('worker-search', 'worker-body')">
      <select id="worker-status-filter" onchange="filterWorkersByStatus()">
        <option value="">All Statuses</option>
        <option value="idle">Idle</option>
        <option value="maintenance">Maintenance</option>
        <option value="offline">Offline</option>
      </select>
    </div>
    <div class="data-table">
      <table>
        <thead>
          <tr>
            <th onclick="sortTable('worker-table', 0)">Worker <span class="keyboard-hint">Click to sort</span></th>
            <th onclick="sortTable('worker-table', 1)">Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="worker-body"></tbody>
      </table>
    </div>
  </div>
</section>

<!-- Jobs Management -->
<section class="section">
  <h2>
    Active Jobs
    <button class="section-toggle" onclick="toggleSection(this)">−</button>
  </h2>
  <div class="section-content">
    <div class="search-container">
      <input type="text" class="search-input" id="job-search" placeholder="🔍 Search jobs..." onkeyup="filterTable('job-search', 'job-body')">
      <button onclick="loadJobs()" class="loading-btn" data-loading-text="Loading...">🔄 Refresh Jobs</button>
    </div>
    <div class="data-table">
      <table id="job-table">
        <thead>
          <tr>
            <th onclick="sortTable('job-table', 0)">Job ID</th>
            <th onclick="sortTable('job-table', 1)">Status</th>
            <th onclick="sortTable('job-table', 2)">Attack Mode</th>
            <th>Progress</th>
          </tr>
        </thead>
        <tbody id="job-body"></tbody>
      </table>
    </div>
  </div>
</section>

<!-- File Management -->
<section class="section">
  <h2>
    File Management
    <button class="section-toggle" onclick="toggleSection(this)">−</button>
  </h2>
  <div class="section-content">
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
      
      <!-- Dictionaries -->
      <div>
        <h4>📚 Dictionaries</h4>
        <div class="search-container">
          <input type="text" class="search-input" id="dict-search" placeholder="🔍 Search dictionaries..." onkeyup="filterList('dict-search', 'dict-list')">
        </div>
        <ul id="dict-list" style="max-height: 200px; overflow-y: auto;"></ul>
        <input type="file" id="dict-upload" accept=".txt,.dic" multiple>
        <button onclick="uploadDict()" class="loading-btn" data-loading-text="Uploading..." style="display: block; margin-top: 0.5rem;">📤 Upload Dictionary</button>
      </div>

      <!-- Masks -->
      <div>
        <h4>🎭 Masks</h4>
        <div class="search-container">
          <input type="text" class="search-input" id="mask-search" placeholder="🔍 Search masks..." onkeyup="filterList('mask-search', 'mask-list')">
        </div>
        <ul id="mask-list" style="max-height: 200px; overflow-y: auto;"></ul>
        <input type="text" id="mask-name" placeholder="Mask name">
        <textarea id="mask-content" rows="2" placeholder="Mask content (e.g., ?a?a?a?a?a?a?a?a)" style="width: 100%; margin-top: 0.5rem;"></textarea>
        <button onclick="createMask()" class="loading-btn" data-loading-text="Creating..." style="display: block; margin-top: 0.5rem;">➕ Create Mask</button>
      </div>

      <!-- Restore Files -->
      <div>
        <h4>💾 Restore Files</h4>
        <div class="search-container">
          <input type="text" class="search-input" id="restore-search" placeholder="🔍 Search restore files..." onkeyup="filterList('restore-search', 'restore-list')">
        </div>
        <ul id="restore-list" style="max-height: 200px; overflow-y: auto;"></ul>
        <input type="file" id="restore-upload" accept=".restore">
        <button onclick="uploadRestore()" class="loading-btn" data-loading-text="Uploading..." style="display: block; margin-top: 0.5rem;">📤 Upload Restore</button>
      </div>
    </div>
  </div>
</section>

<!-- System Logs -->
<section class="section">
  <h2>
    System Logs
    <button class="section-toggle" onclick="toggleSection(this)">−</button>
  </h2>
  <div class="section-content">
    <div class="search-container">
      <select id="log-worker" onchange="loadLogs()">
        <option value="">All Workers</option>
      </select>
      <input type="text" class="search-input" id="log-search" placeholder="🔍 Search logs..." onkeyup="filterLogs()">
      <button onclick="loadLogs()" class="loading-btn" data-loading-text="Loading...">🔄 Refresh Logs</button>
      <button onclick="clearLogFilter()">🗑️ Clear Filter</button>
    </div>
    <pre id="log-output" style="max-height: 400px; overflow-y: auto; background: var(--secondary-bg); padding: 1rem; border-radius: 4px;"></pre>
  </div>
</section>

<!-- Advanced Configuration -->
<section class="section collapsed">
  <h2>
    Advanced Configuration
    <button class="section-toggle" onclick="toggleSection(this)">+</button>
  </h2>
  <div class="section-content">
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 2rem;">
      
      <!-- Hashes.com Settings -->
      <div>
        <h4>🌐 Hashes.com Integration</h4>
        <div style="margin-bottom: 1rem;">
          <label>API Key:</label>
          <input type="password" id="hashes-key" placeholder="Enter API key">
          <button onclick="saveHashesKey()" class="loading-btn" data-loading-text="Saving..." style="margin-left: 0.5rem;">💾 Save</button>
        </div>
        <div style="margin-bottom: 1rem;">
          <label>Algorithms:</label>
          <input type="text" id="hashes-algos" placeholder="md5,sha1,sha256">
          <button onclick="saveHashesAlgos()" class="loading-btn" data-loading-text="Saving..." style="margin-left: 0.5rem;">💾 Save</button>
        </div>
        <div style="margin-bottom: 1rem;">
          <label>Poll Interval (seconds):</label>
          <input type="number" id="hashes-poll" value="0" min="0">
          <button onclick="saveHashesPoll()" class="loading-btn" data-loading-text="Saving..." style="margin-left: 0.5rem;">💾 Save</button>
        </div>
      </div>

      <!-- Markov Training -->
      <div>
        <h4>🧠 Markov Training</h4>
        <div style="margin-bottom: 1rem;">
          <label>Language:</label>
          <select id="markov-language">
            <option value="english">English</option>
            <option value="german">German</option>
            <option value="french">French</option>
            <option value="spanish">Spanish</option>
          </select>
          <button onclick="trainMarkov()" class="loading-btn" data-loading-text="Training...">🏋️ Train</button>
          <button onclick="changeMarkovLang()" class="loading-btn" data-loading-text="Applying...">✅ Set Active</button>
        </div>
        <div>
          <label><input type="checkbox" id="prob-order" onchange="updateProbOrder()"> Probabilistic Ordering</label>
        </div>
        <div>
          <label><input type="checkbox" id="inverse-order" onchange="updateInverseOrder()"> Inverse Order</label>
        </div>
        <div style="margin-top: 1rem; font-size: 0.9rem; opacity: 0.8;">
          Current Language: <span id="current-markov-lang">-</span><br>
          Probabilistic Order: <span id="current-prob-order">-</span><br>
          Inverse Order: <span id="current-inverse-order">-</span>
        </div>
      </div>
    </div>
  </div>
</section>

<script>
// ============================================================================
// CORE UTILITIES AND STATE MANAGEMENT
// ============================================================================

class PortalApp {
  constructor() {
    this.csrfToken = this.getCSRFToken();
    this.autoRefresh = true;
    this.refreshInterval = 30000; // 30 seconds
    this.refreshTimer = null;
    this.wsConnection = null;
    this.cache = new Map();
    this.cacheTTL = 30000; // 30 seconds
    this.pendingConfirmation = null;
    this.loadingRequests = new Set();
    
    this.initializeApp();
  }

  getCSRFToken() {
    const meta = document.querySelector('meta[name="csrf-token"]');
    return meta ? meta.getAttribute('content') : null;
  }

  async refreshCSRFToken() {
    try {
      const response = await fetch('/csrf_token');
      const data = await response.json();
      this.csrfToken = data.csrf_token;
      
      // Update meta tag
      let meta = document.querySelector('meta[name="csrf-token"]');
      if (!meta) {
        meta = document.createElement('meta');
        meta.name = 'csrf-token';
        document.head.appendChild(meta);
      }
      meta.content = this.csrfToken;
      
    } catch (error) {
      console.error('Failed to refresh CSRF token:', error);
    }
  }

  // Enhanced fetch with CSRF protection, loading states, and error handling
  async apiCall(url, options = {}) {
    const requestId = `${url}-${Date.now()}`;
    this.loadingRequests.add(requestId);
    
    try {
      // Add CSRF token to requests
      if (this.csrfToken && (options.method !== 'GET' && options.method !== 'HEAD')) {
        options.headers = {
          ...options.headers,
          'X-CSRF-Token': this.csrfToken
        };
      }

      // Set default headers
      if (!options.headers) options.headers = {};
      if (options.body && typeof options.body === 'string') {
        options.headers['Content-Type'] = 'application/json';
      }

      const response = await fetch(url, options);
      
      // Handle CSRF token refresh
      if (response.status === 403) {
        await this.refreshCSRFToken();
        // Retry with new token
        options.headers['X-CSRF-Token'] = this.csrfToken;
        return await fetch(url, options);
      }
      
      if (!response.ok) {
        if (response.status === 401) {
          this.showLogin();
          throw new Error('Authentication required');
        }
        
        let errorMessage = `HTTP ${response.status}`;
        try {
          const errorData = await response.json();
          errorMessage = errorData.detail || errorData.message || errorMessage;
        } catch (e) {
          errorMessage = await response.text() || errorMessage;
        }
        
        throw new Error(errorMessage);
      }

      return response;
    } finally {
      this.loadingRequests.delete(requestId);
    }
  }

  // Cache management
  setCache(key, value) {
    this.cache.set(key, {
      value,
      timestamp: Date.now()
    });
  }

  getCache(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() - item.timestamp > this.cacheTTL) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value;
  }

  clearCache() {
    this.cache.clear();
    this.showToast('Cache cleared', 'success');
  }

  // ============================================================================
  // UI UTILITIES
  // ============================================================================

  showToast(message, type = 'info', duration = 5000) {
    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span>${this.sanitizeHTML(message)}</span>
        <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: inherit; cursor: pointer; padding: 0; margin-left: 1rem;">×</button>
      </div>
    `;
    
    container.appendChild(toast);
    
    // Show toast with animation
    setTimeout(() => toast.classList.add('show'), 100);
    
    // Auto-remove toast
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  sanitizeHTML(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  showLoading(element, text = 'Loading...') {
    if (typeof element === 'string') {
      element = document.getElementById(element);
    }
    
    if (element) {
      element.classList.add('loading');
      if (element.tagName === 'BUTTON') {
        element.disabled = true;
        element.dataset.originalText = element.textContent;
        element.innerHTML = `<span class="spinner"></span>${text}`;
      }
    }
  }

  hideLoading(element) {
    if (typeof element === 'string') {
      element = document.getElementById(element);
    }
    
    if (element) {
      element.classList.remove('loading');
      if (element.tagName === 'BUTTON') {
        element.disabled = false;
        if (element.dataset.originalText) {
          element.textContent = element.dataset.originalText;
          delete element.dataset.originalText;
        }
      }
    }
  }

  showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.style.display = 'flex';
    }
  }

  closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.style.display = 'none';
    }
  }

  confirmAction(title, message, callback) {
    document.getElementById('confirm-title').textContent = title;
    document.getElementById('confirm-message').textContent = message;
    this.pendingConfirmation = callback;
    this.showModal('confirmation-modal');
  }

  // ============================================================================
  // APPLICATION INITIALIZATION
  // ============================================================================

  initializeApp() {
    this.setupEventListeners();
    this.setupKeyboardShortcuts();
    this.checkAuthentication();
    this.startRefreshTimer();
    this.connectWebSocket();
  }

  setupEventListeners() {
    // Auto-refresh toggle
    const autoRefreshBtn = document.getElementById('auto-refresh-btn');
    if (autoRefreshBtn) {
      autoRefreshBtn.addEventListener('click', () => this.toggleAutoRefresh());
    }

    // Loading button handlers
    document.querySelectorAll('.loading-btn').forEach(btn => {
      const originalHandler = btn.onclick;
      btn.onclick = async (e) => {
        const loadingText = btn.dataset.loadingText || 'Loading...';
        this.showLoading(btn, loadingText);
        
        try {
          if (originalHandler) {
            await originalHandler.call(btn, e);
          }
        } finally {
          this.hideLoading(btn);
        }
      };
    });

    // Modal click outside to close
    document.querySelectorAll('.modal-overlay').forEach(overlay => {
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          this.closeModal(overlay.id);
        }
      });
    });
  }

  setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      // Ctrl+R - Refresh all data
      if (e.ctrlKey && e.key === 'r') {
        e.preventDefault();
        this.refreshAllData();
      }
      
      // Escape - Close modals
      if (e.key === 'Escape') {
        document.querySelectorAll('.modal-overlay').forEach(modal => {
          if (modal.style.display === 'flex') {
            this.closeModal(modal.id);
          }
        });
      }
      
      // Ctrl+L - Focus log search
      if (e.ctrlKey && e.key === 'l') {
        e.preventDefault();
        document.getElementById('log-search')?.focus();
      }
      
      // Ctrl+F - Focus general search
      if (e.ctrlKey && e.key === 'f') {
        const activeSearch = document.querySelector('.search-input:focus') || 
                           document.querySelector('.search-input');
        if (activeSearch) {
          e.preventDefault();
          activeSearch.focus();
        }
      }
    });
  }

  async checkAuthentication() {
    try {
      const response = await this.apiCall('/server_status');
      if (response.ok) {
        this.hideLogin();
        this.refreshAllData();
      }
    } catch (error) {
      if (error.message.includes('Authentication')) {
        this.showLogin();
      } else {
        this.showToast('Connection error: ' + error.message, 'error');
      }
    }
  }

  // ============================================================================
  // DATA MANAGEMENT
  // ============================================================================

  async refreshAllData() {
    this.showToast('Refreshing all data...', 'info', 2000);
    
    try {
      await Promise.allSettled([
        this.updateMetrics(),
        this.loadWorkers(),
        this.loadJobs(),
        this.loadDicts(),
        this.loadMasks(),
        this.loadRestores(),
        this.loadLogs(),
        this.loadAllFounds()
      ]);
      
      this.showToast('Data refreshed successfully', 'success', 2000);
    } catch (error) {
      this.showToast('Some data failed to refresh: ' + error.message, 'warning');
    }
  }

  async updateMetrics() {
    try {
      const response = await this.apiCall('/server_status');
      const data = await response.json();
      
      // Update metric cards
      document.getElementById('workers').textContent = data.worker_count || 0;
      document.getElementById('queue').textContent = data.queue_length || 0;
      document.getElementById('results').textContent = data.found_results || 0;
      document.getElementById('gpu-temps').textContent = 
        (data.gpu_temps && data.gpu_temps.length > 0) ? data.gpu_temps.join(', ') + '°C' : 'N/A';
      
      // Update worker count badge
      document.getElementById('worker-count-badge').textContent = data.worker_count || 0;
      
      // Update configuration status
      document.getElementById('current-prob-order').textContent = data.probabilistic_order ? 'ON' : 'OFF';
      document.getElementById('current-inverse-order').textContent = data.inverse_prob_order ? 'ON' : 'OFF';
      document.getElementById('current-markov-lang').textContent = data.markov_lang || 'english';
      
      // Update form values
      const probOrderCheck = document.getElementById('prob-order');
      const inverseOrderCheck = document.getElementById('inverse-order');
      const markovLangSelect = document.getElementById('markov-language');
      
      if (probOrderCheck) probOrderCheck.checked = !!data.probabilistic_order;
      if (inverseOrderCheck) inverseOrderCheck.checked = !!data.inverse_prob_order;
      if (markovLangSelect) markovLangSelect.value = data.markov_lang || 'english';
      
      // Update timestamp
      document.getElementById('updated-time').textContent = new Date().toLocaleTimeString();
      
      // Cache the data
      this.setCache('metrics', data);
      
    } catch (error) {
      console.error('Failed to update metrics:', error);
      this.showToast('Failed to update metrics: ' + error.message, 'error');
    }
  }

  // ============================================================================
  // WEBSOCKET MANAGEMENT
  // ============================================================================

  connectWebSocket() {
    if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {
      return;
    }

    const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${protocol}://${location.host}/ws/portal`;
    
    this.updateConnectionStatus('connecting');
    
    try {
      this.wsConnection = new WebSocket(wsUrl);
      
      this.wsConnection.onopen = () => {
        console.log('WebSocket connected');
        this.updateConnectionStatus('connected');
      };
      
      this.wsConnection.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.handleWebSocketMessage(data);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };
      
      this.wsConnection.onclose = (event) => {
        console.log('WebSocket disconnected:', event.code, event.reason);
        this.updateConnectionStatus('disconnected');
        
        // Reconnect after delay
        setTimeout(() => this.connectWebSocket(), 5000);
      };
      
      this.wsConnection.onerror = (error) => {
        console.error('WebSocket error:', error);
        this.updateConnectionStatus('error');
      };
      
    } catch (error) {
      console.error('Failed to create WebSocket connection:', error);
      this.updateConnectionStatus('error');
      setTimeout(() => this.connectWebSocket(), 10000);
    }
  }

  handleWebSocketMessage(data) {
    if (data.metrics) {
      // Update metrics from WebSocket
      const metrics = data.metrics;
      document.getElementById('workers').textContent = metrics.worker_count || 0;
      document.getElementById('queue').textContent = metrics.queue_length || 0;
      document.getElementById('results').textContent = metrics.found_results || 0;
      document.getElementById('gpu-temps').textContent = 
        (metrics.gpu_temps && metrics.gpu_temps.length > 0) ? metrics.gpu_temps.join(', ') + '°C' : 'N/A';
      
      document.getElementById('updated-time').textContent = new Date().toLocaleTimeString();
    }
    
    if (data.founds && data.founds.length > 0) {
      // Update found results
      const foundOutput = document.getElementById('found-output');
      if (foundOutput) {
        const newResults = data.founds.map(f => this.sanitizeHTML(f)).join('\n');
        foundOutput.textContent += (foundOutput.textContent ? '\n' : '') + newResults;
        
        // Auto-scroll to bottom
        foundOutput.scrollTop = foundOutput.scrollHeight;
        
        // Show notification
        this.showToast(`Found ${data.founds.length} new result(s)!`, 'success');
      }
    }
    
    if (data.workers) {
      // Refresh workers list
      this.loadWorkers();
    }
  }

  updateConnectionStatus(status) {
    const statusElement = document.getElementById('connection-status');
    const textElement = document.getElementById('connection-text');
    const spinnerElement = document.getElementById('connection-spinner');
    
    if (!statusElement || !textElement) return;
    
    statusElement.className = 'connection-status';
    
    switch (status) {
      case 'connected':
        statusElement.classList.add('connected');
        textElement.textContent = 'Connected';
        spinnerElement.style.display = 'none';
        break;
      case 'connecting':
        textElement.textContent = 'Connecting...';
        spinnerElement.style.display = 'inline-block';
        break;
      case 'disconnected':
        statusElement.classList.add('disconnected');
        textElement.textContent = 'Disconnected';
        spinnerElement.style.display = 'none';
        break;
      case 'error':
        statusElement.classList.add('disconnected');
        textElement.textContent = 'Connection Error';
        spinnerElement.style.display = 'none';
        break;
    }
  }

  // ============================================================================
  // AUTO-REFRESH MANAGEMENT
  // ============================================================================

  toggleAutoRefresh() {
    this.autoRefresh = !this.autoRefresh;
    const btn = document.getElementById('auto-refresh-btn');
    
    if (this.autoRefresh) {
      btn.textContent = '⏸️ Pause Updates';
      this.startRefreshTimer();
      this.showToast('Auto-refresh enabled', 'success', 2000);
    } else {
      btn.textContent = '▶️ Resume Updates';
      this.stopRefreshTimer();
      this.showToast('Auto-refresh paused', 'warning', 2000);
    }
  }

  startRefreshTimer() {
    this.stopRefreshTimer();
    
    if (this.autoRefresh) {
      this.refreshTimer = setInterval(() => {
        this.updateMetrics();
      }, this.refreshInterval);
    }
  }

  stopRefreshTimer() {
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
      this.refreshTimer = null;
    }
  }

  // ============================================================================
  // AUTHENTICATION
  // ============================================================================

  showLogin() {
    document.getElementById('login-overlay').style.display = 'flex';
    document.getElementById('passkey').focus();
  }

  hideLogin() {
    document.getElementById('login-overlay').style.display = 'none';
  }

  async submitPasskey() {
    const passkey = document.getElementById('passkey').value.trim();
    const errorElement = document.getElementById('login-error');
    
    if (!passkey) {
      errorElement.textContent = 'Please enter a passkey';
      return;
    }

    try {
      const response = await this.apiCall('/login', {
        method: 'POST',
        body: JSON.stringify({ passkey })
      });

      if (response.ok) {
        const data = await response.json();
        document.cookie = `session=${data.cookie}; path=/; SameSite=Strict`;
        this.hideLogin();
        this.refreshAllData();
        this.showToast('Login successful', 'success');
      }
    } catch (error) {
      errorElement.textContent = error.message || 'Invalid passkey';
    }
  }

  handleLoginKeypress(event) {
    if (event.key === 'Enter') {
      this.submitPasskey();
    }
  }

  async logout() {
    try {
      const match = document.cookie.match(/(?:^|; )session=([^;]+)/);
      if (match) {
        await this.apiCall('/logout', {
          method: 'POST',
          body: JSON.stringify({ token: match[1] })
        });
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      document.cookie = 'session=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT';
      location.reload();
    }
  }

  // ============================================================================
  // WORKERS MANAGEMENT
  // ============================================================================

  async loadWorkers() {
    try {
      const response = await this.apiCall('/workers');
      const workers = await response.json();
      
      const tbody = document.getElementById('worker-body');
      const logSelect = document.getElementById('log-worker');
      
      // Clear existing content
      tbody.innerHTML = '';
      logSelect.innerHTML = '<option value="">All Workers</option>';
      
      workers.forEach(worker => {
        // Add worker to table
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>
            <span class="status-indicator status-${worker.status}"></span>
            ${this.sanitizeHTML(worker.name)}
          </td>
          <td>
            <span class="status-${worker.status}">${this.sanitizeHTML(worker.status)}</span>
          </td>
          <td>
            <select onchange="app.changeWorkerStatus('${worker.name}', this.value)">
              <option value="idle" ${worker.status === 'idle' ? 'selected' : ''}>Idle</option>
              <option value="maintenance" ${worker.status === 'maintenance' ? 'selected' : ''}>Maintenance</option>
              <option value="offline" ${worker.status === 'offline' ? 'selected' : ''}>Offline</option>
            </select>
          </td>
        `;
        tbody.appendChild(row);
        
        // Add worker to log filter
        const option = document.createElement('option');
        option.value = worker.name;
        option.textContent = worker.name;
        logSelect.appendChild(option);
      });
      
      // Update worker count
      document.getElementById('worker-count-badge').textContent = workers.length;
      
      // Cache workers data
      this.setCache('workers', workers);
      
    } catch (error) {
      console.error('Failed to load workers:', error);
      this.showToast('Failed to load workers: ' + error.message, 'error');
    }
  }

  async changeWorkerStatus(workerName, newStatus) {
    try {
      await this.apiCall('/worker_status', {
        method: 'POST',
        body: JSON.stringify({
          name: workerName,
          status: newStatus
        })
      });
      
      this.showToast(`Worker ${workerName} status changed to ${newStatus}`, 'success');
      
      // Update the status in the table immediately
      const rows = document.querySelectorAll('#worker-body tr');
      rows.forEach(row => {
        const workerCell = row.cells[0];
        if (workerCell.textContent.trim().includes(workerName)) {
          const statusCell = row.cells[1];
          const statusIndicator = workerCell.querySelector('.status-indicator');
          
          statusCell.innerHTML = `<span class="status-${newStatus}">${newStatus}</span>`;
          statusIndicator.className = `status-indicator status-${newStatus}`;
        }
      });
      
    } catch (error) {
      console.error('Failed to change worker status:', error);
      this.showToast('Failed to change worker status: ' + error.message, 'error');
    }
  }

  filterWorkersByStatus() {
    const statusFilter = document.getElementById('worker-status-filter').value;
    const searchTerm = document.getElementById('worker-search').value.toLowerCase();
    const rows = document.querySelectorAll('#worker-body tr');
    
    rows.forEach(row => {
      const workerName = row.cells[0].textContent.toLowerCase();
      const workerStatus = row.cells[1].textContent.toLowerCase();
      
      const matchesSearch = !searchTerm || workerName.includes(searchTerm);
      const matchesStatus = !statusFilter || workerStatus.includes(statusFilter.toLowerCase());
      
      row.style.display = (matchesSearch && matchesStatus) ? '' : 'none';
    });
  }

  // ============================================================================
  // JOBS MANAGEMENT
  // ============================================================================

  async loadJobs() {
    try {
      const response = await this.apiCall('/jobs');
      const jobs = await response.json();
      
      const tbody = document.getElementById('job-body');
      tbody.innerHTML = '';
      
      jobs.forEach(job => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${this.sanitizeHTML(job.job_id || 'N/A')}</td>
          <td><span class="status-${job.status || 'unknown'}">${this.sanitizeHTML(job.status || 'Unknown')}</span></td>
          <td>${this.sanitizeHTML(job.attack_mode || 'N/A')}</td>
          <td>
            <div class="progress-bar">
              <div class="progress-fill" style="width: ${(job.progress || 0) * 100}%"></div>
            </div>
            <small>${Math.round((job.progress || 0) * 100)}%</small>
          </td>
        `;
        tbody.appendChild(row);
      });
      
      this.setCache('jobs', jobs);
      
    } catch (error) {
      console.error('Failed to load jobs:', error);
      this.showToast('Failed to load jobs: ' + error.message, 'error');
    }
  }

  // ============================================================================
  // FILE MANAGEMENT
  // ============================================================================

  async loadDicts() {
    try {
      const response = await this.apiCall('/wordlists');
      const dicts = await response.json();
      
      const list = document.getElementById('dict-list');
      list.innerHTML = '';
      
      dicts.forEach(name => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span>${this.sanitizeHTML(name)}</span>
          <button class="danger" onclick="app.deleteDict('${name}')">🗑️ Delete</button>
        `;
        list.appendChild(li);
      });
      
      this.setCache('dicts', dicts);
      
    } catch (error) {
      console.error('Failed to load dictionaries:', error);
      this.showToast('Failed to load dictionaries: ' + error.message, 'error');
    }
  }

  async uploadDict() {
    const fileInput = document.getElementById('dict-upload');
    const files = fileInput.files;
    
    if (!files || files.length === 0) {
      this.showToast('Please select at least one file', 'warning');
      return;
    }

    try {
      for (const file of files) {
        const formData = new FormData();
        formData.append('file', file);
        
        await this.apiCall('/upload_wordlist', {
          method: 'POST',
          body: formData
        });
      }
      
      fileInput.value = '';
      this.loadDicts();
      this.showToast(`Successfully uploaded ${files.length} dictionary(s)`, 'success');
      
    } catch (error) {
      console.error('Failed to upload dictionary:', error);
      this.showToast('Failed to upload dictionary: ' + error.message, 'error');
    }
  }

  async deleteDict(name) {
    this.confirmAction(
      'Delete Dictionary',
      `Are you sure you want to delete the dictionary "${name}"? This action cannot be undone.`,
      async () => {
        try {
          await this.apiCall(`/wordlist/${encodeURIComponent(name)}`, {
            method: 'DELETE'
          });
          
          this.loadDicts();
          this.showToast(`Dictionary "${name}" deleted successfully`, 'success');
          
        } catch (error) {
          console.error('Failed to delete dictionary:', error);
          this.showToast('Failed to delete dictionary: ' + error.message, 'error');
        }
      }
    );
  }

  async loadMasks() {
    try {
      const response = await this.apiCall('/masks');
      const masks = await response.json();
      
      const list = document.getElementById('mask-list');
      list.innerHTML = '';
      
      masks.forEach(name => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span>${this.sanitizeHTML(name)}</span>
          <button class="danger" onclick="app.deleteMask('${name}')">🗑️ Delete</button>
        `;
        list.appendChild(li);
      });
      
      this.setCache('masks', masks);
      
    } catch (error) {
      console.error('Failed to load masks:', error);
      this.showToast('Failed to load masks: ' + error.message, 'error');
    }
  }

  async createMask() {
    const name = document.getElementById('mask-name').value.trim();
    const content = document.getElementById('mask-content').value.trim();
    
    if (!name) {
      this.showToast('Please enter a mask name', 'warning');
      return;
    }
    
    if (!content) {
      this.showToast('Please enter mask content', 'warning');
      return;
    }

    try {
      await this.apiCall('/create_mask', {
        method: 'POST',
        body: JSON.stringify({ name, content })
      });
      
      document.getElementById('mask-name').value = '';
      document.getElementById('mask-content').value = '';
      this.loadMasks();
      this.showToast(`Mask "${name}" created successfully`, 'success');
      
    } catch (error) {
      console.error('Failed to create mask:', error);
      this.showToast('Failed to create mask: ' + error.message, 'error');
    }
  }

  async deleteMask(name) {
    this.confirmAction(
      'Delete Mask',
      `Are you sure you want to delete the mask "${name}"? This action cannot be undone.`,
      async () => {
        try {
          await this.apiCall(`/mask/${encodeURIComponent(name)}`, {
            method: 'DELETE'
          });
          
          this.loadMasks();
          this.showToast(`Mask "${name}" deleted successfully`, 'success');
          
        } catch (error) {
          console.error('Failed to delete mask:', error);
          this.showToast('Failed to delete mask: ' + error.message, 'error');
        }
      }
    );
  }

  async loadRestores() {
    try {
      const response = await this.apiCall('/restores');
      const restores = await response.json();
      
      const list = document.getElementById('restore-list');
      list.innerHTML = '';
      
      restores.forEach(name => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span>${this.sanitizeHTML(name)}</span>
          <a href="/download_restore/${encodeURIComponent(name)}" style="color: var(--primary-color); margin-left: 0.5rem;">📥 Download</a>
          <button class="danger" onclick="app.deleteRestore('${name}')" style="margin-left: 0.5rem;">🗑️ Delete</button>
        `;
        list.appendChild(li);
      });
      
      this.setCache('restores', restores);
      
    } catch (error) {
      console.error('Failed to load restore files:', error);
      this.showToast('Failed to load restore files: ' + error.message, 'error');
    }
  }

  async uploadRestore() {
    const fileInput = document.getElementById('restore-upload');
    const file = fileInput.files[0];
    
    if (!file) {
      this.showToast('Please select a restore file', 'warning');
      return;
    }

    try {
      const formData = new FormData();
      formData.append('file', file);
      
      await this.apiCall('/upload_restore', {
        method: 'POST',
        body: formData
      });
      
      fileInput.value = '';
      this.loadRestores();
      this.showToast('Restore file uploaded successfully', 'success');
      
    } catch (error) {
      console.error('Failed to upload restore file:', error);
      this.showToast('Failed to upload restore file: ' + error.message, 'error');
    }
  }

  async deleteRestore(name) {
    this.confirmAction(
      'Delete Restore File',
      `Are you sure you want to delete the restore file "${name}"? This action cannot be undone.`,
      async () => {
        try {
          await this.apiCall(`/restore/${encodeURIComponent(name)}`, {
            method: 'DELETE'
          });
          
          this.loadRestores();
          this.showToast(`Restore file "${name}" deleted successfully`, 'success');
          
        } catch (error) {
          console.error('Failed to delete restore file:', error);
          this.showToast('Failed to delete restore file: ' + error.message, 'error');
        }
      }
    );
  }

  // ============================================================================
  // HASH MANAGEMENT
  // ============================================================================

  async uploadHashes() {
    const fileInput = document.getElementById('hash-file');
    const hashModeInput = document.getElementById('hash-mode');
    
    const file = fileInput.files[0];
    const hashMode = hashModeInput.value.trim();
    
    if (!file) {
      this.showToast('Please select a hash file', 'warning');
      return;
    }

    try {
      const formData = new FormData();
      formData.append('file', file);
      if (hashMode) {
        formData.append('hash_mode', hashMode);
      }
      
      await this.apiCall('/import_hashes', {
        method: 'POST',
        body: formData
      });
      
      fileInput.value = '';
      hashModeInput.value = '';
      
      this.updateMetrics();
      this.loadJobs();
      this.showToast('Hashes uploaded successfully', 'success');
      
    } catch (error) {
      console.error('Failed to upload hashes:', error);
      this.showToast('Failed to upload hashes: ' + error.message, 'error');
    }
  }

  async submitHash() {
    const hashInput = document.getElementById('single-hash');
    const hashModeInput = document.getElementById('single-hash-mode');
    
    const hash = hashInput.value.trim();
    const hashMode = hashModeInput.value.trim() || '0';
    
    if (!hash) {
      this.showToast('Please enter a hash value', 'warning');
      return;
    }

    try {
      await this.apiCall('/import_hash', {
        method: 'POST',
        body: JSON.stringify({
          hash: hash,
          hash_mode: hashMode
        })
      });
      
      hashInput.value = '';
      hashModeInput.value = '';
      
      this.updateMetrics();
      this.loadJobs();
      this.showToast('Hash added successfully', 'success');
      
    } catch (error) {
      console.error('Failed to add hash:', error);
      this.showToast('Failed to add hash: ' + error.message, 'error');
    }
  }

  async loadAllFounds() {
    try {
      const response = await this.apiCall('/found_results?limit=100');
      const results = await response.json();
      
      const output = document.getElementById('found-output');
      output.textContent = results.join('\n');
      
      // Auto-scroll to bottom
      output.scrollTop = output.scrollHeight;
      
      this.setCache('found_results', results);
      
    } catch (error) {
      console.error('Failed to load found results:', error);
      this.showToast('Failed to load found results: ' + error.message, 'error');
    }
  }

  // ============================================================================
  // LOGS MANAGEMENT
  // ============================================================================

  async loadLogs() {
    const workerSelect = document.getElementById('log-worker');
    const worker = workerSelect.value;
    
    try {
      const url = worker ? `/logs?worker=${encodeURIComponent(worker)}` : '/logs';
      const response = await this.apiCall(url);
      const logs = await response.json();
      
      const output = document.getElementById('log-output');
      const logText = logs.map(entry => 
        `${entry.datetime || ''} [${this.sanitizeHTML(entry.worker_id || '')}] ${this.sanitizeHTML(entry.message || '')}`
      ).join('\n');
      
      output.textContent = logText;
      
      // Auto-scroll to bottom
      output.scrollTop = output.scrollHeight;
      
      this.setCache('logs', logs);
      
    } catch (error) {
      console.error('Failed to load logs:', error);
      this.showToast('Failed to load logs: ' + error.message, 'error');
    }
  }

  filterLogs() {
    const searchTerm = document.getElementById('log-search').value.toLowerCase();
    const output = document.getElementById('log-output');
    const allLogs = this.getCache('logs') || [];
    
    if (!searchTerm) {
      // Show all logs
      const logText = allLogs.map(entry => 
        `${entry.datetime || ''} [${entry.worker_id || ''}] ${entry.message || ''}`
      ).join('\n');
      output.textContent = logText;
    } else {
      // Filter logs
      const filteredLogs = allLogs.filter(entry => 
        (entry.message || '').toLowerCase().includes(searchTerm) ||
        (entry.worker_id || '').toLowerCase().includes(searchTerm)
      );
      
      const logText = filteredLogs.map(entry => 
        `${entry.datetime || ''} [${entry.worker_id || ''}] ${entry.message || ''}`
      ).join('\n');
      output.textContent = logText;
    }
    
    // Auto-scroll to bottom
    output.scrollTop = output.scrollHeight;
  }

  clearLogFilter() {
    document.getElementById('log-search').value = '';
    this.filterLogs();
  }

  // ============================================================================
  // CONFIGURATION MANAGEMENT
  // ============================================================================

  async saveHashesKey() {
    const key = document.getElementById('hashes-key').value.trim();
    
    try {
      await this.apiCall('/hashes_api_key', {
        method: 'POST',
        body: JSON.stringify({ api_key: key })
      });
      
      this.showToast('Hashes.com API key saved successfully', 'success');
      
    } catch (error) {
      console.error('Failed to save API key:', error);
      this.showToast('Failed to save API key: ' + error.message, 'error');
    }
  }

  async saveHashesAlgos() {
    const algosInput = document.getElementById('hashes-algos');
    const algosText = algosInput.value.trim();
    const algos = algosText ? algosText.split(',').map(a => a.trim()).filter(a => a) : [];
    
    try {
      await this.apiCall('/hashes_algorithms', {
        method: 'POST',
        body: JSON.stringify({ algorithms: algos })
      });
      
      this.showToast('Hashes.com algorithms saved successfully', 'success');
      
    } catch (error) {
      console.error('Failed to save algorithms:', error);
      this.showToast('Failed to save algorithms: ' + error.message, 'error');
    }
  }

  async saveHashesPoll() {
    const interval = parseInt(document.getElementById('hashes-poll').value, 10) || 0;
    
    try {
      await this.apiCall('/hashes_settings', {
        method: 'POST',
        body: JSON.stringify({ hashes_poll_interval: interval })
      });
      
      this.showToast('Poll interval saved successfully', 'success');
      
    } catch (error) {
      console.error('Failed to save poll interval:', error);
      this.showToast('Failed to save poll interval: ' + error.message, 'error');
    }
  }

  async trainMarkov() {
    const lang = document.getElementById('markov-language').value;
    
    try {
      await this.apiCall('/train_markov', {
        method: 'POST',
        body: JSON.stringify({ lang })
      });
      
      this.showToast(`Markov training started for ${lang}`, 'success');
      
    } catch (error) {
      console.error('Failed to start Markov training:', error);
      this.showToast('Failed to start Markov training: ' + error.message, 'error');
    }
  }

  async updateProbOrder() {
    const enabled = document.getElementById('prob-order').checked;
    
    try {
      await this.apiCall('/probabilistic_order', {
        method: 'POST',
        body: JSON.stringify({ enabled })
      });
      
      this.updateMetrics();
      this.showToast(`Probabilistic ordering ${enabled ? 'enabled' : 'disabled'}`, 'success');
      
    } catch (error) {
      console.error('Failed to update probabilistic order:', error);
      this.showToast('Failed to update probabilistic order: ' + error.message, 'error');
    }
  }

  async updateInverseOrder() {
    const enabled = document.getElementById('inverse-order').checked;
    
    try {
      await this.apiCall('/inverse_prob_order', {
        method: 'POST',
        body: JSON.stringify({ enabled })
      });
      
      this.updateMetrics();
      this.showToast(`Inverse order ${enabled ? 'enabled' : 'disabled'}`, 'success');
      
    } catch (error) {
      console.error('Failed to update inverse order:', error);
      this.showToast('Failed to update inverse order: ' + error.message, 'error');
    }
  }

  async changeMarkovLang() {
    const lang = document.getElementById('markov-language').value;
    
    try {
      await this.apiCall('/markov_lang', {
        method: 'POST',
        body: JSON.stringify({ lang })
      });
      
      this.updateMetrics();
      this.showToast(`Markov language set to ${lang}`, 'success');
      
    } catch (error) {
      console.error('Failed to change Markov language:', error);
      this.showToast('Failed to change Markov language: ' + error.message, 'error');
    }
  }

  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================

  toggleSection(button) {
    const section = button.closest('.section');
    const content = section.querySelector('.section-content');
    
    if (section.classList.contains('collapsed')) {
      section.classList.remove('collapsed');
      button.textContent = '−';
      content.style.display = 'block';
    } else {
      section.classList.add('collapsed');
      button.textContent = '+';
      content.style.display = 'none';
    }
  }

  filterTable(searchInputId, tableBodyId) {
    const searchTerm = document.getElementById(searchInputId).value.toLowerCase();
    const rows = document.querySelectorAll(`#${tableBodyId} tr`);
    
    rows.forEach(row => {
      const text = row.textContent.toLowerCase();
      row.style.display = text.includes(searchTerm) ? '' : 'none';
    });
  }

  filterList(searchInputId, listId) {
    const searchTerm = document.getElementById(searchInputId).value.toLowerCase();
    const items = document.querySelectorAll(`#${listId} li`);
    
    items.forEach(item => {
      const text = item.textContent.toLowerCase();
      item.style.display = text.includes(searchTerm) ? '' : 'none';
    });
  }

  sortTable(tableId, columnIndex) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector('tbody');
    const rows = Array.from(tbody.querySelectorAll('tr'));
    
    // Determine sort direction
    const isAscending = !table.dataset.sortAsc || table.dataset.sortAsc === 'false';
    table.dataset.sortAsc = isAscending.toString();
    
    rows.sort((a, b) => {
      const aText = a.cells[columnIndex].textContent.trim();
      const bText = b.cells[columnIndex].textContent.trim();
      
      // Try to parse as numbers
      const aNum = parseFloat(aText);
      const bNum = parseFloat(bText);
      
      if (!isNaN(aNum) && !isNaN(bNum)) {
        return isAscending ? aNum - bNum : bNum - aNum;
      } else {
        return isAscending ? 
          aText.localeCompare(bText) : 
          bText.localeCompare(aText);
      }
    });
    
    // Clear and re-append sorted rows
    tbody.innerHTML = '';
    rows.forEach(row => tbody.appendChild(row));
  }
}

// ============================================================================
// GLOBAL FUNCTIONS AND EVENT HANDLERS
// ============================================================================

// Initialize the application
let app;

// Global functions that need to be available from HTML onclick handlers
function toggleSection(button) {
  app.toggleSection(button);
}

function filterTable(searchInputId, tableBodyId) {
  app.filterTable(searchInputId, tableBodyId);
}

function filterList(searchInputId, listId) {
  app.filterList(searchInputId, listId);
}

function sortTable(tableId, columnIndex) {
  app.sortTable(tableId, columnIndex);
}

function closeModal(modalId) {
  app.closeModal(modalId);
}

function confirmAction() {
  if (app.pendingConfirmation) {
    app.pendingConfirmation();
    app.pendingConfirmation = null;
  }
  app.closeModal('confirmation-modal');
}

function logout() {
  app.logout();
}

function submitPasskey() {
  app.submitPasskey();
}

function handleLoginKeypress(event) {
  app.handleLoginKeypress(event);
}

// File management functions
function uploadDict() {
  return app.uploadDict();
}

function createMask() {
  return app.createMask();
}

function uploadRestore() {
  return app.uploadRestore();
}

function uploadHashes() {
  return app.uploadHashes();
}

function submitHash() {
  return app.submitHash();
}

function loadAllFounds() {
  return app.loadAllFounds();
}

function loadLogs() {
  return app.loadLogs();
}

function loadJobs() {
  return app.loadJobs();
}

function filterLogs() {
  app.filterLogs();
}

function clearLogFilter() {
  app.clearLogFilter();
}

function filterWorkersByStatus() {
  app.filterWorkersByStatus();
}

// Configuration functions
function saveHashesKey() {
  return app.saveHashesKey();
}

function saveHashesAlgos() {
  return app.saveHashesAlgos();
}

function saveHashesPoll() {
  return app.saveHashesPoll();
}

function trainMarkov() {
  return app.trainMarkov();
}

function updateProbOrder() {
  return app.updateProbOrder();
}

function updateInverseOrder() {
  return app.updateInverseOrder();
}

function changeMarkovLang() {
  return app.changeMarkovLang();
}

function toggleAutoRefresh() {
  app.toggleAutoRefresh();
}

// Initialize the application when the page loads
document.addEventListener('DOMContentLoaded', () => {
  app = new PortalApp();
});

// Handle page visibility changes to pause/resume updates
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    app?.stopRefreshTimer();
  } else if (app?.autoRefresh) {
    app?.startRefreshTimer();
  }
});

// Handle beforeunload to clean up WebSocket
window.addEventListener('beforeunload', () => {
  if (app?.wsConnection) {
    app.wsConnection.close();
  }
});

</script>

</body>
</html>