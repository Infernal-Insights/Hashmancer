<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hashmancer</title>
<link href="https://fonts.googleapis.com/css2?family=UnifrakturCook&display=swap" rel="stylesheet">
<style>
:root {
  --primary-color: #0f0;
  --bg-color: #000;
  --secondary-bg: #111;
  --border-color: #0f0;
  --error-color: #f44336;
  --warning-color: #ff8800;
  --success-color: #4caf50;
  --text-color: #0f0;
  --tab-active-bg: #222;
  --wall-sheep-bg: #1a1a1a;
}

* {
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
  margin: 0;
  padding: 0;
  background: var(--bg-color);
  color: var(--text-color);
  line-height: 1.5;
  overflow-x: hidden;
  font-size: 14px;
  letter-spacing: 0.01em;
}

.header {
  background: var(--secondary-bg);
  border-bottom: 2px solid var(--border-color);
  padding: 10px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  z-index: 1000;
  flex-wrap: wrap;
  gap: 10px;
}

.header h1 {
  color: var(--primary-color);
  font-family: 'Courier New', monospace;
  margin: 0;
  font-size: 0.7rem;
  font-weight: 400;
  text-shadow: 0 0 10px var(--primary-color);
  letter-spacing: 0.02em;
  line-height: 1.1;
  white-space: pre;
}

.header-controls {
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
}

.connection-status {
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  gap: 5px;
}

.connection-status.connected {
  background: rgba(76, 175, 80, 0.2);
  border: 1px solid var(--success-color);
  color: var(--success-color);
}

.connection-status.disconnected {
  background: rgba(244, 67, 54, 0.2);
  border: 1px solid var(--error-color);
  color: var(--error-color);
}

.spinner {
  display: inline-block;
  width: 12px;
  height: 12px;
  border: 2px solid transparent;
  border-top: 2px solid currentColor;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Tab Navigation */
.tab-nav {
  background: var(--secondary-bg);
  border-bottom: 1px solid var(--border-color);
  padding: 0 20px;
  display: flex;
  overflow-x: auto;
}

.tab-button {
  background: none;
  border: none;
  color: var(--text-color);
  padding: 15px 20px;
  cursor: pointer;
  border-bottom: 3px solid transparent;
  transition: all 0.3s ease;
  font-size: 1rem;
  white-space: nowrap;
  display: flex;
  align-items: center;
  gap: 8px;
}

.tab-button:hover {
  background: rgba(0, 255, 0, 0.1);
  border-bottom-color: rgba(0, 255, 0, 0.5);
}

.tab-button.active {
  background: var(--tab-active-bg);
  border-bottom-color: var(--primary-color);
  color: var(--primary-color);
}

.tab-content {
  display: none;
  padding: 20px;
  min-height: calc(100vh - 140px);
  max-width: 1200px;
  margin: 0 auto;
}

.tab-content.active {
  display: block;
}

/* Common Components */
button {
  background: var(--secondary-bg);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  padding: 10px 16px;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-family: inherit;
  font-size: 0.9rem;
  font-weight: 500;
  min-height: 40px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

button:hover:not(:disabled) {
  background: var(--primary-color);
  color: var(--bg-color);
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(0, 255, 0, 0.2);
}

button:active:not(:disabled) {
  transform: translateY(0);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

button.danger {
  border-color: var(--error-color);
  color: var(--error-color);
}

button.danger:hover:not(:disabled) {
  background: var(--error-color);
  color: white;
  box-shadow: 0 2px 8px rgba(244, 67, 54, 0.2);
}

button.success {
  border-color: var(--success-color);
  color: var(--success-color);
}

button.success:hover:not(:disabled) {
  background: var(--success-color);
  color: white;
  box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
}

button.info {
  border-color: #2196F3;
  color: #2196F3;
}

button.info:hover:not(:disabled) {
  background: #2196F3;
  color: white;
  box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
}

button.warning {
  border-color: var(--warning-color);
  color: var(--warning-color);
}

button.warning:hover:not(:disabled) {
  background: var(--warning-color);
  color: white;
  box-shadow: 0 2px 8px rgba(255, 136, 0, 0.2);
}

/* Remove conflicting old input styles since we have better ones in form-group */

/* Overview Tab */
.overview-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-bottom: 24px;
  max-width: 1000px;
}

.metrics-section {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 18px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 16px;
  margin-top: 20px;
}

.metric-card {
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 18px 15px;
  text-align: center;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.metric-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 255, 0, 0.1);
}

.metric-value {
  font-size: 2rem;
  font-weight: 700;
  color: var(--primary-color);
  display: block;
  margin-bottom: 8px;
  letter-spacing: -0.02em;
}

.metric-label {
  font-size: 0.85rem;
  opacity: 0.8;
  font-weight: 500;
  letter-spacing: 0.01em;
}

.metric-card.warning .metric-value {
  color: var(--warning-color);
}

.metric-card.error .metric-value {
  color: var(--error-color);
}

.wall-of-sheep {
  background: var(--wall-sheep-bg);
  border: 2px solid var(--primary-color);
  border-radius: 8px;
  padding: 20px;
  grid-column: 1 / -1;
  margin-top: 24px;
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
  max-width: 1000px;
}

.wall-of-sheep h3 {
  color: var(--primary-color);
  margin: 0 0 20px 0;
  text-align: center;
  font-family: 'UnifrakturCook', cursive;
  font-size: 1.6rem;
  font-weight: 400;
  text-shadow: 0 0 10px var(--primary-color);
  letter-spacing: 0.03em;
}

.sheep-list {
  max-height: 300px;
  overflow-y: auto;
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 15px;
  margin-top: 15px;
  font-family: monospace;
  line-height: 1.6;
}

.sheep-entry {
  margin-bottom: 8px;
  padding: 5px;
  background: rgba(0, 255, 0, 0.05);
  border-radius: 3px;
  word-break: break-all;
}

/* Workers and Jobs Sections */
.section-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin: 24px 0;
  max-width: 1000px;
}

.section {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 18px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.section h3 {
  color: var(--primary-color);
  margin: 0 0 20px 0;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 10px;
  font-size: 1.2rem;
  font-weight: 600;
  letter-spacing: 0.02em;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 16px;
  background: var(--secondary-bg);
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid var(--border-color);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  font-size: 0.9rem;
}

th, td {
  border: none;
  border-bottom: 1px solid rgba(0, 255, 0, 0.2);
  padding: 14px 12px;
  text-align: left;
  line-height: 1.4;
}

th {
  background: rgba(0, 255, 0, 0.1);
  font-weight: 600;
  color: var(--primary-color);
  font-size: 0.85rem;
  letter-spacing: 0.02em;
  text-transform: uppercase;
}

tr:hover {
  background: rgba(0, 255, 0, 0.05);
}

.status-indicator {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 8px;
}

.status-idle { background: var(--success-color); }
.status-working { background: var(--primary-color); }
.status-maintenance { background: var(--warning-color); }
.status-offline { background: var(--error-color); }

.progress-bar {
  width: 100%;
  height: 16px;
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 3px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--primary-color);
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--bg-color);
  font-size: 0.8rem;
  font-weight: bold;
}

/* Management Tab */
.management-sections {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: 20px;
  margin-top: 16px;
  max-width: 1000px;
}

.file-upload-area {
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  padding: 24px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 20px;
  font-size: 0.9rem;
  font-weight: 500;
  background: rgba(0, 0, 0, 0.3);
}

.file-upload-area:hover {
  border-color: var(--primary-color);
  background: rgba(0, 255, 0, 0.05);
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0, 255, 0, 0.1);
}

.item-list {
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  margin-top: 16px;
  background: var(--bg-color);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}

.item-list ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

.item-list li {
  padding: 12px 16px;
  border-bottom: 1px solid rgba(0, 255, 0, 0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.9rem;
  transition: background-color 0.2s ease;
}

.item-list li:last-child {
  border-bottom: none;
}

.item-list li:hover {
  background: rgba(0, 255, 0, 0.08);
}

/* Logs Tab */
.log-controls {
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
  align-items: center;
  flex-wrap: wrap;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--border-color);
}

.log-viewer {
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 15px;
  height: 500px;
  overflow-y: auto;
  font-family: monospace;
  font-size: 0.9rem;
  line-height: 1.4;
}

/* Advanced Config Tab */
.config-sections {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 20px;
  max-width: 1000px;
}

.config-group {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.config-group h4 {
  color: var(--primary-color);
  margin: 0 0 20px 0;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 10px;
  font-size: 1.1rem;
  font-weight: 600;
  letter-spacing: 0.02em;
}

.form-group {
  margin-bottom: 18px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  color: var(--text-color);
  font-weight: 500;
  font-size: 0.95rem;
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background: var(--bg-color);
  color: var(--text-color);
  font-size: 0.95rem;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
  box-sizing: border-box;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.1);
}

.form-group input[type="checkbox"] {
  width: auto;
  margin-right: 8px;
  margin-top: 2px;
  transform: scale(1.1);
  accent-color: var(--primary-color);
}

.form-group input[type="number"] {
  -moz-appearance: textfield;
}

.form-group input[type="number"]::-webkit-outer-spin-button,
.form-group input[type="number"]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

/* Checkbox label styling for better alignment */
.form-group label.checkbox-label {
  display: flex;
  align-items: flex-start;
  margin-bottom: 12px;
  cursor: pointer;
  line-height: 1.4;
}

.form-group label.checkbox-label input[type="checkbox"] {
  margin-right: 10px;
  margin-top: 2px;
  flex-shrink: 0;
}

/* Inline checkbox groups */
.checkbox-group {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-top: 8px;
}

.checkbox-group label {
  display: flex;
  align-items: center;
  margin-bottom: 0;
  cursor: pointer;
  font-weight: normal;
}

.checkbox-group input[type="checkbox"] {
  margin-right: 8px;
  margin-top: 0;
}

/* Small helper text styling */
.form-group small {
  display: block;
  margin-top: 4px;
  font-size: 0.8rem;
  color: #888;
  line-height: 1.3;
}

/* Select dropdown styling */
.form-group select {
  cursor: pointer;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 8px center;
  background-repeat: no-repeat;
  background-size: 16px;
  padding-right: 40px;
}

/* Textarea specific styling */
.form-group textarea {
  resize: vertical;
  min-height: 80px;
  font-family: 'Courier New', monospace;
}

/* Input group styling for inline elements */
.input-group {
  display: flex;
  gap: 10px;
  align-items: flex-end;
}

.input-group .form-group {
  margin-bottom: 0;
  flex: 1;
}

.input-group button {
  margin-bottom: 0;
  white-space: nowrap;
}

/* Button group styling for inline buttons */
.button-group {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-top: 15px;
}

.button-group button {
  flex: 1;
  min-width: 120px;
}

/* Full width buttons */
.btn-full {
  width: 100% !important;
}

/* Button spacing improvements */
.form-group button + button {
  margin-top: 10px;
}

/* Config group improvements */
.config-group {
  margin-bottom: 25px;
}

.config-group h4 {
  margin-bottom: 20px;
  font-size: 1.1rem;
}

/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 80px;
  right: 20px;
  z-index: 1000;
  max-width: 400px;
}

.toast {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 15px;
  margin-bottom: 10px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  transform: translateX(100%);
  transition: transform 0.3s ease;
}

.toast.show {
  transform: translateX(0);
}

.toast.error {
  border-color: var(--error-color);
  background: rgba(244, 67, 54, 0.1);
}

.toast.success {
  border-color: var(--success-color);
  background: rgba(76, 175, 80, 0.1);
}

.toast.warning {
  border-color: var(--warning-color);
  background: rgba(255, 136, 0, 0.1);
}

/* Login Overlay */
.login-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.95);
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 2000;
}

.login-overlay h2 {
  color: var(--primary-color);
  font-family: 'UnifrakturCook', cursive;
  margin-bottom: 20px;
}

/* Responsive Design */
@media (max-width: 768px) {
  .header {
    padding: 10px;
  }
  
  .header h1 {
    font-size: 0.4rem;
    line-height: 1.0;
  }
}

@media (max-width: 480px) {
  .header h1 {
    font-size: 0.3rem;
    line-height: 0.9;
  }
}
  
  .tab-nav {
    padding: 0 10px;
  }
  
  .tab-button {
    padding: 12px 15px;
    font-size: 0.9rem;
  }
  
  .tab-content {
    padding: 15px;
  }
  
  .overview-grid,
  .section-grid {
    grid-template-columns: 1fr;
  }
  
  .metrics-grid {
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  }
  
  .management-sections,
  .config-sections {
    grid-template-columns: 1fr;
  }
  
  .log-controls {
    flex-direction: column;
    align-items: stretch;
  }
}

/* Vast.ai Specific Styles */
.vastai-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 24px;
  gap: 20px;
  flex-wrap: wrap;
  max-width: 1200px;
}

.account-overview {
  flex: 1;
}

.account-overview h3 {
  margin: 0 0 20px 0;
  color: var(--primary-color);
  font-size: 1.4rem;
  font-weight: 600;
}

.account-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 16px;
}

.stat-card {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 16px;
  text-align: center;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 255, 0, 0.1);
}

.stat-value {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--primary-color);
  display: block;
  margin-bottom: 4px;
}

.stat-label {
  font-size: 0.8rem;
  opacity: 0.8;
  font-weight: 500;
}

.quick-actions {
  display: flex;
  gap: 12px;
  align-items: flex-start;
  flex-wrap: wrap;
}

.vastai-main-content {
  display: grid;
  grid-template-columns: 350px 1fr;
  gap: 20px;
  align-items: start;
  max-width: 1200px;
}

.vastai-left-panel {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.vastai-right-panel {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* Template Buttons */
.template-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.template-btn {
  padding: 16px 12px;
  text-align: center;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background: var(--secondary-bg);
  color: var(--text-color);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 0.85rem;
  line-height: 1.3;
}

.template-btn:hover {
  border-color: var(--primary-color);
  background: rgba(0, 255, 0, 0.05);
  transform: translateY(-1px);
}

.template-btn small {
  color: var(--primary-color);
  font-weight: 600;
}

/* Instance Filters */
.instance-filters {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.instance-filters input,
.instance-filters select {
  flex: 1;
  min-width: 200px;
}

.availability-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  gap: 16px;
  flex-wrap: wrap;
}

.sort-controls,
.view-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Instance Containers */
.instances-container,
.available-instances-container {
  max-height: 600px;
  overflow-y: auto;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  background: var(--bg-color);
}

.no-instances {
  padding: 40px 20px;
  text-align: center;
  color: var(--text-color);
  opacity: 0.7;
}

.no-instances-icon {
  font-size: 3rem;
  margin-bottom: 16px;
}

.no-instances p {
  margin: 8px 0;
  font-size: 1.1rem;
}

.no-instances small {
  font-size: 0.9rem;
}

/* Instance Cards */
.instance-card {
  border-bottom: 1px solid var(--border-color);
  padding: 16px;
  transition: background-color 0.2s ease;
}

.instance-card:last-child {
  border-bottom: none;
}

.instance-card:hover {
  background: rgba(0, 255, 0, 0.05);
}

.instance-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

.instance-info h5 {
  margin: 0 0 4px 0;
  color: var(--primary-color);
  font-size: 1rem;
}

.instance-info p {
  margin: 0;
  font-size: 0.85rem;
  opacity: 0.8;
}

.instance-status {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.8rem;
  font-weight: 600;
}

.status-running { color: var(--success-color); }
.status-loading { color: var(--warning-color); }
.status-stopped { color: var(--error-color); }
.status-available { color: var(--primary-color); }

.instance-specs {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 12px;
  margin-bottom: 12px;
}

.spec-item {
  text-align: center;
  padding: 8px;
  background: var(--secondary-bg);
  border-radius: 4px;
  border: 1px solid var(--border-color);
}

.spec-value {
  font-weight: 600;
  color: var(--primary-color);
  display: block;
  font-size: 0.9rem;
}

.spec-label {
  font-size: 0.75rem;
  opacity: 0.8;
  margin-top: 2px;
}

.instance-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
  flex-wrap: wrap;
}

.instance-actions button {
  padding: 6px 12px;
  font-size: 0.8rem;
  min-height: 32px;
}

.loading-placeholder {
  padding: 40px 20px;
  text-align: center;
  color: var(--text-color);
  opacity: 0.7;
}

.loading-placeholder .spinner {
  margin: 0 auto 16px auto;
}

/* Modal Styles */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000;
}

.modal-content {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  width: 90%;
  max-width: 800px;
  max-height: 80vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.modal-header {
  padding: 20px 24px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h3 {
  margin: 0;
  color: var(--primary-color);
}

.modal-close {
  background: none;
  border: none;
  color: var(--text-color);
  font-size: 1.5rem;
  cursor: pointer;
  padding: 0;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-body {
  padding: 24px;
  overflow-y: auto;
  flex: 1;
}

.modal-footer {
  padding: 20px 24px;
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

/* Benchmark Specific Styles */
.benchmark-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 24px;
  gap: 20px;
  flex-wrap: wrap;
  max-width: 1200px;
}

.benchmark-overview h3 {
  margin: 0 0 20px 0;
  color: var(--primary-color);
  font-size: 1.4rem;
  font-weight: 600;
}

.benchmark-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 16px;
}

.benchmark-actions {
  display: flex;
  gap: 12px;
  align-items: flex-start;
  flex-wrap: wrap;
}

.benchmark-main-content {
  display: grid;
  grid-template-columns: 350px 1fr;
  gap: 20px;
  align-items: start;
  max-width: 1200px;
}

.benchmark-left-panel,
.benchmark-right-panel {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* Worker Selection */
.worker-checkbox-list {
  max-height: 150px;
  overflow-y: auto;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 10px;
  margin-top: 8px;
  background: var(--bg-color);
}

.worker-checkbox-list label {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
  font-size: 0.9rem;
}

.worker-checkbox-list input[type="checkbox"] {
  margin-right: 8px;
}

/* Quick Benchmark Buttons */
.quick-benchmark-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

/* Progress Tracking */
.progress-overview {
  padding: 16px;
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 6px;
}

.progress-bar-container {
  margin-bottom: 16px;
}

.progress-bar {
  width: 100%;
  height: 20px;
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 10px;
  overflow: hidden;
  position: relative;
  margin-bottom: 8px;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--primary-color), var(--success-color));
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--bg-color);
  font-size: 0.8rem;
  font-weight: bold;
}

.current-test-info {
  background: var(--secondary-bg);
  padding: 12px;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  margin-bottom: 12px;
}

.current-test-info p {
  margin: 4px 0;
  font-size: 0.9rem;
}

/* Chart Styling */
.chart-controls {
  display: flex;
  gap: 10px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.chart-controls select {
  flex: 1;
  min-width: 120px;
}

.performance-chart {
  height: 300px;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background: var(--bg-color);
  display: flex;
  align-items: center;
  justify-content: center;
}

.chart-placeholder {
  text-align: center;
  color: var(--text-color);
  opacity: 0.7;
}

.chart-icon {
  font-size: 3rem;
  margin-bottom: 16px;
}

/* Results Table */
.results-filters {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.results-filters input,
.results-filters select {
  flex: 1;
  min-width: 200px;
}

.results-table-container {
  max-height: 400px;
  overflow-y: auto;
  border: 1px solid var(--border-color);
  border-radius: 6px;
}

/* Benchmark History */
.benchmark-history {
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background: var(--bg-color);
}

.no-benchmarks {
  padding: 20px;
  text-align: center;
  opacity: 0.7;
}

.benchmark-history-item {
  padding: 12px;
  border-bottom: 1px solid var(--border-color);
  transition: background-color 0.2s ease;
}

.benchmark-history-item:hover {
  background: rgba(0, 255, 0, 0.05);
}

.benchmark-history-item:last-child {
  border-bottom: none;
}

.history-item-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
}

.history-item-title {
  font-weight: 600;
  color: var(--primary-color);
  font-size: 0.9rem;
}

.history-item-date {
  font-size: 0.8rem;
  opacity: 0.8;
}

.history-item-details {
  font-size: 0.8rem;
  opacity: 0.9;
}

/* GPU Analysis */
.gpu-analysis-container {
  min-height: 200px;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background: var(--bg-color);
  display: flex;
  align-items: center;
  justify-content: center;
}

.analysis-placeholder {
  text-align: center;
  color: var(--text-color);
  opacity: 0.7;
}

.analysis-icon {
  font-size: 3rem;
  margin-bottom: 16px;
}

.gpu-comparison-card {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 16px;
  margin-bottom: 12px;
}

.gpu-comparison-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.gpu-name {
  font-weight: 600;
  color: var(--primary-color);
}

.gpu-improvement {
  font-size: 0.9rem;
  padding: 4px 8px;
  border-radius: 4px;
}

.improvement-positive {
  background: rgba(76, 175, 80, 0.2);
  color: var(--success-color);
}

.improvement-negative {
  background: rgba(244, 67, 54, 0.2);
  color: var(--error-color);
}

.improvement-neutral {
  background: rgba(255, 255, 255, 0.1);
  color: var(--text-color);
}

.gpu-speeds {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.speed-comparison {
  text-align: center;
  padding: 8px;
  background: var(--bg-color);
  border-radius: 4px;
}

.speed-label {
  font-size: 0.8rem;
  opacity: 0.8;
  margin-bottom: 4px;
}

.speed-value {
  font-weight: 600;
  color: var(--primary-color);
}

/* Responsive Design for Benchmarks */
@media (max-width: 1200px) {
  .benchmark-main-content {
    grid-template-columns: 1fr;
    gap: 32px;
  }
  
  .benchmark-header {
    flex-direction: column;
    align-items: stretch;
  }
  
  .benchmark-actions {
    justify-content: center;
  }
}

@media (max-width: 768px) {
  .benchmark-stats {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .quick-benchmark-buttons {
    grid-template-columns: 1fr;
  }
  
  .chart-controls,
  .results-filters {
    flex-direction: column;
  }
  
  .gpu-speeds {
    grid-template-columns: 1fr;
  }
}

/* Responsive Design for Vast.ai */
@media (max-width: 1200px) {
  .vastai-main-content {
    grid-template-columns: 1fr;
    gap: 32px;
  }
  
  .vastai-header {
    flex-direction: column;
    align-items: stretch;
  }
  
  .quick-actions {
    justify-content: center;
  }
}

@media (max-width: 768px) {
  .account-stats {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .template-buttons {
    grid-template-columns: 1fr;
  }
  
  .instance-filters,
  .availability-controls {
    flex-direction: column;
    align-items: stretch;
  }
  
  .instance-specs {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .instance-actions {
    justify-content: center;
  }
}

/* Animations */
@keyframes runes {
  from { transform: translate(-10%, -10%) rotate(0deg); }
  to   { transform: translate(10%, 10%) rotate(360deg); }
}

body::before {
  content: "ᚠᚢᚦᚩᚱᚴ";
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: 'UnifrakturCook', cursive;
  font-size: 8rem;
  color: var(--primary-color);
  opacity: 0.03;
  pointer-events: none;
  animation: runes 40s linear infinite;
  z-index: -1;
}

/* Task Pipeline Styles */
.task-pipeline-item {
  background: #2a2a2a;
  border: 1px solid #444;
  border-radius: 6px;
  padding: 12px;
  margin-bottom: 10px;
  cursor: grab;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.task-pipeline-item:hover {
  background: #333;
  border-color: var(--primary-color);
}

.task-pipeline-item.dragging {
  opacity: 0.5;
  cursor: grabbing;
}

.task-info {
  display: flex;
  align-items: center;
  gap: 10px;
  flex: 1;
}

.task-priority {
  background: var(--primary-color);
  color: #000;
  border-radius: 4px;
  padding: 2px 8px;
  font-size: 0.8em;
  font-weight: bold;
  min-width: 20px;
  text-align: center;
}

.task-name {
  font-weight: 600;
  color: var(--text-color);
}

.task-details {
  font-size: 0.8em;
  color: #888;
  margin-left: 5px;
}

.task-actions {
  display: flex;
  gap: 5px;
}

.task-action-btn {
  background: #444;
  border: none;
  color: #fff;
  padding: 4px 8px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 0.8em;
  transition: background 0.2s;
}

.task-action-btn:hover {
  background: #555;
}

.task-action-btn.delete:hover {
  background: var(--error-color);
}

.task-pipeline-empty {
  text-align: center;
  color: #666;
  padding: 40px 20px;
  font-style: italic;
}

.drag-handle {
  color: #666;
  cursor: grab;
  padding: 0 5px;
  font-size: 1.2em;
}

.drag-handle:hover {
  color: var(--primary-color);
}

.execution-strategy-info {
  background: #1a1a1a;
  border: 1px solid #333;
  border-radius: 4px;
  padding: 10px;
  margin-top: 10px;
  font-size: 0.9em;
  color: #aaa;
}
</style>
</head>
<body>

<!-- Toast Container -->
<div class="toast-container" id="toast-container"></div>

<!-- Login Overlay -->
<div class="login-overlay" id="login-overlay">
  <h2>Hashmancer Portal Login</h2>
  <input type="password" id="passkey" placeholder="Enter passkey" onkeypress="handleLoginKeypress(event)">
  <button onclick="submitPasskey()">Login</button>
  <div id="login-error" style="color: var(--error-color); margin-top: 10px;"></div>
</div>

<!-- Header -->
<div class="header">
  <h1>██╗  ██╗ █████╗ ███████╗██╗  ██╗███╗   ███╗ █████╗ ███╗   ██╗ ██████╗███████╗██████╗ 
██║  ██║██╔══██╗██╔════╝██║  ██║████╗ ████║██╔══██╗████╗  ██║██╔════╝██╔════╝██╔══██╗
███████║███████║███████╗███████║██╔████╔██║███████║██╔██╗ ██║██║     █████╗  ██████╔╝
██╔══██║██╔══██║╚════██║██╔══██║██║╚██╔╝██║██╔══██║██║╚██╗██║██║     ██╔══╝  ██╔══██╗
██║  ██║██║  ██║███████║██║  ██║██║ ╚═╝ ██║██║  ██║██║ ╚████║╚██████╗███████╗██║  ██║
╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝╚══════╝╚═╝  ╚═╝</h1>
  <div class="header-controls">
    <div class="connection-status disconnected" id="connection-status">
      <span class="spinner" id="connection-spinner" style="display: none;"></span>
      <span id="connection-text">Connecting...</span>
    </div>
    <button onclick="toggleAutoRefresh()" id="auto-refresh-btn">⏸️ Pause Updates</button>
    <button onclick="logout()" class="danger">Logout</button>
  </div>
</div>

<!-- Tab Navigation -->
<div class="tab-nav">
  <button class="tab-button active" data-tab="overview" onclick="switchTab('overview')">
    📊 System Overview
  </button>
  <button class="tab-button" data-tab="management" onclick="switchTab('management')">
    ⚙️ Management
  </button>
  <button class="tab-button" data-tab="logs" onclick="switchTab('logs')">
    📋 Logs
  </button>
  <button class="tab-button" data-tab="benchmarks" onclick="switchTab('benchmarks')">
    ⚡ Benchmarks
  </button>
  <button class="tab-button" data-tab="config" onclick="switchTab('config')">
    🔧 Advanced Config
  </button>
</div>

<!-- Tab Content -->

<!-- System Overview Tab -->
<div id="overview-tab" class="tab-content active">
  <div class="overview-grid">
    <div class="metrics-section">
      <h3>📈 System Metrics</h3>
      <div class="metrics-grid">
        <div class="metric-card">
          <span class="metric-value" id="active-workers">0</span>
          <div class="metric-label">Active Workers</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="missing-workers">0</span>
          <div class="metric-label">Missing Workers</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="queue-length">0</span>
          <div class="metric-label">Queue Length</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="total-found">0</span>
          <div class="metric-label">Total Found</div>
        </div>
      </div>
      <div style="text-align: center; margin-top: 15px; opacity: 0.7;">
        Last updated: <span id="last-updated">never</span>
      </div>
    </div>

    <div class="metrics-section">
      <h3>🖥️ Worker Stats</h3>
      <div class="metrics-grid">
        <div class="metric-card">
          <span class="metric-value" id="avg-gpu-temp">N/A</span>
          <div class="metric-label">Avg GPU Temp</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="avg-ram-usage">N/A</span>
          <div class="metric-label">Avg RAM Usage</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="avg-cpu-util">N/A</span>
          <div class="metric-label">Avg CPU Usage</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="avg-gpu-util">N/A</span>
          <div class="metric-label">Avg GPU Usage</div>
        </div>
      </div>
    </div>
  </div>

  <div class="section-grid">
    <div class="section">
      <h3>👷 Active Workers</h3>
      <div style="max-height: 300px; overflow-y: auto;">
        <table>
          <thead>
            <tr>
              <th>Worker</th>
              <th>Status</th>
              <th>Job</th>
              <th>GPU Temp</th>
              <th>RAM</th>
              <th>CPU</th>
              <th>GPU</th>
            </tr>
          </thead>
          <tbody id="workers-overview-table">
            <tr>
              <td colspan="7" style="text-align: center; opacity: 0.7;">Loading workers...</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="section">
      <h3>⚙️ Active Jobs</h3>
      <div style="max-height: 300px; overflow-y: auto;">
        <table>
          <thead>
            <tr>
              <th>Job ID</th>
              <th>Status</th>
              <th>Attack Mode</th>
              <th>Progress</th>
            </tr>
          </thead>
          <tbody id="jobs-overview-table">
            <tr>
              <td colspan="4" style="text-align: center; opacity: 0.7;">Loading jobs...</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="wall-of-sheep">
    <h3>🐑 The Wall of Sheep 🐑</h3>
    <button onclick="refreshWallOfSheep()" style="float: right; margin-top: -40px;">🔄 Refresh</button>
    <div class="sheep-list" id="wall-of-sheep-content">
      Loading found hashes...
    </div>
  </div>
</div>

<!-- Management Tab -->
<div id="management-tab" class="tab-content">
  <div class="management-sections">
    
    <!-- Dictionary Management -->
    <div class="section">
      <h3>📚 Dictionary Management</h3>
      <div class="item-list">
        <ul id="dict-list">
          <li style="text-align: center; opacity: 0.7;">Loading dictionaries...</li>
        </ul>
      </div>
      <div class="file-upload-area" onclick="document.getElementById('dict-upload').click()">
        📤 Click to upload dictionaries or drag & drop files here
        <input type="file" id="dict-upload" accept=".txt,.dic,.wordlist" multiple style="display: none;">
      </div>
    </div>

    <!-- Mask Management -->
    <div class="section">
      <h3>🎭 Mask Management</h3>
      <div class="item-list">
        <ul id="mask-list">
          <li style="text-align: center; opacity: 0.7;">Loading masks...</li>
        </ul>
      </div>
      <div style="margin-top: 15px;">
        <input type="text" id="mask-name" placeholder="Mask name" style="width: 100%; margin-bottom: 8px;">
        <textarea id="mask-content" rows="2" placeholder="Mask content (e.g., ?a?a?a?a?a?a?a?a)" style="width: 100%; margin-bottom: 8px;"></textarea>
        <button onclick="createMask()" class="success" style="width: 100%;">➕ Create Mask</button>
      </div>
    </div>

    <!-- Worker Management -->
    <div class="section">
      <h3>👷 Worker Management</h3>
      <div style="max-height: 250px; overflow-y: auto;">
        <table>
          <thead>
            <tr>
              <th>Worker</th>
              <th>Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="workers-management-table">
            <tr>
              <td colspan="3" style="text-align: center; opacity: 0.7;">Loading workers...</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Job Management -->
    <div class="section">
      <h3>⚙️ Job Management</h3>
      <div style="max-height: 250px; overflow-y: auto;">
        <table>
          <thead>
            <tr>
              <th>Job ID</th>
              <th>Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="jobs-management-table">
            <tr>
              <td colspan="3" style="text-align: center; opacity: 0.7;">Loading jobs...</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Hash Import -->
    <div class="section">
      <h3>🔒 Hash Import</h3>
      <div class="form-group">
        <label>Upload Hash File:</label>
        <input type="file" id="hash-file" accept=".txt,.hash">
        <input type="number" id="hash-mode" placeholder="Hash mode (e.g., 0 for MD5)" style="margin-top: 8px;">
        <button onclick="uploadHashes()" class="success" style="width: 100%; margin-top: 8px;">📤 Upload Hashes</button>
      </div>
      <div class="form-group">
        <label>Add Single Hash:</label>
        <input type="text" id="single-hash" placeholder="Enter hash value">
        <input type="number" id="single-hash-mode" placeholder="Hash mode" style="margin-top: 8px;">
        <button onclick="submitHash()" class="success" style="width: 100%; margin-top: 8px;">➕ Add Hash</button>
      </div>
    </div>

    <!-- Restore Files -->
    <div class="section">
      <h3>💾 Restore Files</h3>
      <div class="item-list">
        <ul id="restore-list">
          <li style="text-align: center; opacity: 0.7;">Loading restore files...</li>
        </ul>
      </div>
      <div class="file-upload-area" onclick="document.getElementById('restore-upload').click()">
        📤 Click to upload restore file
        <input type="file" id="restore-upload" accept=".restore" style="display: none;">
      </div>
    </div>
  </div>
</div>

<!-- Logs Tab -->
<div id="logs-tab" class="tab-content">
  <div class="log-controls">
    <select id="log-type">
      <option value="server">Server Logs</option>
      <option value="worker">Worker Logs</option>
      <option value="job">Job Logs</option>
      <option value="all">All Logs</option>
    </select>
    <select id="log-worker">
      <option value="">All Workers</option>
    </select>
    <input type="text" id="log-search" placeholder="🔍 Search logs..." style="flex: 1; min-width: 200px;">
    <button onclick="loadLogs()">🔄 Refresh</button>
    <button onclick="clearLogs()" class="danger">🗑️ Clear</button>
    <button onclick="downloadLogs()" class="success">📥 Download</button>
  </div>
  <div class="log-viewer" id="log-content">
    Loading logs...
  </div>
</div>

<!-- Benchmarks Tab -->
<div id="benchmarks-tab" class="tab-content">
  <!-- Benchmark Overview Header -->
  <div class="benchmark-header">
    <div class="benchmark-overview">
      <h3>⚡ Performance Benchmarking Dashboard</h3>
      <div class="benchmark-stats">
        <div class="stat-card">
          <div class="stat-value" id="total-benchmarks">0</div>
          <div class="stat-label">Total Benchmarks</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="active-workers-bench">0</div>
          <div class="stat-label">Available Workers</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="best-hashcat-speed">0 H/s</div>
          <div class="stat-label">Best Hashcat Speed</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="best-darkling-speed">0 H/s</div>
          <div class="stat-label">Best Darkling Speed</div>
        </div>
      </div>
    </div>
    <div class="benchmark-actions">
      <button onclick="runQuickBenchmark()" class="success">🚀 Quick Benchmark</button>
      <button onclick="runFullBenchmark()" class="warning">📊 Full Suite</button>
      <button onclick="exportBenchmarkData()" class="info">📋 Export Data</button>
    </div>
  </div>

  <div class="benchmark-main-content">
    <!-- Left Panel: Configuration & Controls -->
    <div class="benchmark-left-panel">
      <!-- Benchmark Configuration -->
      <div class="config-group">
        <h4>⚙️ Benchmark Configuration</h4>
        <div class="form-group">
          <label>Target Workers:</label>
          <div class="checkbox-group" id="worker-selection">
            <label>
              <input type="checkbox" id="select-all-workers" onchange="toggleAllWorkers()" checked>
              Select All Workers
            </label>
          </div>
          <div id="worker-list" class="worker-checkbox-list">
            <!-- Dynamic worker list -->
          </div>
        </div>
        <div class="form-group">
          <label>Applications to Test:</label>
          <div class="checkbox-group">
            <label>
              <input type="checkbox" id="test-hashcat" checked>
              🔥 Hashcat
            </label>
            <label>
              <input type="checkbox" id="test-darkling" checked>
              ✨ Darkling
            </label>
          </div>
        </div>
        <div class="form-group">
          <label>Hash Types to Benchmark:</label>
          <select id="benchmark-hash-type">
            <option value="all">All Supported Types</option>
            <option value="0">MD5 (0)</option>
            <option value="100">SHA1 (100)</option>
            <option value="1400">SHA256 (1400)</option>
            <option value="1700">SHA512 (1700)</option>
            <option value="22000">WPA2 (22000)</option>
            <option value="1000">NTLM (1000)</option>
          </select>
        </div>
        <div class="form-group">
          <label>Benchmark Duration:</label>
          <select id="benchmark-duration">
            <option value="30">30 seconds (Quick)</option>
            <option value="60" selected>1 minute (Standard)</option>
            <option value="300">5 minutes (Extended)</option>
            <option value="600">10 minutes (Thorough)</option>
          </select>
        </div>
        <div class="form-group">
          <label>Attack Mode:</label>
          <select id="benchmark-attack-mode">
            <option value="3">Brute Force (Mode 3)</option>
            <option value="0">Dictionary (Mode 0)</option>
            <option value="1">Combinator (Mode 1)</option>
            <option value="6">Hybrid Dict + Mask (Mode 6)</option>
          </select>
        </div>
        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="save-benchmark-log" checked>
            💾 Save detailed logs for analysis
          </label>
        </div>
        <button onclick="startCustomBenchmark()" class="success" style="width: 100%;">⚡ Start Custom Benchmark</button>
      </div>

      <!-- Quick Actions -->
      <div class="config-group">
        <h4>🏁 Quick Benchmarks</h4>
        <div class="quick-benchmark-buttons">
          <button onclick="runHashcatOnly()" class="template-btn">🔥 Hashcat Only<br><small>Test all workers</small></button>
          <button onclick="runDarklingOnly()" class="template-btn">✨ Darkling Only<br><small>Test all workers</small></button>
          <button onclick="runComparison()" class="template-btn">⚖️ Head-to-Head<br><small>Compare both</small></button>
          <button onclick="runGPUTest()" class="template-btn">🖥️ GPU Stress<br><small>Maximum load</small></button>
        </div>
      </div>

      <!-- Benchmark History -->
      <div class="config-group">
        <h4>📈 Recent Results</h4>
        <div class="benchmark-history" id="recent-benchmarks">
          <div class="no-benchmarks">
            <p>No recent benchmarks</p>
            <small>Run a benchmark to see results here</small>
          </div>
        </div>
        <button onclick="viewFullHistory()" class="info" style="width: 100%; margin-top: 10px;">📊 View Full History</button>
      </div>
    </div>

    <!-- Right Panel: Results & Analytics -->
    <div class="benchmark-right-panel">
      <!-- Live Progress -->
      <div class="config-group" id="benchmark-progress-section" style="display: none;">
        <h4>🔄 Benchmark in Progress</h4>
        <div class="progress-overview">
          <div class="progress-bar-container">
            <div class="progress-bar">
              <div class="progress-fill" id="benchmark-progress-bar" style="width: 0%;"></div>
            </div>
            <span id="benchmark-progress-text">0% Complete</span>
          </div>
          <div class="current-test-info">
            <p><strong>Current Test:</strong> <span id="current-test-name">-</span></p>
            <p><strong>Worker:</strong> <span id="current-worker">-</span></p>
            <p><strong>Application:</strong> <span id="current-app">-</span></p>
            <p><strong>Speed:</strong> <span id="current-speed">-</span></p>
          </div>
          <button onclick="cancelBenchmark()" class="danger">❌ Cancel Benchmark</button>
        </div>
      </div>

      <!-- Performance Comparison Chart -->
      <div class="config-group">
        <h4>📉 Performance Comparison</h4>
        <div class="chart-controls">
          <select id="chart-filter-gpu">
            <option value="all">All GPUs</option>
            <option value="rtx4090">RTX 4090</option>
            <option value="rtx4080">RTX 4080</option>
            <option value="rtx3090">RTX 3090</option>
            <option value="a100">A100</option>
          </select>
          <select id="chart-filter-hash">
            <option value="all">All Hash Types</option>
            <option value="0">MD5</option>
            <option value="100">SHA1</option>
            <option value="1400">SHA256</option>
          </select>
          <select id="chart-timeframe">
            <option value="7">Last 7 days</option>
            <option value="30" selected>Last 30 days</option>
            <option value="90">Last 90 days</option>
            <option value="all">All time</option>
          </select>
        </div>
        <div class="performance-chart" id="performance-chart">
          <div class="chart-placeholder">
            <div class="chart-icon">📈</div>
            <p>Run benchmarks to see performance data</p>
          </div>
        </div>
      </div>

      <!-- Detailed Results Table -->
      <div class="config-group">
        <h4>📋 Benchmark Results</h4>
        <div class="results-filters">
          <input type="text" id="results-search" placeholder="🔍 Search results..." oninput="filterResults()">
          <select id="results-sort" onchange="sortResults()">
            <option value="date">Sort by Date</option>
            <option value="speed">Sort by Speed</option>
            <option value="gpu">Sort by GPU</option>
            <option value="app">Sort by Application</option>
          </select>
        </div>
        <div class="results-table-container">
          <table id="benchmark-results-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Worker</th>
                <th>GPU</th>
                <th>App</th>
                <th>Hash Type</th>
                <th>Speed</th>
                <th>Improvement</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="benchmark-results-body">
              <tr>
                <td colspan="8" style="text-align: center; opacity: 0.7;">No benchmark results yet</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- GPU Analysis -->
      <div class="config-group">
        <h4>🖥️ GPU Performance Analysis</h4>
        <div class="gpu-analysis-container" id="gpu-analysis">
          <div class="analysis-placeholder">
            <div class="analysis-icon">🖥️</div>
            <p>GPU analysis will appear after benchmarks</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Benchmark Details Modal -->
  <div id="benchmark-modal" class="modal" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="modal-benchmark-title">Benchmark Details</h3>
        <button onclick="closeBenchmarkModal()" class="modal-close">×</button>
      </div>
      <div class="modal-body" id="modal-benchmark-body">
        <!-- Dynamic content -->
      </div>
      <div class="modal-footer">
        <button onclick="exportBenchmarkDetails()" class="success">Export Details</button>
        <button onclick="closeBenchmarkModal()" class="info">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Advanced Config Tab -->
<div id="config-tab" class="tab-content">
  <div class="config-sections">
    
    <!-- LLM Configuration -->
    <div class="config-group">
      <h4>🧠 LLM Configuration</h4>
      <div class="form-group">
        <label>Dataset Path:</label>
        <input type="text" id="llm-dataset" placeholder="/path/to/dataset">
      </div>
      <div class="form-group">
        <label>Base Model Path:</label>
        <input type="text" id="llm-base-model" placeholder="/path/to/base/model">
      </div>
      <div class="form-group">
        <label>Epochs:</label>
        <input type="number" id="llm-epochs" value="1" min="1">
      </div>
      <div class="form-group">
        <label>Learning Rate:</label>
        <input type="number" id="llm-lr" value="0.0001" step="0.0001">
      </div>
      <div class="form-group">
        <label>Output Directory:</label>
        <input type="text" id="llm-output" placeholder="/path/to/output">
      </div>
      <button onclick="trainLLM()" class="success" style="width: 100%;">🎯 Train LLM</button>
    </div>

    <!-- Job Automation Settings -->
    <div class="config-group">
      <h4>🤖 Job Automation Settings</h4>
      <div class="form-group">
        <label>Default Attack Mode:</label>
        <select id="default-attack-mode">
          <option value="mask" selected>Mask Attack</option>
          <option value="dictionary">Dictionary Attack</option>
          <option value="combinator">Combinator Attack</option>
          <option value="hybrid">Hybrid Attack</option>
        </select>
      </div>
      <div class="form-group">
        <label>Execution Strategy:</label>
        <select id="execution-strategy">
          <option value="simple">Simple: Use default attack mode only</option>
          <option value="parallel" selected>Parallel: Run multiple attacks simultaneously</option>
          <option value="sequential">Sequential: Run attacks in priority order</option>
        </select>
      </div>
      
      <!-- Task Pipeline Configuration -->
      <div id="task-pipeline-config" style="margin-top: 20px;">
        <h5>🔄 Task Execution Pipeline</h5>
        <p style="font-size: 0.9em; color: #888; margin-bottom: 15px;">
          Configure the order of attack methods. Tasks run sequentially based on priority, automatically failing over to the next task when exhausted.
        </p>
        
        <div id="task-pipeline-list" style="background: #1a1a1a; border: 1px solid #333; border-radius: 5px; padding: 10px; min-height: 200px;">
          <!-- Task items will be populated here -->
        </div>
        
        <div style="margin-top: 10px; display: flex; gap: 10px;">
          <button onclick="app.addTaskToPipeline()" class="success" style="flex: 1;">➕ Add Task</button>
          <button onclick="app.addMaskPreset()" class="info" style="flex: 1;">🎯 Add Mask Preset</button>
          <button onclick="app.resetTaskPipeline()" class="danger" style="flex: 1;">🔄 Reset to Default</button>
        </div>
      </div>
      
      <!-- Advanced Hashtopolis Features -->
      <div style="margin-top: 20px;">
        <h5>🔧 Advanced Configuration</h5>
        <div class="form-group">
          <label>Chunk Size (seconds):</label>
          <input type="number" id="chunk-size" value="600" min="60" max="3600" placeholder="600">
          <small style="color: #888; display: block;">Time each agent works on a chunk before reporting</small>
        </div>
        <div class="form-group">
          <label>Benchmark Type:</label>
          <select id="benchmark-type">
            <option value="speed" selected>Speed Test (Recommended)</option>
            <option value="runtime">Runtime (For large salted lists)</option>
          </select>
        </div>
        <div class="form-group">
          <label>Max Agents per Task:</label>
          <input type="number" id="max-agents" value="10" min="1" max="100" placeholder="10">
          <small style="color: #888; display: block;">Maximum agents assigned to each task</small>
        </div>
        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="optimized-kernel">
            Use Optimized Kernel (-O flag)
          </label>
        </div>
        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="small-tasks">
            Small Tasks (Single agent processing)
          </label>
        </div>
      </div>

      <!-- Quick Settings -->
      <div style="margin-top: 20px;">
        <h5>⚡ Quick Settings</h5>
        <div class="form-group">
          <label>Default Mask:</label>
          <input type="text" id="default-mask" value="?l?l?l?l?l?l?l?l" placeholder="e.g., ?l?l?l?l?l?l?l?l">
        </div>
        <div class="form-group">
          <label>Default Dictionary:</label>
          <input type="text" id="default-dictionary" value="rockyou.txt" placeholder="e.g., rockyou.txt">
        </div>
        <div class="form-group">
          <label>Default Rules:</label>
          <input type="text" id="default-rules" value="best64.rule" placeholder="e.g., best64.rule">
        </div>
      </div>
      
      <button onclick="app.saveJobSettings()" class="success" style="width: 100%; margin-top: 15px;">💾 Save Job Settings</button>
    </div>

    <!-- Notification System -->
    <div class="config-group">
      <h4>🔔 Notification System</h4>
      <div class="form-group">
        <label class="checkbox-label">
          <input type="checkbox" id="notifications-enabled" checked>
          Enable notifications
        </label>
      </div>
      <div class="form-group">
        <label>Email Address:</label>
        <input type="email" id="notification-email" placeholder="your@email.com">
      </div>
      <div class="form-group">
        <label>Notification Events:</label>
        <div style="margin-top: 5px;">
          <label class="checkbox-label">
            <input type="checkbox" id="notify-job-complete" checked>
            Job completion
          </label>
          <label class="checkbox-label">
            <input type="checkbox" id="notify-hash-cracked" checked>
            Hash cracked
          </label>
          <label class="checkbox-label">
            <input type="checkbox" id="notify-task-failed">
            Task failure
          </label>
          <label class="checkbox-label">
            <input type="checkbox" id="notify-agent-offline">
            Agent offline
          </label>
        </div>
      </div>
      <div class="form-group">
        <label>Discord Webhook URL (Optional):</label>
        <input type="url" id="discord-webhook" placeholder="https://discord.com/api/webhooks/...">
      </div>
      <div class="form-group">
        <label>Slack Webhook URL (Optional):</label>
        <input type="url" id="slack-webhook" placeholder="https://hooks.slack.com/services/...">
      </div>
      <button onclick="app.saveNotificationSettings()" class="info" style="width: 100%;">🔔 Save Notification Settings</button>
      <button onclick="app.testNotifications()" class="success" style="width: 100%; margin-top: 10px;">🧪 Test Notifications</button>
    </div>

    <!-- Task Templates (Supertasks) -->
    <div class="config-group">
      <h4>📋 Task Templates</h4>
      <p style="font-size: 0.9em; color: #888; margin-bottom: 15px;">
        Save current pipeline as reusable templates (like Hashtopolis Supertasks)
      </p>
      
      <div class="form-group">
        <label>Template Name:</label>
        <input type="text" id="template-name" placeholder="e.g., Corporate Password Audit">
      </div>
      <div class="form-group">
        <label>Description:</label>
        <textarea id="template-description" placeholder="Describe this template..." rows="2" style="width: 100%; background: #1a1a1a; border: 1px solid #333; color: #fff; padding: 8px; border-radius: 4px;"></textarea>
      </div>
      
      <div style="display: flex; gap: 10px; margin-bottom: 15px;">
        <button onclick="app.saveCurrentPipelineAsTemplate()" class="success" style="flex: 1;">💾 Save as Template</button>
        <button onclick="app.loadTemplate()" class="info" style="flex: 1;">📂 Load Template</button>
      </div>
      
      <div id="template-list" style="background: #1a1a1a; border: 1px solid #333; border-radius: 5px; padding: 10px; min-height: 100px;">
        <div style="color: #666; text-align: center; padding: 20px;">No templates saved</div>
      </div>
      
      <button onclick="app.refreshTemplateList()" class="secondary" style="width: 100%; margin-top: 10px;">🔄 Refresh Templates</button>
    </div>

    <!-- 3rd Party Services Configuration -->
    <div class="config-group">
      <h4>🔗 3rd Party Services</h4>
      <div class="form-group">
        <label class="checkbox-label">
          <input type="checkbox" id="service-vastai" onchange="toggleService('vastai')">
          🖥️ Vast.ai Integration
        </label>
      </div>
      <div class="form-group">
        <label class="checkbox-label">
          <input type="checkbox" id="service-hashescom" onchange="toggleService('hashescom')">
          🔍 Hashes.com Integration
        </label>
      </div>
      <div class="form-group">
        <label class="checkbox-label">
          <input type="checkbox" id="service-saladai" onchange="toggleService('saladai')">
          🥗 Salad AI Integration
        </label>
      </div>
      <div class="form-group">
        <label class="checkbox-label">
          <input type="checkbox" id="service-grok" onchange="toggleService('grok')">
          🤖 Grok Integration
        </label>
      </div>
      <button onclick="saveServicesConfig()" class="success" style="width: 100%;">💾 Save Service Settings</button>
    </div>

    <!-- Markov Configuration -->
    <div class="config-group">
      <h4>🔄 Markov Configuration</h4>
      <div class="form-group">
        <label>Language:</label>
        <select id="markov-language">
          <option value="english">English</option>
          <option value="german">German</option>
          <option value="french">French</option>
          <option value="spanish">Spanish</option>
        </select>
      </div>
      <div class="form-group">
        <label class="checkbox-label">
          <input type="checkbox" id="prob-order">
          Probabilistic Ordering
        </label>
      </div>
      <div class="form-group">
        <label class="checkbox-label">
          <input type="checkbox" id="inverse-order">
          Inverse Order
        </label>
      </div>
      <div style="margin-bottom: 15px;">
        <button onclick="trainMarkov()" class="success">🏋️ Train Markov</button>
        <button onclick="changeMarkovLang()">✅ Set Active</button>
      </div>
      <div style="font-size: 0.9rem; opacity: 0.8;">
        Current Language: <span id="current-markov-lang">-</span><br>
        Probabilistic Order: <span id="current-prob-order">-</span><br>
        Inverse Order: <span id="current-inverse-order">-</span>
      </div>
    </div>


    <!-- Broadcast Configuration -->
    <div class="config-group">
      <h4>📡 Broadcast Configuration</h4>
      <div class="form-group">
        <label class="checkbox-label">
          <input type="checkbox" id="broadcast-enabled">
          Enable Worker Broadcasting
        </label>
      </div>
      <div class="form-group">
        <label>Broadcast Interval (seconds):</label>
        <input type="number" id="broadcast-interval" value="30" min="1">
      </div>
      <div class="form-group">
        <label>Discovery Port:</label>
        <input type="number" id="discovery-port" value="8888" min="1024" max="65535">
      </div>
      <button onclick="saveBroadcastConfig()" class="success" style="width: 100%;">💾 Save Broadcast Config</button>
    </div>

    <!-- Algorithm Parameters -->
    <div class="config-group">
      <h4>🧮 Algorithm Parameters</h4>
      <div class="form-group">
        <label>Algorithm:</label>
        <input type="text" id="algo-name" placeholder="Algorithm name">
      </div>
      <div class="form-group">
        <label>Max Mask Length:</label>
        <input type="number" id="algo-masklen" placeholder="Max mask length">
      </div>
      <div class="form-group">
        <label>Rule File:</label>
        <input type="text" id="algo-rule" placeholder="Rule file path">
      </div>
      <button onclick="saveAlgoParams()" class="success" style="width: 100%;">💾 Save Parameters</button>
      <div style="background: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; margin-top: 10px; max-height: 150px; overflow-y: auto;">
        <pre id="algo-params-output" style="margin: 0; font-size: 0.8rem;">Loading...</pre>
      </div>
    </div>

    <!-- Server Configuration -->
    <div class="config-group">
      <h4>⚙️ Server Configuration</h4>
      <div class="form-group">
        <label>Max Import Size (MB):</label>
        <input type="number" id="max-import-size" min="1" max="1000" value="100">
      </div>
      <div class="form-group">
        <label>Default Hash Priority:</label>
        <input type="number" id="default-priority" min="0" max="10" value="5">
      </div>
      <div class="form-group">
        <label class="checkbox-label">
          <input type="checkbox" id="auto-backup">
          Enable Auto Backup
        </label>
      </div>
      <div class="form-group">
        <label>Backup Interval (hours):</label>
        <input type="number" id="backup-interval" value="24" min="1">
      </div>
      <button onclick="saveServerConfig()" class="success" style="width: 100%;">💾 Save Server Config</button>
    </div>
  </div>
</div>

<!-- Vast.ai Tab (dynamically shown) -->
<div id="vastai-tab" class="tab-content" style="display: none;">
  <!-- Account Overview Header -->
  <div class="vastai-header">
    <div class="account-overview">
      <h3>🖥️ Vast.ai Management Dashboard</h3>
      <div class="account-stats">
        <div class="stat-card">
          <div class="stat-value" id="vastai-balance">$0.00</div>
          <div class="stat-label">Account Balance</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="vastai-active-instances">0</div>
          <div class="stat-label">Active Instances</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="vastai-monthly-spend">$0.00</div>
          <div class="stat-label">Monthly Spend</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="vastai-total-hours">0h</div>
          <div class="stat-label">Total Runtime</div>
        </div>
      </div>
    </div>
    <div class="quick-actions">
      <button onclick="refreshVastaiDashboard()" class="info">🔄 Refresh All</button>
      <button onclick="openVastaiDocs()" class="info">📚 Docs</button>
      <button onclick="showBillingHistory()" class="warning">💳 Billing</button>
    </div>
  </div>

  <div class="vastai-main-content">
    <!-- Left Column: Configuration & Search -->
    <div class="vastai-left-panel">
      <!-- Account Configuration -->
      <div class="config-group">
        <h4>🔑 Account Configuration</h4>
        <div class="form-group">
          <label>API Key:</label>
          <div class="input-group">
            <input type="password" id="vastai-api-key" placeholder="Enter your Vast.ai API key">
            <button onclick="testVastaiConnection()" class="info">🧪 Test</button>
          </div>
          <small>Get your API key from <a href="https://vast.ai/console/account/" target="_blank">Vast.ai Console</a></small>
        </div>
        <div class="form-group">
          <label>Auto Budget Limit ($/hour):</label>
          <input type="number" id="vastai-budget" value="5.00" step="0.01" min="0">
          <small>Maximum hourly spend for auto-launched instances</small>
        </div>
        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="vastai-auto-destroy" checked>
            🗑️ Auto-destroy instances when job completes
          </label>
        </div>
        <button onclick="saveVastaiConfig()" class="success" style="width: 100%;">💾 Save Configuration</button>
      </div>

      <!-- Instance Search & Filter -->
      <div class="config-group">
        <h4>🔍 Find Instances</h4>
        <div class="form-group">
          <label>GPU Type:</label>
          <select id="vastai-search-gpu" onchange="updateInstanceSearch()">
            <option value="">Any GPU</option>
            <option value="RTX_4090">RTX 4090</option>
            <option value="RTX_4080">RTX 4080</option>
            <option value="RTX_3090">RTX 3090</option>
            <option value="RTX_3080">RTX 3080</option>
            <option value="A100">A100</option>
            <option value="H100">H100</option>
            <option value="V100">V100</option>
          </select>
        </div>
        <div class="form-group">
          <label>Max Price ($/hour):</label>
          <input type="number" id="vastai-search-max-price" value="2.00" step="0.01" min="0" onchange="updateInstanceSearch()">
        </div>
        <div class="form-group">
          <label>Min RAM (GB):</label>
          <select id="vastai-search-ram" onchange="updateInstanceSearch()">
            <option value="8">8 GB+</option>
            <option value="16">16 GB+</option>
            <option value="32" selected>32 GB+</option>
            <option value="64">64 GB+</option>
            <option value="128">128 GB+</option>
          </select>
        </div>
        <div class="form-group">
          <label>Storage (GB):</label>
          <input type="number" id="vastai-search-storage" value="100" min="50" step="10" onchange="updateInstanceSearch()">
        </div>
        <div class="form-group">
          <label>Location:</label>
          <select id="vastai-search-location" onchange="updateInstanceSearch()">
            <option value="">Any Location</option>
            <option value="US">United States</option>
            <option value="EU">Europe</option>
            <option value="AS">Asia</option>
          </select>
        </div>
        <div class="checkbox-group">
          <label>
            <input type="checkbox" id="vastai-search-verified" checked>
            ✅ Verified hosts only
          </label>
          <label>
            <input type="checkbox" id="vastai-search-dlperf" checked>
            🚀 High DL performance
          </label>
        </div>
        <button onclick="searchAvailableInstances()" class="success" style="width: 100%;">🔍 Search Available</button>
      </div>

      <!-- Quick Launch Templates -->
      <div class="config-group">
        <h4>⚡ Quick Launch Templates</h4>
        <div class="template-buttons">
          <button onclick="launchTemplate('budget')" class="template-btn">💰 Budget (RTX 3080)<br><small>~$0.50/hr</small></button>
          <button onclick="launchTemplate('balanced')" class="template-btn">⚖️ Balanced (RTX 4080)<br><small>~$1.20/hr</small></button>
          <button onclick="launchTemplate('performance')" class="template-btn">🚀 Performance (RTX 4090)<br><small>~$2.50/hr</small></button>
          <button onclick="launchTemplate('enterprise')" class="template-btn">🏢 Enterprise (A100)<br><small>~$4.00/hr</small></button>
        </div>
      </div>
    </div>

    <!-- Right Column: Active Instances & Available -->
    <div class="vastai-right-panel">
      <!-- Active Instances -->
      <div class="config-group">
        <h4>🖥️ Active Instances</h4>
        <div class="instance-filters">
          <input type="text" id="instance-filter" placeholder="🔍 Filter by name, ID, or status..." oninput="filterInstances()">
          <select id="instance-status-filter" onchange="filterInstances()">
            <option value="">All Statuses</option>
            <option value="running">Running</option>
            <option value="loading">Loading</option>
            <option value="stopped">Stopped</option>
          </select>
        </div>
        <div id="vastai-instances" class="instances-container">
          <div class="no-instances">
            <div class="no-instances-icon">🖥️</div>
            <p>No active instances</p>
            <small>Launch an instance to get started</small>
          </div>
        </div>
      </div>

      <!-- Available Instances -->
      <div class="config-group">
        <h4>🌍 Available Instances</h4>
        <div class="availability-controls">
          <div class="sort-controls">
            <label>Sort by:</label>
            <select id="vastai-sort" onchange="sortAvailableInstances()">
              <option value="price">Price (Low to High)</option>
              <option value="price_desc">Price (High to Low)</option>
              <option value="dlperf">DL Performance</option>
              <option value="reliability">Reliability</option>
            </select>
          </div>
          <div class="view-controls">
            <button onclick="toggleViewMode()" id="view-mode-btn" class="info">📋 List View</button>
            <button onclick="refreshAvailableInstances()" class="info">🔄 Refresh</button>
          </div>
        </div>
        <div id="vastai-available-instances" class="available-instances-container">
          <div class="loading-placeholder">
            <div class="spinner"></div>
            <p>Loading available instances...</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Instance Details Modal -->
  <div id="instance-modal" class="modal" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="modal-instance-title">Instance Details</h3>
        <button onclick="closeInstanceModal()" class="modal-close">×</button>
      </div>
      <div class="modal-body" id="modal-instance-body">
        <!-- Dynamic content -->
      </div>
      <div class="modal-footer">
        <button onclick="closeInstanceModal()" class="info">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Hashes.com Tab (dynamically shown) -->
<div id="hashescom-tab" class="tab-content" style="display: none;">
  <div class="config-sections">
    
    <!-- API Configuration -->
    <div class="config-group">
      <h4>🔑 API Configuration</h4>
      <div class="form-group">
        <label>API Key:</label>
        <input type="password" id="hashescom-api-key" placeholder="Enter your Hashes.com API key">
        <small>Get your API key from your Hashes.com account settings</small>
      </div>
      <div class="form-group">
        <label>Algorithms:</label>
        <input type="text" id="hashescom-algorithms" value="md5,sha1,sha256" placeholder="md5,sha1,sha256">
        <small>Comma-separated list of supported algorithms</small>
      </div>
      <div class="form-group">
        <label>Poll Interval (minutes):</label>
        <input type="number" id="hashescom-poll-interval" value="30" min="1" max="1440">
        <small>How often to check for new jobs (1-1440 minutes)</small>
      </div>
      <button onclick="saveHashescomConfig()" class="success" style="width: 100%;">💾 Save Configuration</button>
      <button onclick="testHashescomConnection()" class="info" style="width: 100%; margin-top: 10px;">🧪 Test Connection</button>
    </div>

    <!-- Payment Filters -->
    <div class="config-group">
      <h4>💰 Payment Filters</h4>
      <div class="form-group">
        <label class="checkbox-label">
          <input type="checkbox" id="hashescom-reject-zero-payment" checked>
          🚫 Reject jobs with zero or no payment
        </label>
      </div>
      <div class="form-group">
        <label>Minimum Payment (USD):</label>
        <input type="number" id="hashescom-min-payment" value="0.01" step="0.01" min="0">
        <small>Minimum payment amount to accept jobs</small>
      </div>
      <div class="form-group">
        <label>Accepted Cryptocurrencies:</label>
        <div class="checkbox-group">
          <label>
            <input type="checkbox" id="hashescom-accept-btc" checked>
            ₿ Bitcoin (BTC)
          </label>
          <label>
            <input type="checkbox" id="hashescom-accept-ltc" checked>
            Ł Litecoin (LTC)
          </label>
          <label>
            <input type="checkbox" id="hashescom-accept-xmr" checked>
            ɱ Monero (XMR)
          </label>
        </div>
        <small>Only accept jobs paying in selected cryptocurrencies</small>
      </div>
      <button onclick="savePaymentFilters()" class="success" style="width: 100%;">💾 Save Payment Filters</button>
    </div>

    <!-- Job Management -->
    <div class="config-group">
      <h4>📋 Job Management</h4>
      <div style="margin-bottom: 15px;">
        <button onclick="fetchHashescomJobs()" class="info" style="margin-right: 10px;">🔄 Fetch Jobs</button>
        <button onclick="clearCompletedJobs()" class="warning" style="margin-right: 10px;">🗑️ Clear Completed</button>
        <button onclick="startJobPolling()" class="success" style="margin-right: 10px;">▶️ Start Polling</button>
        <button onclick="stopJobPolling()" class="danger">⏸️ Stop Polling</button>
      </div>
      
      <!-- Status Display -->
      <div id="hashescom-status" style="background: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; margin-bottom: 15px;">
        <div>Status: <span id="hashescom-polling-status" style="color: #888;">Stopped</span></div>
        <div>Last Check: <span id="hashescom-last-check" style="color: #888;">Never</span></div>
        <div>Active Jobs: <span id="hashescom-active-jobs" style="color: var(--success-color);">0</span></div>
        <div>Rejected Jobs: <span id="hashescom-rejected-jobs" style="color: var(--warning-color);">0</span></div>
        <div>Completed Jobs: <span id="hashescom-completed-jobs" style="color: var(--primary-color);">0</span></div>
      </div>

      <!-- Job Queue -->
      <div id="hashescom-job-queue" style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 4px;">
        <div style="padding: 20px; text-align: center; color: #888;">
          No jobs available. Click "Fetch Jobs" to load available jobs.
        </div>
      </div>
    </div>

    <!-- Statistics -->
    <div class="config-group">
      <h4>📊 Statistics</h4>
      <div class="metrics-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
        <div class="metric-card" style="background: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; text-align: center;">
          <div style="font-size: 1.5rem; color: var(--primary-color); font-weight: bold;" id="hashescom-total-earned">$0.00</div>
          <div style="font-size: 0.8rem; color: #888;">Total Earned</div>
        </div>
        <div class="metric-card" style="background: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; text-align: center;">
          <div style="font-size: 1.5rem; color: var(--success-color); font-weight: bold;" id="hashescom-jobs-completed">0</div>
          <div style="font-size: 0.8rem; color: #888;">Jobs Completed</div>
        </div>
        <div class="metric-card" style="background: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; text-align: center;">
          <div style="font-size: 1.5rem; color: var(--warning-color); font-weight: bold;" id="hashescom-success-rate">0%</div>
          <div style="font-size: 0.8rem; color: #888;">Success Rate</div>
        </div>
        <div class="metric-card" style="background: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; text-align: center;">
          <div style="font-size: 1.5rem; color: var(--primary-color); font-weight: bold;" id="hashescom-avg-payment">$0.00</div>
          <div style="font-size: 0.8rem; color: #888;">Avg Payment</div>
        </div>
      </div>
      
      <div style="margin-top: 15px;">
        <button onclick="resetHashescomStats()" class="danger" style="width: 100%;">🔄 Reset Statistics</button>
      </div>
    </div>

  </div>
</div>

<!-- Salad AI Tab (dynamically shown) -->
<div id="saladai-tab" class="tab-content" style="display: none;">
  <div class="config-sections">
    <div class="config-group">
      <h4>🥗 Salad AI Integration</h4>
      <div class="form-group">
        <label>API Key:</label>
        <input type="password" id="saladai-api-key" placeholder="Enter your Salad AI API key">
      </div>
      <div class="form-group">
        <label>Project ID:</label>
        <input type="text" id="saladai-project" placeholder="Project ID">
      </div>
      <button onclick="saveSaladaiConfig()" class="success" style="width: 100%;">💾 Save Settings</button>
    </div>
  </div>
</div>

<!-- Grok Tab (dynamically shown) -->
<div id="grok-tab" class="tab-content" style="display: none;">
  <div class="config-sections">
    <div class="config-group">
      <h4>🤖 Grok Integration</h4>
      <div class="form-group">
        <label>API Key:</label>
        <input type="password" id="grok-api-key" placeholder="Enter your Grok API key">
      </div>
      <div class="form-group">
        <label>Model:</label>
        <select id="grok-model">
          <option value="grok-beta">Grok Beta</option>
          <option value="grok-vision-beta">Grok Vision Beta</option>
        </select>
      </div>
      <button onclick="saveGrokConfig()" class="success" style="width: 100%;">💾 Save Settings</button>
    </div>
  </div>
</div>

<script>
// ============================================================================
// GLOBAL APPLICATION STATE
// ============================================================================

class HashmancerPortal {
  constructor() {
    this.csrfToken = this.getCSRFToken();
    this.autoRefresh = true;
    this.refreshInterval = 30000;
    this.refreshTimer = null;
    this.wsConnection = null;
    this.currentTab = 'overview';
    this.hashescomPollingTimer = null;
    this.enabledServices = {
      vastai: false,
      hashescom: false,
      saladai: false,
      grok: false
    };
    
    this.jobSettings = {
      defaultAttackMode: 'mask',
      executionStrategy: 'parallel',
      defaultMask: '?l?l?l?l?l?l?l?l',
      defaultDictionary: 'rockyou.txt',
      defaultRules: 'best64.rule',
      taskPipeline: [],
      // Hashtopolis-inspired advanced settings
      chunkSize: 600,
      benchmarkType: 'speed',
      maxAgents: 10,
      optimizedKernel: false,
      smallTasks: false
    };
    
    this.notificationSettings = {
      enabled: true,
      email: '',
      events: {
        jobComplete: true,
        hashCracked: true,
        taskFailed: false,
        agentOffline: false
      },
      discordWebhook: '',
      slackWebhook: ''
    };
    
    this.templates = [];
    
    this.initializeApp();
    this.loadServicesConfig();
    this.loadJobSettings();
    this.loadNotificationSettings();
    this.loadTemplates();
  }

  getCSRFToken() {
    const meta = document.querySelector('meta[name="csrf-token"]');
    return meta ? meta.getAttribute('content') : null;
  }

  async refreshCSRFToken() {
    try {
      const response = await fetch('/csrf_token');
      const data = await response.json();
      this.csrfToken = data.csrf_token;
      
      let meta = document.querySelector('meta[name="csrf-token"]');
      if (!meta) {
        meta = document.createElement('meta');
        meta.name = 'csrf-token';
        document.head.appendChild(meta);
      }
      meta.content = this.csrfToken;
    } catch (error) {
      console.error('Failed to refresh CSRF token:', error);
    }
  }

  async apiCall(url, options = {}) {
    try {
      if (this.csrfToken && (options.method !== 'GET' && options.method !== 'HEAD')) {
        options.headers = {
          ...options.headers,
          'X-CSRF-Token': this.csrfToken
        };
      }

      if (!options.headers) options.headers = {};
      if (options.body && typeof options.body === 'string') {
        options.headers['Content-Type'] = 'application/json';
      }

      const response = await fetch(url, options);
      
      if (response.status === 403) {
        await this.refreshCSRFToken();
        options.headers['X-CSRF-Token'] = this.csrfToken;
        return await fetch(url, options);
      }
      
      if (!response.ok) {
        if (response.status === 401) {
          this.showLogin();
          throw new Error('Authentication required');
        }
        
        let errorMessage = `HTTP ${response.status}`;
        try {
          const errorData = await response.json();
          errorMessage = errorData.detail || errorData.message || errorMessage;
        } catch (e) {
          errorMessage = await response.text() || errorMessage;
        }
        
        throw new Error(errorMessage);
      }

      return response;
    } catch (error) {
      console.error('API call failed:', error);
      throw error;
    }
  }

  // ============================================================================
  // UI UTILITIES
  // ============================================================================

  showToast(message, type = 'info', duration = 5000) {
    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span>${this.sanitizeHTML(message)}</span>
        <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: inherit; cursor: pointer; padding: 0; margin-left: 1rem;">×</button>
      </div>
    `;
    
    container.appendChild(toast);
    setTimeout(() => toast.classList.add('show'), 100);
    
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  sanitizeHTML(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // ============================================================================
  // APPLICATION INITIALIZATION
  // ============================================================================

  initializeApp() {
    this.setupEventListeners();
    this.setupKeyboardShortcuts();
    this.setupFileUploads();
    this.checkAuthentication();
    this.startRefreshTimer();
    this.connectWebSocket();
  }

  setupEventListeners() {
    // File upload handling
    document.getElementById('dict-upload').addEventListener('change', (e) => {
      this.uploadDictionaries(e.target.files);
    });

    document.getElementById('restore-upload').addEventListener('change', (e) => {
      this.uploadRestore(e.target.files[0]);
    });
  }

  setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'r') {
        e.preventDefault();
        this.refreshCurrentTab();
      }
      
      if (e.key === 'Escape') {
        const loginOverlay = document.getElementById('login-overlay');
        if (loginOverlay.style.display === 'flex') {
          loginOverlay.style.display = 'none';
        }
      }

      // Tab switching with Ctrl+1,2,3,4
      if (e.ctrlKey && e.key >= '1' && e.key <= '4') {
        e.preventDefault();
        const tabs = ['overview', 'management', 'logs', 'config'];
        this.switchTab(tabs[parseInt(e.key) - 1]);
      }
    });
  }

  setupFileUploads() {
    // Drag and drop for dictionaries
    const dictUploadArea = document.querySelector('.file-upload-area');
    if (dictUploadArea) {
      dictUploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        dictUploadArea.style.borderColor = 'var(--primary-color)';
        dictUploadArea.style.background = 'rgba(0, 255, 0, 0.1)';
      });
      
      dictUploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dictUploadArea.style.borderColor = 'var(--border-color)';
        dictUploadArea.style.background = 'transparent';
      });
      
      dictUploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        dictUploadArea.style.borderColor = 'var(--border-color)';
        dictUploadArea.style.background = 'transparent';
        
        const files = Array.from(e.dataTransfer.files);
        this.uploadDictionaries(files);
      });
    }
  }

  async checkAuthentication() {
    try {
      const response = await this.apiCall('/server_status');
      if (response.ok) {
        this.hideLogin();
        this.refreshCurrentTab();
      }
    } catch (error) {
      if (error.message.includes('Authentication')) {
        this.showLogin();
      } else {
        this.showToast('Connection error: ' + error.message, 'error');
      }
    }
  }

  // ============================================================================
  // TAB MANAGEMENT
  // ============================================================================

  switchTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.classList.remove('active');
    });
    
    // Find and activate the correct tab button using data-tab attribute
    const targetButton = document.querySelector(`[data-tab="${tabName}"]`);
    if (targetButton) {
      targetButton.classList.add('active');
    }

    // Update tab content - hide all first
    document.querySelectorAll('.tab-content').forEach(content => {
      content.classList.remove('active');
      content.style.display = 'none';
    });
    
    // Show the selected tab
    const targetTab = document.getElementById(`${tabName}-tab`);
    if (targetTab) {
      targetTab.classList.add('active');
      targetTab.style.display = 'block';
    } else {
      console.warn(`Tab content not found for: ${tabName}-tab`);
    }

    this.currentTab = tabName;
    this.refreshCurrentTab();
  }

  refreshCurrentTab() {
    switch (this.currentTab) {
      case 'overview':
        this.refreshOverview();
        break;
      case 'management':
        this.refreshManagement();
        break;
      case 'logs':
        this.loadLogs();
        break;
      case 'config':
        this.refreshConfig();
        break;
      case 'vastai':
        this.refreshVastaiTab();
        break;
      case 'hashescom':
        this.refreshHashescomTab();
        break;
      case 'saladai':
        this.refreshSaladaiTab();
        break;
      case 'grok':
        this.refreshGrokTab();
        break;
    }
  }

  // ============================================================================
  // OVERVIEW TAB
  // ============================================================================

  async refreshOverview() {
    try {
      await Promise.allSettled([
        this.updateSystemMetrics(),
        this.updateWorkerStats(),
        this.loadWorkersOverview(),
        this.loadJobsOverview(),
        this.refreshWallOfSheep()
      ]);
      
      document.getElementById('last-updated').textContent = new Date().toLocaleTimeString();
    } catch (error) {
      this.showToast('Failed to refresh overview: ' + error.message, 'error');
    }
  }

  async updateSystemMetrics() {
    try {
      const response = await this.apiCall('/server_status');
      const data = await response.json();
      
      document.getElementById('active-workers').textContent = data.worker_count || 0;
      document.getElementById('queue-length').textContent = data.queue_length || 0;
      document.getElementById('total-found').textContent = data.found_results || 0;
      
      // Calculate missing workers (placeholder logic)
      const expectedWorkers = 10; // This should come from config
      const missingWorkers = Math.max(0, expectedWorkers - (data.worker_count || 0));
      document.getElementById('missing-workers').textContent = missingWorkers;
      
      // Update warning/error states
      const missingWorkersCard = document.getElementById('missing-workers').parentElement;
      if (missingWorkers > 0) {
        missingWorkersCard.classList.add('warning');
      } else {
        missingWorkersCard.classList.remove('warning');
      }
      
    } catch (error) {
      console.error('Failed to update system metrics:', error);
    }
  }

  async updateWorkerStats() {
    try {
      const response = await this.apiCall('/workers');
      const workers = await response.json();
      
      if (workers.length === 0) {
        document.getElementById('avg-gpu-temp').textContent = 'N/A';
        document.getElementById('avg-ram-usage').textContent = 'N/A';
        document.getElementById('avg-cpu-util').textContent = 'N/A';
        document.getElementById('avg-gpu-util').textContent = 'N/A';
        return;
      }
      
      // Calculate averages (placeholder - real data would come from worker stats)
      const avgGpuTemp = Math.floor(Math.random() * 20) + 60; // 60-80°C
      const avgRamUsage = Math.floor(Math.random() * 30) + 40; // 40-70%
      const avgCpuUtil = Math.floor(Math.random() * 40) + 20; // 20-60%
      const avgGpuUtil = Math.floor(Math.random() * 50) + 50; // 50-100%
      
      document.getElementById('avg-gpu-temp').textContent = `${avgGpuTemp}°C`;
      document.getElementById('avg-ram-usage').textContent = `${avgRamUsage}%`;
      document.getElementById('avg-cpu-util').textContent = `${avgCpuUtil}%`;
      document.getElementById('avg-gpu-util').textContent = `${avgGpuUtil}%`;
      
      // Update warning states
      const gpuTempCard = document.getElementById('avg-gpu-temp').parentElement;
      if (avgGpuTemp > 75) {
        gpuTempCard.classList.add('error');
      } else if (avgGpuTemp > 70) {
        gpuTempCard.classList.add('warning');
      } else {
        gpuTempCard.classList.remove('warning', 'error');
      }
      
    } catch (error) {
      console.error('Failed to update worker stats:', error);
    }
  }

  async loadWorkersOverview() {
    try {
      const response = await this.apiCall('/workers');
      const workers = await response.json();
      
      const tbody = document.getElementById('workers-overview-table');
      tbody.innerHTML = '';
      
      if (workers.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; opacity: 0.7;">No workers found</td></tr>';
        return;
      }
      
      workers.forEach(worker => {
        // Generate mock data for demonstration
        const gpuTemp = Math.floor(Math.random() * 20) + 60;
        const ramUsage = Math.floor(Math.random() * 30) + 40;
        const cpuUsage = Math.floor(Math.random() * 40) + 20;
        const gpuUsage = Math.floor(Math.random() * 50) + 50;
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>
            <span class="status-indicator status-${worker.status}"></span>
            ${this.sanitizeHTML(worker.name)}
          </td>
          <td><span class="status-${worker.status}">${this.sanitizeHTML(worker.status)}</span></td>
          <td>Job ${Math.floor(Math.random() * 1000)}</td>
          <td style="color: ${gpuTemp > 75 ? 'var(--error-color)' : gpuTemp > 70 ? 'var(--warning-color)' : 'inherit'}">${gpuTemp}°C</td>
          <td>${ramUsage}%</td>
          <td>${cpuUsage}%</td>
          <td>${gpuUsage}%</td>
        `;
        tbody.appendChild(row);
      });
      
    } catch (error) {
      console.error('Failed to load workers overview:', error);
    }
  }

  async loadJobsOverview() {
    try {
      console.log('Loading jobs overview...');
      
      // Load jobs from localStorage (accepted jobs from hashes.com and other sources)
      const acceptedJobs = JSON.parse(localStorage.getItem('hashescom-accepted-jobs') || '[]');
      const localJobs = JSON.parse(localStorage.getItem('local-jobs') || '[]');
      
      // Combine all job sources
      const allJobs = [...acceptedJobs, ...localJobs];
      console.log('Total jobs found:', allJobs.length, allJobs);
      
      const tbody = document.getElementById('jobs-overview-table');
      if (!tbody) {
        console.error('jobs-overview-table element not found');
        return;
      }
      
      tbody.innerHTML = '';
      
      if (allJobs.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; opacity: 0.7;">No jobs found</td></tr>';
        return;
      }
      
      allJobs.forEach(job => {
        // Calculate progress based on job status
        let progress = 0;
        switch(job.status) {
          case 'accepted': progress = 10; break;
          case 'queued': progress = 20; break;
          case 'running': progress = Math.floor(Math.random() * 60) + 30; break;
          case 'completed': progress = 100; break;
          case 'failed': progress = 0; break;
          default: progress = 5;
        }
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${this.sanitizeHTML(job.job_id || job.id || 'N/A')}</td>
          <td><span class="status-${job.status || 'unknown'}">${this.sanitizeHTML(job.status || 'Unknown')}</span></td>
          <td>
            <div>${this.sanitizeHTML(job.plan_name || job.attack_mode || 'mask')}</div>
            <div style="font-size: 0.8em; color: #888;">${this.sanitizeHTML(job.attack_mode || 'mask')}</div>
          </td>
          <td>
            <div class="progress-bar">
              <div class="progress-fill" style="width: ${progress}%">
                ${progress}%
              </div>
            </div>
          </td>
        `;
        tbody.appendChild(row);
      });
      
    } catch (error) {
      console.error('Failed to load jobs overview:', error);
      const tbody = document.getElementById('jobs-overview-table');
      if (tbody) {
        tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--error-color);">Error loading jobs</td></tr>';
      }
    }
  }

  async refreshWallOfSheep() {
    try {
      console.log('Refreshing wall of sheep...');
      
      // Load results from localStorage
      const results = JSON.parse(localStorage.getItem('wall-of-sheep-results') || '[]');
      console.log('Wall of sheep results:', results.length);
      
      const content = document.getElementById('wall-of-sheep-content');
      if (!content) {
        console.error('wall-of-sheep-content element not found');
        return;
      }
      
      if (results.length === 0) {
        content.innerHTML = '<div style="text-align: center; opacity: 0.7; padding: 20px;">No hashes cracked yet. Keep waiting for the sheep to appear! 🐑</div>';
        return;
      }
      
      content.innerHTML = results.map(result => 
        `<div class="sheep-entry">
          <div style="font-family: monospace; color: var(--primary-color);">${this.sanitizeHTML(result.hash || 'N/A')}</div>
          <div style="font-family: monospace; color: var(--success-color);">${this.sanitizeHTML(result.plaintext || 'N/A')}</div>
          <div style="font-size: 0.8rem; opacity: 0.7;">Job: ${this.sanitizeHTML(result.job_id || 'N/A')} | ${new Date(result.timestamp || Date.now()).toLocaleString()}</div>
        </div>`
      ).join('');
      
      // Auto-scroll to bottom
      content.scrollTop = content.scrollHeight;
      
    } catch (error) {
      console.error('Failed to refresh wall of sheep:', error);
      const content = document.getElementById('wall-of-sheep-content');
      if (content) {
        content.innerHTML = '<div style="text-align: center; color: var(--error-color); padding: 20px;">Failed to load found hashes</div>';
      }
    }
  }

  // ============================================================================
  // MANAGEMENT TAB
  // ============================================================================

  async refreshManagement() {
    try {
      await Promise.allSettled([
        this.loadDictionaries(),
        this.loadMasks(),
        this.loadWorkersManagement(),
        this.loadJobsManagement(),
        this.loadRestoreFiles()
      ]);
    } catch (error) {
      this.showToast('Failed to refresh management: ' + error.message, 'error');
    }
  }

  async loadDictionaries() {
    try {
      const response = await this.apiCall('/wordlists');
      const dicts = await response.json();
      
      const list = document.getElementById('dict-list');
      list.innerHTML = '';
      
      if (dicts.length === 0) {
        list.innerHTML = '<li style="text-align: center; opacity: 0.7;">No dictionaries found</li>';
        return;
      }
      
      dicts.forEach(name => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span style="font-family: monospace;">${this.sanitizeHTML(name)}</span>
          <div>
            <button onclick="app.downloadDict('${name}')" class="success" style="margin-right: 5px;">📥</button>
            <button onclick="app.deleteDict('${name}')" class="danger">🗑️</button>
          </div>
        `;
        list.appendChild(li);
      });
      
    } catch (error) {
      console.error('Failed to load dictionaries:', error);
    }
  }

  async uploadDictionaries(files) {
    if (!files || files.length === 0) return;
    
    try {
      for (const file of files) {
        const formData = new FormData();
        formData.append('file', file);
        
        await this.apiCall('/upload_wordlist', {
          method: 'POST',
          body: formData
        });
      }
      
      this.showToast(`Successfully uploaded ${files.length} dictionary(s)`, 'success');
      this.loadDictionaries();
      
    } catch (error) {
      this.showToast('Failed to upload dictionaries: ' + error.message, 'error');
    }
  }

  async deleteDict(name) {
    if (!confirm(`Are you sure you want to delete dictionary "${name}"?`)) return;
    
    try {
      await this.apiCall(`/wordlist/${encodeURIComponent(name)}`, {
        method: 'DELETE'
      });
      
      this.loadDictionaries();
      this.showToast(`Dictionary "${name}" deleted successfully`, 'success');
      
    } catch (error) {
      this.showToast('Failed to delete dictionary: ' + error.message, 'error');
    }
  }

  downloadDict(name) {
    window.open(`/wordlist/${encodeURIComponent(name)}`, '_blank');
  }

  async loadMasks() {
    try {
      const response = await this.apiCall('/masks');
      const masks = await response.json();
      
      const list = document.getElementById('mask-list');
      list.innerHTML = '';
      
      if (masks.length === 0) {
        list.innerHTML = '<li style="text-align: center; opacity: 0.7;">No masks found</li>';
        return;
      }
      
      masks.forEach(name => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span style="font-family: monospace;">${this.sanitizeHTML(name)}</span>
          <button onclick="app.deleteMask('${name}')" class="danger">🗑️</button>
        `;
        list.appendChild(li);
      });
      
    } catch (error) {
      console.error('Failed to load masks:', error);
    }
  }

  async createMask() {
    const name = document.getElementById('mask-name').value.trim();
    const content = document.getElementById('mask-content').value.trim();
    
    if (!name) {
      this.showToast('Please enter a mask name', 'warning');
      return;
    }
    
    if (!content) {
      this.showToast('Please enter mask content', 'warning');
      return;
    }

    try {
      await this.apiCall('/create_mask', {
        method: 'POST',
        body: JSON.stringify({ name, content })
      });
      
      document.getElementById('mask-name').value = '';
      document.getElementById('mask-content').value = '';
      
      this.loadMasks();
      this.showToast(`Mask "${name}" created successfully`, 'success');
      
    } catch (error) {
      this.showToast('Failed to create mask: ' + error.message, 'error');
    }
  }

  async deleteMask(name) {
    if (!confirm(`Are you sure you want to delete mask "${name}"?`)) return;
    
    try {
      await this.apiCall(`/mask/${encodeURIComponent(name)}`, {
        method: 'DELETE'
      });
      
      this.loadMasks();
      this.showToast(`Mask "${name}" deleted successfully`, 'success');
      
    } catch (error) {
      this.showToast('Failed to delete mask: ' + error.message, 'error');
    }
  }

  async loadWorkersManagement() {
    try {
      const response = await this.apiCall('/workers');
      const workers = await response.json();
      
      const tbody = document.getElementById('workers-management-table');
      tbody.innerHTML = '';
      
      if (workers.length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; opacity: 0.7;">No workers found</td></tr>';
        return;
      }
      
      workers.forEach(worker => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>
            <span class="status-indicator status-${worker.status}"></span>
            ${this.sanitizeHTML(worker.name)}
          </td>
          <td><span class="status-${worker.status}">${this.sanitizeHTML(worker.status)}</span></td>
          <td>
            <select onchange="app.changeWorkerStatus('${worker.name}', this.value)" style="margin-right: 5px;">
              <option value="idle" ${worker.status === 'idle' ? 'selected' : ''}>Idle</option>
              <option value="maintenance" ${worker.status === 'maintenance' ? 'selected' : ''}>Maintenance</option>
              <option value="offline" ${worker.status === 'offline' ? 'selected' : ''}>Offline</option>
            </select>
            <button onclick="app.restartWorker('${worker.name}')" class="danger" title="Restart">🔄</button>
          </td>
        `;
        tbody.appendChild(row);
      });
      
    } catch (error) {
      console.error('Failed to load workers management:', error);
    }
  }

  async changeWorkerStatus(workerName, newStatus) {
    try {
      await this.apiCall('/worker_status', {
        method: 'POST',
        body: JSON.stringify({
          name: workerName,
          status: newStatus
        })
      });
      
      this.showToast(`Worker ${workerName} status changed to ${newStatus}`, 'success');
      this.loadWorkersManagement();
      
    } catch (error) {
      this.showToast('Failed to change worker status: ' + error.message, 'error');
    }
  }

  async restartWorker(workerName) {
    if (!confirm(`Are you sure you want to restart worker "${workerName}"?`)) return;
    
    try {
      await this.apiCall('/worker_restart', {
        method: 'POST',
        body: JSON.stringify({ worker_id: workerName })
      });
      this.showToast(`Worker ${workerName} restart command sent`, 'success');
    } catch (error) {
      this.showToast('Failed to restart worker: ' + error.message, 'error');
    }
  }

  async loadJobsManagement() {
    try {
      const response = await this.apiCall('/jobs');
      const jobs = await response.json();
      
      const tbody = document.getElementById('jobs-management-table');
      tbody.innerHTML = '';
      
      if (jobs.length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; opacity: 0.7;">No jobs found</td></tr>';
        return;
      }
      
      jobs.forEach(job => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${this.sanitizeHTML(job.job_id || 'N/A')}</td>
          <td><span class="status-${job.status || 'unknown'}">${this.sanitizeHTML(job.status || 'Unknown')}</span></td>
          <td>
            <button onclick="app.pauseJob('${job.job_id}')" class="warning" title="Pause">⏸️</button>
            <button onclick="app.cancelJob('${job.job_id}')" class="danger" title="Cancel">❌</button>
          </td>
        `;
        tbody.appendChild(row);
      });
      
    } catch (error) {
      console.error('Failed to load jobs management:', error);
    }
  }

  async pauseJob(jobId) {
    try {
      await this.apiCall('/job_pause', {
        method: 'POST',
        body: JSON.stringify({ job_id: jobId })
      });
      this.showToast(`Job ${jobId} paused successfully`, 'success');
      this.loadJobsManagement();
    } catch (error) {
      this.showToast('Failed to pause job: ' + error.message, 'error');
    }
  }

  async cancelJob(jobId) {
    if (!confirm(`Are you sure you want to cancel job "${jobId}"?`)) return;
    
    try {
      await this.apiCall('/job_cancel', {
        method: 'POST',
        body: JSON.stringify({ job_id: jobId })
      });
      this.showToast(`Job ${jobId} cancelled`, 'success');
    } catch (error) {
      this.showToast('Failed to cancel job: ' + error.message, 'error');
    }
  }

  async uploadHashes() {
    const fileInput = document.getElementById('hash-file');
    const hashModeInput = document.getElementById('hash-mode');
    
    const file = fileInput.files[0];
    const hashMode = hashModeInput.value.trim();
    
    if (!file) {
      this.showToast('Please select a hash file', 'warning');
      return;
    }

    try {
      const formData = new FormData();
      formData.append('file', file);
      if (hashMode) {
        formData.append('hash_mode', hashMode);
      }
      
      await this.apiCall('/import_hashes', {
        method: 'POST',
        body: formData
      });
      
      fileInput.value = '';
      hashModeInput.value = '';
      
      this.showToast('Hashes uploaded successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to upload hashes: ' + error.message, 'error');
    }
  }

  async submitHash() {
    const hashInput = document.getElementById('single-hash');
    const hashModeInput = document.getElementById('single-hash-mode');
    
    const hash = hashInput.value.trim();
    const hashMode = hashModeInput.value.trim() || '0';
    
    if (!hash) {
      this.showToast('Please enter a hash value', 'warning');
      return;
    }

    try {
      await this.apiCall('/import_hash', {
        method: 'POST',
        body: JSON.stringify({
          hash: hash,
          hash_mode: hashMode
        })
      });
      
      hashInput.value = '';
      hashModeInput.value = '';
      
      this.showToast('Hash added successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to add hash: ' + error.message, 'error');
    }
  }

  async loadRestoreFiles() {
    try {
      const response = await this.apiCall('/restores');
      const restores = await response.json();
      
      const list = document.getElementById('restore-list');
      list.innerHTML = '';
      
      if (restores.length === 0) {
        list.innerHTML = '<li style="text-align: center; opacity: 0.7;">No restore files found</li>';
        return;
      }
      
      restores.forEach(name => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span style="font-family: monospace;">${this.sanitizeHTML(name)}</span>
          <div>
            <button onclick="app.downloadRestore('${name}')" class="success" style="margin-right: 5px;">📥</button>
            <button onclick="app.deleteRestore('${name}')" class="danger">🗑️</button>
          </div>
        `;
        list.appendChild(li);
      });
      
    } catch (error) {
      console.error('Failed to load restore files:', error);
    }
  }

  async uploadRestore(file) {
    if (!file) return;

    try {
      const formData = new FormData();
      formData.append('file', file);
      
      await this.apiCall('/upload_restore', {
        method: 'POST',
        body: formData
      });
      
      document.getElementById('restore-upload').value = '';
      this.loadRestoreFiles();
      this.showToast('Restore file uploaded successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to upload restore file: ' + error.message, 'error');
    }
  }

  downloadRestore(name) {
    window.open(`/download_restore/${encodeURIComponent(name)}`, '_blank');
  }

  async deleteRestore(name) {
    if (!confirm(`Are you sure you want to delete restore file "${name}"?`)) return;
    
    try {
      await this.apiCall(`/restore/${encodeURIComponent(name)}`, {
        method: 'DELETE'
      });
      
      this.loadRestoreFiles();
      this.showToast(`Restore file "${name}" deleted successfully`, 'success');
      
    } catch (error) {
      this.showToast('Failed to delete restore file: ' + error.message, 'error');
    }
  }

  // ============================================================================
  // LOGS TAB
  // ============================================================================

  async loadLogs() {
    const logType = document.getElementById('log-type').value;
    const worker = document.getElementById('log-worker').value;
    const searchTerm = document.getElementById('log-search').value;
    
    try {
      let url = '/logs';
      const params = new URLSearchParams();
      
      if (logType !== 'all') params.append('type', logType);
      if (worker) params.append('worker', worker);
      if (searchTerm) params.append('search', searchTerm);
      
      if (params.toString()) {
        url += '?' + params.toString();
      }
      
      const response = await this.apiCall(url);
      const logs = await response.json();
      
      const content = document.getElementById('log-content');
      
      if (logs.length === 0) {
        content.innerHTML = '<div style="text-align: center; opacity: 0.7; padding: 20px;">No logs found</div>';
        return;
      }
      
      const logText = logs.map(entry => 
        `${entry.datetime || ''} [${entry.worker_id || 'server'}] ${entry.message || ''}`
      ).join('\n');
      
      content.textContent = logText;
      content.scrollTop = content.scrollHeight;
      
    } catch (error) {
      console.error('Failed to load logs:', error);
      document.getElementById('log-content').innerHTML = 
        '<div style="text-align: center; color: var(--error-color); padding: 20px;">Failed to load logs</div>';
    }
  }

  async clearLogs() {
    if (!confirm('Are you sure you want to clear all logs? This action cannot be undone.')) return;
    
    try {
      await this.apiCall('/clear_logs', {
        method: 'POST'
      });
      document.getElementById('log-content').innerHTML = 'Logs cleared.';
      this.showToast('Logs cleared successfully', 'success');
    } catch (error) {
      this.showToast('Failed to clear logs: ' + error.message, 'error');
    }
  }

  downloadLogs() {
    // Trigger log download
    const link = document.createElement('a');
    link.href = '/download_logs';
    link.download = `hashmancer_logs_${new Date().toISOString().split('T')[0]}.txt`;
    link.click();
    this.showToast('Log download started', 'success');
  }

  // ============================================================================
  // ADVANCED CONFIG TAB
  // ============================================================================

  async refreshConfig() {
    try {
      await Promise.allSettled([
        this.loadMarkovConfig(),
        this.loadHashesConfig(),
        this.loadAlgoParams(),
        this.loadServerConfig()
      ]);
      
      // Update service checkboxes when config tab is loaded
      this.updateServiceCheckboxes();
      
    } catch (error) {
      this.showToast('Failed to refresh config: ' + error.message, 'error');
    }
  }

  async loadMarkovConfig() {
    try {
      const response = await this.apiCall('/server_status');
      const data = await response.json();
      
      document.getElementById('current-markov-lang').textContent = data.markov_lang || 'english';
      document.getElementById('current-prob-order').textContent = data.probabilistic_order ? 'ON' : 'OFF';
      document.getElementById('current-inverse-order').textContent = data.inverse_prob_order ? 'ON' : 'OFF';
      
      document.getElementById('markov-language').value = data.markov_lang || 'english';
      document.getElementById('prob-order').checked = !!data.probabilistic_order;
      document.getElementById('inverse-order').checked = !!data.inverse_prob_order;
      
    } catch (error) {
      console.error('Failed to load Markov config:', error);
    }
  }

  async trainMarkov() {
    const lang = document.getElementById('markov-language').value;
    
    try {
      await this.apiCall('/train_markov', {
        method: 'POST',
        body: JSON.stringify({ lang })
      });
      
      this.showToast(`Markov training started for ${lang}`, 'success');
      
    } catch (error) {
      this.showToast('Failed to start Markov training: ' + error.message, 'error');
    }
  }

  async changeMarkovLang() {
    const lang = document.getElementById('markov-language').value;
    
    try {
      await this.apiCall('/markov_lang', {
        method: 'POST',
        body: JSON.stringify({ lang })
      });
      
      this.loadMarkovConfig();
      this.showToast(`Markov language set to ${lang}`, 'success');
      
    } catch (error) {
      this.showToast('Failed to change Markov language: ' + error.message, 'error');
    }
  }

  async loadHashesConfig() {
    try {
      const response = await this.apiCall('/hashes_settings');
      const data = await response.json();
      
      if (data.hashes_poll_interval !== undefined) {
        document.getElementById('hashes-poll').value = data.hashes_poll_interval;
      }
      
    } catch (error) {
      console.error('Failed to load hashes config:', error);
    }
  }

  async saveHashesKey() {
    const key = document.getElementById('hashes-key').value.trim();
    
    try {
      await this.apiCall('/hashes_api_key', {
        method: 'POST',
        body: JSON.stringify({ api_key: key })
      });
      
      this.showToast('Hashes.com API key saved successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to save API key: ' + error.message, 'error');
    }
  }

  async saveHashesAlgos() {
    const algosInput = document.getElementById('hashes-algos');
    const algosText = algosInput.value.trim();
    const algos = algosText ? algosText.split(',').map(a => a.trim()).filter(a => a) : [];
    
    try {
      await this.apiCall('/hashes_algorithms', {
        method: 'POST',
        body: JSON.stringify({ algorithms: algos })
      });
      
      this.showToast('Hashes.com algorithms saved successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to save algorithms: ' + error.message, 'error');
    }
  }

  async saveHashesPoll() {
    const interval = parseInt(document.getElementById('hashes-poll').value, 10) || 0;
    
    try {
      await this.apiCall('/hashes_settings', {
        method: 'POST',
        body: JSON.stringify({ hashes_poll_interval: interval })
      });
      
      this.showToast('Poll interval saved successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to save poll interval: ' + error.message, 'error');
    }
  }

  async trainLLM() {
    const dataset = document.getElementById('llm-dataset').value.trim();
    const model = document.getElementById('llm-base-model').value.trim();
    const epochs = parseInt(document.getElementById('llm-epochs').value, 10) || 1;
    const learningRate = parseFloat(document.getElementById('llm-lr').value) || 0.0001;
    const outputDir = document.getElementById('llm-output').value.trim();

    if (!dataset || !model || !outputDir) {
      this.showToast('Please fill in all required fields', 'warning');
      return;
    }

    try {
      await this.apiCall('/train_llm', {
        method: 'POST',
        body: JSON.stringify({
          dataset_path: dataset,
          base_model_path: model,
          epochs: epochs,
          learning_rate: learningRate,
          output_dir: outputDir
        })
      });
      
      this.showToast('LLM training started', 'success');
      
    } catch (error) {
      this.showToast('Failed to start LLM training: ' + error.message, 'error');
    }
  }

  async loadAlgoParams() {
    try {
      const response = await this.apiCall('/hashes_settings');
      const data = await response.json();
      
      document.getElementById('algo-params-output').textContent = JSON.stringify(data.algo_params || {}, null, 2);
      
    } catch (error) {
      console.error('Failed to load algorithm parameters:', error);
      document.getElementById('algo-params-output').textContent = 'Failed to load parameters';
    }
  }

  async saveAlgoParams() {
    const algo = document.getElementById('algo-name').value.trim();
    if (!algo) {
      this.showToast('Please enter an algorithm name', 'warning');
      return;
    }
    
    const maskLength = parseInt(document.getElementById('algo-masklen').value, 10);
    const rule = document.getElementById('algo-rule').value.trim();
    
    const params = {};
    if (maskLength) params.mask_length = maskLength;
    if (rule) params.rule = rule;

    try {
      const body = { algo_params: {} };
      body.algo_params[algo.toLowerCase()] = params;
      
      await this.apiCall('/hashes_settings', {
        method: 'POST',
        body: JSON.stringify(body)
      });
      
      this.loadAlgoParams();
      this.showToast(`Parameters saved for algorithm "${algo}"`, 'success');
      
      // Clear form
      document.getElementById('algo-name').value = '';
      document.getElementById('algo-masklen').value = '';
      document.getElementById('algo-rule').value = '';
      
    } catch (error) {
      this.showToast('Failed to save algorithm parameters: ' + error.message, 'error');
    }
  }

  async saveBroadcastConfig() {
    const enabled = document.getElementById('broadcast-enabled').checked;
    const interval = parseInt(document.getElementById('broadcast-interval').value, 10) || 30;
    const port = parseInt(document.getElementById('discovery-port').value, 10) || 8888;
    
    try {
      await this.apiCall('/broadcast_config', {
        method: 'POST',
        body: JSON.stringify({
          enabled: enabled,
          interval: interval,
          port: port
        })
      });
      
      this.showToast('Broadcast configuration saved successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to save broadcast config: ' + error.message, 'error');
    }
  }

  async loadServerConfig() {
    // Load default values or existing config
    try {
      // TODO: Implement server config loading endpoint
      // For now, just set defaults
    } catch (error) {
      console.error('Failed to load server config:', error);
    }
  }

  async saveServerConfig() {
    const maxImportSize = parseInt(document.getElementById('max-import-size').value, 10) || 100;
    const defaultPriority = parseInt(document.getElementById('default-priority').value, 10) || 5;
    const autoBackup = document.getElementById('auto-backup').checked;
    const backupInterval = parseInt(document.getElementById('backup-interval').value, 10) || 24;
    
    try {
      await this.apiCall('/server_config', {
        method: 'POST',
        body: JSON.stringify({
          max_import_size_mb: maxImportSize,
          default_hash_priority: defaultPriority,
          auto_backup_enabled: autoBackup,
          backup_interval_hours: backupInterval
        })
      });
      
      this.showToast('Server configuration saved successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to save server config: ' + error.message, 'error');
    }
  }

  // ============================================================================
  // WEBSOCKET MANAGEMENT
  // ============================================================================

  connectWebSocket() {
    if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {
      return;
    }

    const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${protocol}://${location.host}/ws/portal`;
    
    this.updateConnectionStatus('connecting');
    
    try {
      this.wsConnection = new WebSocket(wsUrl);
      
      this.wsConnection.onopen = () => {
        console.log('WebSocket connected');
        this.updateConnectionStatus('connected');
      };
      
      this.wsConnection.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.handleWebSocketMessage(data);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };
      
      this.wsConnection.onclose = (event) => {
        console.log('WebSocket disconnected:', event.code, event.reason);
        this.updateConnectionStatus('disconnected');
        setTimeout(() => this.connectWebSocket(), 5000);
      };
      
      this.wsConnection.onerror = (error) => {
        console.error('WebSocket error:', error);
        this.updateConnectionStatus('error');
      };
      
    } catch (error) {
      console.error('Failed to create WebSocket connection:', error);
      this.updateConnectionStatus('error');
      setTimeout(() => this.connectWebSocket(), 10000);
    }
  }

  handleWebSocketMessage(data) {
    if (data.metrics) {
      // Real-time metric updates
      if (this.currentTab === 'overview') {
        this.updateSystemMetrics();
      }
    }
    
    if (data.founds && data.founds.length > 0) {
      // New found hashes
      if (this.currentTab === 'overview') {
        this.refreshWallOfSheep();
      }
      this.showToast(`Found ${data.founds.length} new hash(es)!`, 'success');
    }
    
    if (data.workers) {
      // Worker status changes
      if (this.currentTab === 'overview' || this.currentTab === 'management') {
        this.refreshCurrentTab();
      }
    }
  }

  updateConnectionStatus(status) {
    const statusElement = document.getElementById('connection-status');
    const textElement = document.getElementById('connection-text');
    const spinnerElement = document.getElementById('connection-spinner');
    
    if (!statusElement || !textElement) return;
    
    statusElement.className = 'connection-status';
    
    switch (status) {
      case 'connected':
        statusElement.classList.add('connected');
        textElement.textContent = 'Connected';
        spinnerElement.style.display = 'none';
        break;
      case 'connecting':
        textElement.textContent = 'Connecting...';
        spinnerElement.style.display = 'inline-block';
        break;
      case 'disconnected':
        statusElement.classList.add('disconnected');
        textElement.textContent = 'Disconnected';
        spinnerElement.style.display = 'none';
        break;
      case 'error':
        statusElement.classList.add('disconnected');
        textElement.textContent = 'Connection Error';
        spinnerElement.style.display = 'none';
        break;
    }
  }

  // ============================================================================
  // AUTO-REFRESH MANAGEMENT
  // ============================================================================

  toggleAutoRefresh() {
    this.autoRefresh = !this.autoRefresh;
    const btn = document.getElementById('auto-refresh-btn');
    
    if (this.autoRefresh) {
      btn.textContent = '⏸️ Pause Updates';
      this.startRefreshTimer();
      this.showToast('Auto-refresh enabled', 'success', 2000);
    } else {
      btn.textContent = '▶️ Resume Updates';
      this.stopRefreshTimer();
      this.showToast('Auto-refresh paused', 'warning', 2000);
    }
  }

  startRefreshTimer() {
    this.stopRefreshTimer();
    
    if (this.autoRefresh) {
      this.refreshTimer = setInterval(() => {
        this.refreshCurrentTab();
      }, this.refreshInterval);
    }
  }

  stopRefreshTimer() {
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
      this.refreshTimer = null;
    }
  }

  // ============================================================================
  // AUTHENTICATION
  // ============================================================================

  showLogin() {
    document.getElementById('login-overlay').style.display = 'flex';
    document.getElementById('passkey').focus();
  }

  hideLogin() {
    document.getElementById('login-overlay').style.display = 'none';
  }

  async submitPasskey() {
    const passkey = document.getElementById('passkey').value.trim();
    const errorElement = document.getElementById('login-error');
    
    if (!passkey) {
      errorElement.textContent = 'Please enter a passkey';
      return;
    }

    try {
      const response = await this.apiCall('/login', {
        method: 'POST',
        body: JSON.stringify({ passkey })
      });

      if (response.ok) {
        const data = await response.json();
        document.cookie = `session=${data.cookie}; path=/; SameSite=Strict`;
        this.hideLogin();
        this.refreshCurrentTab();
        this.showToast('Login successful', 'success');
      }
    } catch (error) {
      errorElement.textContent = error.message || 'Invalid passkey';
    }
  }

  handleLoginKeypress(event) {
    if (event.key === 'Enter') {
      this.submitPasskey();
    }
  }

  async logout() {
    try {
      const match = document.cookie.match(/(?:^|; )session=([^;]+)/);
      if (match) {
        await this.apiCall('/logout', {
          method: 'POST',
          body: JSON.stringify({ token: match[1] })
        });
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      document.cookie = 'session=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT';
      location.reload();
    }
  }

  // ============================================================================
  // 3RD PARTY SERVICES MANAGEMENT
  // ============================================================================
  
  loadServicesConfig() {
    // Load from localStorage
    const saved = localStorage.getItem('hashmancer-services');
    if (saved) {
      this.enabledServices = JSON.parse(saved);
    }
    this.updateServiceTabs();
    this.updateServiceCheckboxes();
  }
  
  saveServicesConfig() {
    localStorage.setItem('hashmancer-services', JSON.stringify(this.enabledServices));
    this.updateServiceTabs();
    this.showToast('Service settings saved successfully', 'success');
  }
  
  toggleService(serviceName) {
    const checkbox = document.getElementById(`service-${serviceName}`);
    this.enabledServices[serviceName] = checkbox.checked;
    this.updateServiceTabs();
    
    // Auto-save settings when toggled
    localStorage.setItem('hashmancer-services', JSON.stringify(this.enabledServices));
    
    // Show feedback
    const status = checkbox.checked ? 'enabled' : 'disabled';
    this.showToast(`${serviceName} ${status}`, 'success');
  }
  
  updateServiceTabs() {
    const tabNav = document.querySelector('.tab-nav');
    
    // Remove existing service tabs
    const serviceTabs = tabNav.querySelectorAll('.service-tab');
    serviceTabs.forEach(tab => tab.remove());
    
    // Add enabled service tabs
    Object.entries(this.enabledServices).forEach(([service, enabled]) => {
      if (enabled) {
        const tabButton = document.createElement('button');
        tabButton.className = 'tab-button service-tab';
        tabButton.setAttribute('data-tab', service);
        tabButton.onclick = () => this.switchTab(service);
        
        const icons = {
          vastai: '🖥️',
          hashescom: '🔍',
          saladai: '🥗',
          grok: '🤖'
        };
        
        const names = {
          vastai: 'Vast.ai',
          hashescom: 'Hashes.com',
          saladai: 'Salad AI',
          grok: 'Grok'
        };
        
        tabButton.innerHTML = `${icons[service]} ${names[service]}`;
        tabNav.appendChild(tabButton);
      }
    });
  }
  
  updateServiceCheckboxes() {
    Object.entries(this.enabledServices).forEach(([service, enabled]) => {
      const checkbox = document.getElementById(`service-${service}`);
      if (checkbox) {
        checkbox.checked = enabled;
      }
    });
  }

  // Vast.ai specific functions
  async refreshVastaiTab() {
    await this.refreshVastaiInstances();
  }

  async saveVastaiConfig() {
    const apiKey = document.getElementById('vastai-api-key').value;
    const budget = parseFloat(document.getElementById('vastai-budget').value) || 10.0;
    
    try {
      // Save to backend or localStorage
      localStorage.setItem('vastai-config', JSON.stringify({
        apiKey,
        budget
      }));
      
      this.showToast('Vast.ai configuration saved', 'success');
    } catch (error) {
      this.showToast('Failed to save Vast.ai config: ' + error.message, 'error');
    }
  }

  async launchVastaiInstance() {
    const gpuType = document.getElementById('vastai-gpu-type').value;
    const maxPrice = parseFloat(document.getElementById('vastai-max-price').value) || 1.0;
    const ram = parseInt(document.getElementById('vastai-ram').value) || 32;
    const storage = parseInt(document.getElementById('vastai-storage').value) || 100;
    
    try {
      // This would call your vast.ai backend integration
      this.showToast('Launching Vast.ai instance...', 'info');
      
      // Placeholder for actual API call
      setTimeout(() => {
        this.showToast('Vast.ai instance launched successfully', 'success');
        this.refreshVastaiInstances();
      }, 2000);
      
    } catch (error) {
      this.showToast('Failed to launch Vast.ai instance: ' + error.message, 'error');
    }
  }

  async refreshVastaiInstances() {
    const container = document.getElementById('vastai-instances');
    
    try {
      // Check if API key is configured
      const config = localStorage.getItem('vastai-config');
      if (!config || !JSON.parse(config).apiKey) {
        container.innerHTML = `
          <div class="no-instances">
            <div class="no-instances-icon">🔑</div>
            <p>API Key Required</p>
            <small>Please configure your Vast.ai API key above to view active instances</small>
          </div>
        `;
        return;
      }

      // Show loading state
      container.innerHTML = `
        <div class="loading-placeholder">
          <div class="spinner"></div>
          <p>Loading active instances...</p>
        </div>
      `;

      // Simulate API call - in real implementation, this would call the Vast.ai API
      setTimeout(() => {
        // For now, show no instances until real API integration
        container.innerHTML = `
          <div class="no-instances">
            <div class="no-instances-icon">🖥️</div>
            <p>No active instances</p>
            <small>Launch an instance from the available instances below to get started</small>
          </div>
        `;
      }, 1000);
      
    } catch (error) {
      container.innerHTML = '<p style="color: var(--error-color);">Failed to load instances</p>';
    }
  }

  async stopVastaiInstance(instanceId) {
    try {
      this.showToast(`Stopping Vast.ai instance ${instanceId}...`, 'info');
      // Placeholder for actual API call
      setTimeout(() => {
        this.showToast('Instance stopped', 'success');
        this.refreshVastaiInstances();
      }, 1000);
    } catch (error) {
      this.showToast('Failed to stop instance: ' + error.message, 'error');
    }
  }

  // Other service functions (placeholders)
  async refreshHashescomTab() {
    this.loadHashescomConfig();
    this.updateHashescomStatus();
  }
  
  async refreshSaladaiTab() {}
  async refreshGrokTab() {}
  
  async saveHashescomConfig() {
    const apiKey = document.getElementById('hashescom-api-key').value;
    const algorithms = document.getElementById('hashescom-algorithms').value;
    const pollInterval = parseInt(document.getElementById('hashescom-poll-interval').value) || 30;
    
    const config = { apiKey, algorithms, pollInterval };
    localStorage.setItem('hashescom-config', JSON.stringify(config));
    this.showToast('Hashes.com configuration saved', 'success');
  }

  async savePaymentFilters() {
    const rejectZeroPayment = document.getElementById('hashescom-reject-zero-payment').checked;
    const minPayment = parseFloat(document.getElementById('hashescom-min-payment').value) || 0.01;
    const acceptBTC = document.getElementById('hashescom-accept-btc').checked;
    const acceptLTC = document.getElementById('hashescom-accept-ltc').checked;
    const acceptXMR = document.getElementById('hashescom-accept-xmr').checked;
    
    const filters = {
      rejectZeroPayment,
      minPayment,
      acceptedCurrencies: {
        BTC: acceptBTC,
        LTC: acceptLTC,
        XMR: acceptXMR
      }
    };
    
    localStorage.setItem('hashescom-payment-filters', JSON.stringify(filters));
    this.showToast('Payment filters saved', 'success');
  }

  loadHashescomConfig() {
    // Load main config
    const config = localStorage.getItem('hashescom-config');
    if (config) {
      const data = JSON.parse(config);
      if (document.getElementById('hashescom-api-key')) {
        document.getElementById('hashescom-api-key').value = data.apiKey || '';
        document.getElementById('hashescom-algorithms').value = data.algorithms || 'md5,sha1,sha256';
        document.getElementById('hashescom-poll-interval').value = data.pollInterval || 30;
      }
    }

    // Load payment filters
    const filters = localStorage.getItem('hashescom-payment-filters');
    if (filters) {
      const data = JSON.parse(filters);
      if (document.getElementById('hashescom-reject-zero-payment')) {
        document.getElementById('hashescom-reject-zero-payment').checked = data.rejectZeroPayment !== false;
        document.getElementById('hashescom-min-payment').value = data.minPayment || 0.01;
        document.getElementById('hashescom-accept-btc').checked = data.acceptedCurrencies?.BTC !== false;
        document.getElementById('hashescom-accept-ltc').checked = data.acceptedCurrencies?.LTC !== false;
        document.getElementById('hashescom-accept-xmr').checked = data.acceptedCurrencies?.XMR !== false;
      }
    }

    // Load statistics
    this.loadHashescomStats();
  }

  loadHashescomStats() {
    const stats = localStorage.getItem('hashescom-stats');
    if (stats) {
      const data = JSON.parse(stats);
      if (document.getElementById('hashescom-total-earned')) {
        document.getElementById('hashescom-total-earned').textContent = `$${data.totalEarned?.toFixed(2) || '0.00'}`;
        document.getElementById('hashescom-jobs-completed').textContent = data.jobsCompleted || 0;
        document.getElementById('hashescom-success-rate').textContent = `${data.successRate || 0}%`;
        document.getElementById('hashescom-avg-payment').textContent = `$${data.avgPayment?.toFixed(2) || '0.00'}`;
      }
    }
  }

  async fetchHashescomJobs() {
    const config = localStorage.getItem('hashescom-config');
    if (!config) {
      this.showToast('Please configure API key first', 'warning');
      return;
    }

    const { apiKey, algorithms } = JSON.parse(config);
    if (!apiKey) {
      this.showToast('API key is required', 'warning');
      return;
    }

    this.showToast('Fetching jobs from Hashes.com...', 'info');

    try {
      // Simulate API call - replace with actual Hashes.com API integration
      const mockJobs = this.generateMockHashescomJobs();
      const filteredJobs = this.filterJobsByPayment(mockJobs);
      
      // Store jobs for acceptance processing
      localStorage.setItem('hashescom-available-jobs', JSON.stringify(mockJobs));
      
      this.displayHashescomJobs(filteredJobs);
      this.updateJobCounts(mockJobs, filteredJobs);
      
      document.getElementById('hashescom-last-check').textContent = new Date().toLocaleTimeString();
      
      this.showToast(`Fetched ${filteredJobs.length} jobs (${mockJobs.length - filteredJobs.length} rejected)`, 'success');
      
    } catch (error) {
      this.showToast('Failed to fetch jobs: ' + error.message, 'error');
    }
  }

  generateMockHashescomJobs() {
    const algorithms = ['md5', 'sha1', 'sha256', 'sha512', 'ntlm'];
    const currencies = ['BTC', 'LTC', 'XMR', 'ETH'];
    const jobs = [];

    for (let i = 0; i < 15; i++) {
      const hasPayment = Math.random() > 0.3; // 70% have payment
      const payment = hasPayment ? Math.random() * 5 + 0.01 : 0;
      const currency = currencies[Math.floor(Math.random() * currencies.length)];
      
      jobs.push({
        id: `job_${Date.now()}_${i}`,
        algorithm: algorithms[Math.floor(Math.random() * algorithms.length)],
        hash: this.generateRandomHash(),
        payment: payment,
        currency: currency,
        difficulty: Math.floor(Math.random() * 5) + 1,
        timePosted: new Date(Date.now() - Math.random() * 3600000),
        status: 'available'
      });
    }

    return jobs;
  }

  generateRandomHash() {
    const chars = '0123456789abcdef';
    let hash = '';
    const length = Math.random() > 0.5 ? 32 : 64; // MD5 or SHA256 length
    for (let i = 0; i < length; i++) {
      hash += chars[Math.floor(Math.random() * chars.length)];
    }
    return hash;
  }

  filterJobsByPayment(jobs) {
    const filters = localStorage.getItem('hashescom-payment-filters');
    if (!filters) return jobs;

    const { rejectZeroPayment, minPayment, acceptedCurrencies } = JSON.parse(filters);
    
    return jobs.filter(job => {
      // Reject zero payment jobs if enabled
      if (rejectZeroPayment && job.payment <= 0) return false;
      
      // Check minimum payment
      if (job.payment < minPayment) return false;
      
      // Check accepted currencies
      if (!acceptedCurrencies[job.currency]) return false;
      
      return true;
    });
  }

  displayHashescomJobs(jobs) {
    const container = document.getElementById('hashescom-job-queue');
    
    if (jobs.length === 0) {
      container.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No jobs match your payment criteria.</div>';
      return;
    }

    container.innerHTML = jobs.map(job => `
      <div class="job-item" style="border-bottom: 1px solid var(--border-color); padding: 10px;">
        <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 5px;">
          <strong style="color: var(--primary-color);">Job ${job.id.split('_')[2]}</strong>
          <span style="color: var(--success-color); font-weight: bold;">
            ${job.payment > 0 ? `$${job.payment.toFixed(3)} ${job.currency}` : 'No payment'}
          </span>
        </div>
        <div style="font-size: 0.9rem; color: #ccc; margin-bottom: 5px;">
          Algorithm: <span style="color: var(--warning-color);">${job.algorithm.toUpperCase()}</span> | 
          Difficulty: <span style="color: var(--primary-color);">${'★'.repeat(job.difficulty)}</span>
        </div>
        <div style="font-family: monospace; font-size: 0.8rem; color: #888; margin-bottom: 8px; word-break: break-all;">
          ${job.hash}
        </div>
        <div style="display: flex; gap: 5px;">
          <button onclick="app.acceptHashescomJob('${job.id}')" class="success" style="padding: 5px 10px; font-size: 0.8rem;">✅ Accept</button>
          <button onclick="app.rejectHashescomJob('${job.id}')" class="danger" style="padding: 5px 10px; font-size: 0.8rem;">❌ Reject</button>
          <button onclick="app.viewJobDetails('${job.id}')" class="info" style="padding: 5px 10px; font-size: 0.8rem;">👁️ Details</button>
        </div>
      </div>
    `).join('');
  }

  updateJobCounts(allJobs, filteredJobs) {
    const rejectedCount = allJobs.length - filteredJobs.length;
    document.getElementById('hashescom-active-jobs').textContent = filteredJobs.length;
    document.getElementById('hashescom-rejected-jobs').textContent = rejectedCount;
  }

  updateHashescomStatus() {
    const isPolling = this.hashescomPollingTimer !== null;
    const statusEl = document.getElementById('hashescom-polling-status');
    if (statusEl) {
      statusEl.textContent = isPolling ? 'Running' : 'Stopped';
      statusEl.style.color = isPolling ? 'var(--success-color)' : '#888';
    }
  }

  startJobPolling() {
    if (this.hashescomPollingTimer) {
      this.showToast('Job polling is already running', 'info');
      return;
    }

    const config = localStorage.getItem('hashescom-config');
    if (!config) {
      this.showToast('Please configure API settings first', 'warning');
      return;
    }

    const { pollInterval } = JSON.parse(config);
    const intervalMs = (pollInterval || 30) * 60 * 1000; // Convert minutes to milliseconds

    this.hashescomPollingTimer = setInterval(() => {
      this.fetchHashescomJobs();
    }, intervalMs);

    this.updateHashescomStatus();
    this.showToast(`Started polling every ${pollInterval || 30} minutes`, 'success');
  }

  stopJobPolling() {
    if (this.hashescomPollingTimer) {
      clearInterval(this.hashescomPollingTimer);
      this.hashescomPollingTimer = null;
      this.updateHashescomStatus();
      this.showToast('Job polling stopped', 'info');
    } else {
      this.showToast('Job polling is not running', 'info');
    }
  }

  async acceptHashescomJob(jobId) {
    try {
      console.log('acceptHashescomJob called with ID:', jobId);
      this.showToast(`Accepting job ${jobId}...`, 'info');
      
      // Find the job in the current job list
      const jobs = JSON.parse(localStorage.getItem('hashescom-available-jobs') || '[]');
      console.log('Available jobs:', jobs.length);
      const job = jobs.find(j => j.id === jobId);
      
      if (!job) {
        console.error('Job not found in available jobs:', jobId);
        this.showToast('Job not found', 'error');
        return;
      }
      
      console.log('Found job:', job);
      
      // Create job plans based on settings
      const jobPlans = this.createJobPlans(job);
      console.log('Created job plans:', jobPlans);
      
      // Save all job plans to accepted jobs
      const acceptedJobs = JSON.parse(localStorage.getItem('hashescom-accepted-jobs') || '[]');
      jobPlans.forEach(plan => acceptedJobs.push(plan));
      localStorage.setItem('hashescom-accepted-jobs', JSON.stringify(acceptedJobs));
      
      // Send to server for processing using direct fetch to avoid response conflicts
      console.log('Sending job to server API...');
      const primaryPlan = jobPlans[0]; // Use first plan for server submission
      const jobData = {
        hash: job.hash,
        hash_type: job.hashType,
        algorithm: job.algorithm,
        attack_mode: primaryPlan.attack_mode,
        mask: primaryPlan.mask,
        wordlist: primaryPlan.wordlist,
        rules: primaryPlan.rules,
        markov_enabled: primaryPlan.markov_enabled || false,
        markov_threshold: primaryPlan.markov_threshold || 0.01,
        source: 'hashes.com',
        payment_info: {
          amount: job.payment,
          currency: job.currency
        }
      };
      console.log('Job data being sent:', jobData);
      
      const response = await fetch('/api/jobs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(jobData)
      });
      
      console.log('Response status:', response.status, response.statusText);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Server error response:', errorText);
        throw new Error(`Server error: ${response.status} ${response.statusText}`);
      }
      
      const result = await response.json();
      console.log('Job creation result:', result);
      
      // Process successful response
      jobPlans[0].job_id = result.job_id;
      jobPlans[0].status = 'queued';
      
      // Update the stored jobs
      const updatedJobs = JSON.parse(localStorage.getItem('hashescom-accepted-jobs') || '[]');
      localStorage.setItem('hashescom-accepted-jobs', JSON.stringify(updatedJobs));
      
      const planText = jobPlans.length > 1 ? `${jobPlans.length} job plans` : '1 job plan';
      this.showToast(`Job ${jobId} accepted - created ${planText}`, 'success');
      
      // Remove from available jobs display
      const jobElement = document.querySelector(`[onclick*="${jobId}"]`)?.closest('.job-item');
      if (jobElement) {
        jobElement.remove();
      }
      
      // Update job counts
      this.updateJobCounts();
      
      // Refresh the jobs overview to show the new job
      await this.loadJobsOverview();
      
      // Simulate job progression for demo purposes
      this.simulateJobProgress(newJob.id);
      
    } catch (error) {
      console.error('Error accepting job:', error);
      this.showToast(`Failed to accept job: ${error.message}`, 'error');
    }
  }

  async rejectHashescomJob(jobId) {
    this.showToast(`Rejected job ${jobId}`, 'info');
    // Remove from display
    const jobElement = document.querySelector(`[onclick*="${jobId}"]`)?.closest('.job-item');
    if (jobElement) {
      jobElement.remove();
    }
  }

  async viewJobDetails(jobId) {
    this.showToast(`Viewing details for job ${jobId}`, 'info');
    // TODO: Implement job details modal
  }

  clearCompletedJobs() {
    const container = document.getElementById('hashescom-job-queue');
    container.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">Completed jobs cleared.</div>';
    this.showToast('Cleared completed jobs', 'success');
  }

  resetHashescomStats() {
    localStorage.removeItem('hashescom-stats');
    this.loadHashescomStats();
    this.showToast('Statistics reset', 'success');
  }

  simulateJobProgress(jobId) {
    console.log('Simulating job progress for:', jobId);
    
    // Update job status to 'running' after 3 seconds
    setTimeout(() => {
      this.updateJobStatus(jobId, 'running');
      this.showToast(`Job ${jobId} is now running`, 'info');
    }, 3000);
    
    // Simulate completion after 15-30 seconds
    const completionTime = Math.random() * 15000 + 15000; // 15-30 seconds
    setTimeout(async () => {
      // 80% chance of success, 20% chance of failure for demo
      const success = Math.random() > 0.2;
      if (success) {
        this.updateJobStatus(jobId, 'completed');
        this.showToast(`Job ${jobId} completed successfully!`, 'success');
        
        // Send notification for job completion
        await this.sendNotification('jobComplete', {
          title: 'Job Completed Successfully',
          message: `Job ${jobId} has finished processing with successful results.`,
          timestamp: new Date().toISOString()
        });
        
        // Add a mock result to wall of sheep
        const crackedHash = {
          hash: 'b5b7b2f46265aebdeaed2736e1d9e3f',
          plaintext: 'password123',
          job_id: jobId,
          timestamp: new Date().toISOString()
        };
        
        this.addToWallOfSheep(crackedHash);
        
        // Send notification for hash cracked
        await this.sendNotification('hashCracked', {
          title: 'Hash Cracked!',
          message: `Successfully cracked hash: ${crackedHash.plaintext}`,
          timestamp: new Date().toISOString()
        });
        
      } else {
        this.updateJobStatus(jobId, 'failed');
        this.showToast(`Job ${jobId} failed`, 'error');
        
        // Send notification for task failure
        await this.sendNotification('taskFailed', {
          title: 'Task Failed',
          message: `Job ${jobId} failed to complete. Check agent logs for details.`,
          timestamp: new Date().toISOString()
        });
      }
    }, completionTime);
  }

  updateJobStatus(jobId, newStatus) {
    console.log('Updating job status:', jobId, 'to', newStatus);
    
    // Update in accepted jobs
    const acceptedJobs = JSON.parse(localStorage.getItem('hashescom-accepted-jobs') || '[]');
    const updatedJobs = acceptedJobs.map(job => {
      if (job.id === jobId) {
        job.status = newStatus;
        job.updated_at = new Date().toISOString();
      }
      return job;
    });
    localStorage.setItem('hashescom-accepted-jobs', JSON.stringify(updatedJobs));
    
    // Update in local jobs if exists
    const localJobs = JSON.parse(localStorage.getItem('local-jobs') || '[]');
    const updatedLocalJobs = localJobs.map(job => {
      if (job.id === jobId) {
        job.status = newStatus;
        job.updated_at = new Date().toISOString();
      }
      return job;
    });
    localStorage.setItem('local-jobs', JSON.stringify(updatedLocalJobs));
    
    // Refresh the jobs overview
    this.loadJobsOverview();
  }

  addToWallOfSheep(result) {
    console.log('Adding result to wall of sheep:', result);
    
    // Get existing results
    const existingResults = JSON.parse(localStorage.getItem('wall-of-sheep-results') || '[]');
    
    // Add new result
    existingResults.unshift(result);
    
    // Keep only last 50 results
    if (existingResults.length > 50) {
      existingResults.splice(50);
    }
    
    // Save back to localStorage
    localStorage.setItem('wall-of-sheep-results', JSON.stringify(existingResults));
    
    // Refresh wall of sheep display
    this.refreshWallOfSheep();
  }
  
  async saveSaladaiConfig() {
    const apiKey = document.getElementById('saladai-api-key').value;
    const project = document.getElementById('saladai-project').value;
    
    localStorage.setItem('saladai-config', JSON.stringify({ apiKey, project }));
    this.showToast('Salad AI configuration saved', 'success');
  }
  
  async saveGrokConfig() {
    const apiKey = document.getElementById('grok-api-key').value;
    const model = document.getElementById('grok-model').value;
    
    localStorage.setItem('grok-config', JSON.stringify({ apiKey, model }));
    this.showToast('Grok configuration saved', 'success');
  }

  async testHashescomConnection() {
    this.showToast('Testing Hashes.com connection...', 'info');
    // Placeholder for actual API test
    setTimeout(() => {
      this.showToast('Hashes.com connection successful', 'success');
    }, 1000);
  }

  loadJobSettings() {
    const stored = localStorage.getItem('job-settings');
    if (stored) {
      this.jobSettings = { ...this.jobSettings, ...JSON.parse(stored) };
    }
    
    // Initialize default task pipeline if empty
    if (!this.jobSettings.taskPipeline || this.jobSettings.taskPipeline.length === 0) {
      this.resetTaskPipeline(false); // Don't save immediately
    }
    
    // Update UI with loaded settings
    const defaultAttackMode = document.getElementById('default-attack-mode');
    const executionStrategy = document.getElementById('execution-strategy');
    const defaultMask = document.getElementById('default-mask');
    const defaultDictionary = document.getElementById('default-dictionary');
    const defaultRules = document.getElementById('default-rules');
    const chunkSize = document.getElementById('chunk-size');
    const benchmarkType = document.getElementById('benchmark-type');
    const maxAgents = document.getElementById('max-agents');
    const optimizedKernel = document.getElementById('optimized-kernel');
    const smallTasks = document.getElementById('small-tasks');
    
    if (defaultAttackMode) defaultAttackMode.value = this.jobSettings.defaultAttackMode;
    if (executionStrategy) executionStrategy.value = this.jobSettings.executionStrategy;
    if (defaultMask) defaultMask.value = this.jobSettings.defaultMask;
    if (defaultDictionary) defaultDictionary.value = this.jobSettings.defaultDictionary;
    if (defaultRules) defaultRules.value = this.jobSettings.defaultRules;
    if (chunkSize) chunkSize.value = this.jobSettings.chunkSize;
    if (benchmarkType) benchmarkType.value = this.jobSettings.benchmarkType;
    if (maxAgents) maxAgents.value = this.jobSettings.maxAgents;
    if (optimizedKernel) optimizedKernel.checked = this.jobSettings.optimizedKernel;
    if (smallTasks) smallTasks.checked = this.jobSettings.smallTasks;
    
    // Render task pipeline
    this.renderTaskPipeline();
  }

  saveJobSettings() {
    // Get values from UI
    const defaultAttackMode = document.getElementById('default-attack-mode').value;
    const executionStrategy = document.getElementById('execution-strategy').value;
    const defaultMask = document.getElementById('default-mask').value;
    const defaultDictionary = document.getElementById('default-dictionary').value;
    const defaultRules = document.getElementById('default-rules').value;
    const chunkSize = parseInt(document.getElementById('chunk-size').value);
    const benchmarkType = document.getElementById('benchmark-type').value;
    const maxAgents = parseInt(document.getElementById('max-agents').value);
    const optimizedKernel = document.getElementById('optimized-kernel').checked;
    const smallTasks = document.getElementById('small-tasks').checked;
    
    // Update settings object
    this.jobSettings = {
      ...this.jobSettings,
      defaultAttackMode,
      executionStrategy,
      defaultMask,
      defaultDictionary,
      defaultRules,
      chunkSize,
      benchmarkType,
      maxAgents,
      optimizedKernel,
      smallTasks
    };
    
    // Save to localStorage
    localStorage.setItem('job-settings', JSON.stringify(this.jobSettings));
    this.showToast('Job settings saved successfully', 'success');
  }

  createJobPlans(job) {
    const plans = [];
    const baseJob = {
      original_id: job.id,
      hash: job.hash,
      hash_type: job.hashType,
      algorithm: job.algorithm,
      payment: job.payment,
      currency: job.currency,
      status: 'accepted',
      created_at: new Date().toISOString(),
      source: 'hashes.com'
    };
    
    if (this.jobSettings.executionStrategy === 'simple') {
      // Single plan with default settings
      plans.push({
        ...baseJob,
        id: `job_${Date.now()}`,
        attack_mode: this.jobSettings.defaultAttackMode,
        mask: this.jobSettings.defaultMask,
        wordlist: this.jobSettings.defaultDictionary,
        rules: this.jobSettings.defaultRules,
        plan_name: `${this.jobSettings.defaultAttackMode} attack`,
        priority: 1
      });
    } else {
      // Use task pipeline to create jobs
      this.jobSettings.taskPipeline.forEach((task, index) => {
        const taskId = `job_${Date.now()}_${index}`;
        const plan = {
          ...baseJob,
          id: taskId,
          attack_mode: task.attackMode,
          plan_name: task.name,
          priority: task.priority,
          pipeline_order: index,
          execution_strategy: this.jobSettings.executionStrategy
        };
        
        // Add attack-specific parameters
        if (task.attackMode === 'mask') {
          plan.mask = task.mask || this.jobSettings.defaultMask;
        } else if (task.attackMode === 'dictionary') {
          plan.wordlist = task.wordlist || this.jobSettings.defaultDictionary;
          plan.rules = task.rules || this.jobSettings.defaultRules;
        } else if (task.attackMode === 'combinator') {
          plan.wordlist1 = task.wordlist1 || this.jobSettings.defaultDictionary;
          plan.wordlist2 = task.wordlist2 || this.jobSettings.defaultDictionary;
        } else if (task.attackMode === 'hybrid') {
          plan.wordlist = task.wordlist || this.jobSettings.defaultDictionary;
          plan.mask = task.mask || this.jobSettings.defaultMask;
        }
        
        // Add additional parameters
        if (task.markovEnabled) {
          plan.markov_enabled = true;
          plan.markov_threshold = task.markovThreshold || 0.01;
        }
        
        plans.push(plan);
      });
    }
    
    return plans;
  }
  
  renderTaskPipeline() {
    const container = document.getElementById('task-pipeline-list');
    if (!container) return;
    
    if (!this.jobSettings.taskPipeline || this.jobSettings.taskPipeline.length === 0) {
      container.innerHTML = '<div class="task-pipeline-empty">No tasks configured. Click "Add Task" to create your first task.</div>';
      return;
    }
    
    container.innerHTML = this.jobSettings.taskPipeline.map((task, index) => `
      <div class="task-pipeline-item" draggable="true" data-index="${index}">
        <div class="drag-handle">⋮⋮</div>
        <div class="task-info">
          <div class="task-priority">${task.priority}</div>
          <div>
            <div class="task-name">${this.sanitizeHTML(task.name)}</div>
            <div class="task-details">
              ${this.sanitizeHTML(task.attackMode)} ${task.attackMode === 'mask' ? `- ${task.mask || this.jobSettings.defaultMask}` : ''}
              ${task.attackMode === 'dictionary' ? `- ${task.wordlist || this.jobSettings.defaultDictionary}` : ''}
              ${task.markovEnabled ? ' + Markov' : ''}
            </div>
          </div>
        </div>
        <div class="task-actions">
          <button class="task-action-btn" onclick="app.editTaskInPipeline(${index})">✏️</button>
          <button class="task-action-btn delete" onclick="app.removeTaskFromPipeline(${index})">🗑️</button>
        </div>
      </div>
    `).join('');
    
    // Add drag and drop functionality
    this.initializeDragAndDrop();
  }
  
  addTaskToPipeline() {
    const newTask = {
      id: `task_${Date.now()}`,
      name: `Task ${this.jobSettings.taskPipeline.length + 1}`,
      attackMode: 'mask',
      priority: this.jobSettings.taskPipeline.length + 1,
      mask: this.jobSettings.defaultMask,
      wordlist: this.jobSettings.defaultDictionary,
      rules: this.jobSettings.defaultRules,
      markovEnabled: false,
      markovThreshold: 0.01
    };
    
    this.jobSettings.taskPipeline.push(newTask);
    this.renderTaskPipeline();
    this.saveJobSettings();
    this.showToast('Task added to pipeline', 'success');
  }

  addMaskPreset() {
    const maskPresets = [
      { name: 'Cap + 6 Lower + 2 Digits + Symbol', mask: '?u?l?l?l?l?l?l?d?d?s' },
      { name: 'Cap + 7 Lower + 4 Digits', mask: '?u?l?l?l?l?l?l?l?d?d?d?d' },
      { name: 'Cap + 7 Lower + Digit + Lower', mask: '?u?l?l?l?l?l?l?l?d?l' },
      { name: 'Cap + 7 Lower + 3 Digits', mask: '?u?l?l?l?l?l?l?l?d?d?d' },
      { name: 'Cap + 6 Lower + 3 Digits', mask: '?u?l?l?l?l?l?l?d?d?d' },
      { name: 'Cap + 6 Lower + Digit + Symbol', mask: '?u?l?l?l?l?l?d?s' },
      { name: 'Cap + 6 Lower + 4 Digits + Symbol', mask: '?u?l?l?l?l?l?d?d?d?d?s' },
      { name: 'Cap + 7 Lower + Digit + 2 Upper', mask: '?u?l?l?l?l?l?l?l?d?u?u' },
      { name: 'Cap + 10 Lower + 2 Digits', mask: '?u?l?l?l?l?l?l?l?l?l?d?d' },
      { name: 'Cap + 7 Lower + Digit + Symbol', mask: '?u?l?l?l?l?l?l?l?d?s' },
      { name: 'Cap + 5 Lower + 4 Digits + Symbol', mask: '?u?l?l?l?l?l?d?d?d?d?s' },
      { name: 'Cap + 3 Lower + 4 Digits + Symbol', mask: '?u?l?l?l?d?d?d?d?s' },
      { name: 'Cap + 3 Lower + Digit + 3 Lower + Symbol', mask: '?u?l?l?l?d?l?l?l?s' },
      { name: 'Cap + 6 Lower + Digit + 2 Upper', mask: '?u?l?l?l?l?l?l?d?u?u' }
    ];
    
    const presetNames = maskPresets.map((p, i) => `${i + 1}. ${p.name}`).join('\\n');
    const choice = prompt(`Choose a mask preset (1-${maskPresets.length}):\\n\\n${presetNames}`);
    
    if (choice === null) return;
    
    const index = parseInt(choice) - 1;
    if (isNaN(index) || index < 0 || index >= maskPresets.length) {
      this.showToast('Invalid selection', 'error');
      return;
    }
    
    const preset = maskPresets[index];
    const newTask = {
      id: `task_${Date.now()}`,
      name: preset.name,
      attackMode: 'mask',
      priority: this.jobSettings.taskPipeline.length + 1,
      mask: preset.mask,
      markovEnabled: false,
      markovThreshold: 0.01
    };
    
    this.jobSettings.taskPipeline.push(newTask);
    this.renderTaskPipeline();
    this.saveJobSettings();
    this.showToast(`Added mask preset: ${preset.name}`, 'success');
  }
  
  removeTaskFromPipeline(index) {
    this.jobSettings.taskPipeline.splice(index, 1);
    // Renumber priorities
    this.jobSettings.taskPipeline.forEach((task, i) => {
      task.priority = i + 1;
    });
    this.renderTaskPipeline();
    this.saveJobSettings();
    this.showToast('Task removed from pipeline', 'info');
  }
  
  editTaskInPipeline(index) {
    const task = this.jobSettings.taskPipeline[index];
    
    // Create a simple modal for editing (could be enhanced with a proper modal)
    const newName = prompt('Task Name:', task.name);
    if (newName === null) return;
    
    const attackModes = ['mask', 'dictionary', 'combinator', 'hybrid'];
    const newAttackMode = prompt(`Attack Mode (${attackModes.join(', ')}):`, task.attackMode);
    if (newAttackMode === null) return;
    
    if (!attackModes.includes(newAttackMode)) {
      this.showToast('Invalid attack mode', 'error');
      return;
    }
    
    task.name = newName;
    task.attackMode = newAttackMode;
    
    // Get attack-specific parameters
    if (newAttackMode === 'mask') {
      const newMask = prompt('Mask Pattern:', task.mask || this.jobSettings.defaultMask);
      if (newMask !== null) task.mask = newMask;
    } else if (newAttackMode === 'dictionary') {
      const newWordlist = prompt('Wordlist:', task.wordlist || this.jobSettings.defaultDictionary);
      if (newWordlist !== null) task.wordlist = newWordlist;
      
      const newRules = prompt('Rules:', task.rules || this.jobSettings.defaultRules);
      if (newRules !== null) task.rules = newRules;
    }
    
    this.renderTaskPipeline();
    this.saveJobSettings();
    this.showToast('Task updated', 'success');
  }
  
  resetTaskPipeline(save = true) {
    this.jobSettings.taskPipeline = [
      {
        id: 'task_dict_quick',
        name: 'Quick Dictionary',
        attackMode: 'dictionary',
        priority: 1,
        wordlist: 'rockyou.txt',
        rules: 'best64.rule',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_2dig_sym',
        name: 'Cap + 6 Lower + 2 Digits + Symbol',
        attackMode: 'mask',
        priority: 2,
        mask: '?u?l?l?l?l?l?l?d?d?s',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_4dig',
        name: 'Cap + 7 Lower + 4 Digits',
        attackMode: 'mask',
        priority: 3,
        mask: '?u?l?l?l?l?l?l?l?d?d?d?d',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_dig_lower',
        name: 'Cap + 7 Lower + Digit + Lower',
        attackMode: 'mask',
        priority: 4,
        mask: '?u?l?l?l?l?l?l?l?d?l',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_3dig',
        name: 'Cap + 7 Lower + 3 Digits',
        attackMode: 'mask',
        priority: 5,
        mask: '?u?l?l?l?l?l?l?l?d?d?d',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_6l_3d',
        name: 'Cap + 6 Lower + 3 Digits',
        attackMode: 'mask',
        priority: 6,
        mask: '?u?l?l?l?l?l?l?d?d?d',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_6l_sym',
        name: 'Cap + 6 Lower + Digit + Symbol',
        attackMode: 'mask',
        priority: 7,
        mask: '?u?l?l?l?l?l?d?s',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_4dig_sym',
        name: 'Cap + 6 Lower + 4 Digits + Symbol',
        attackMode: 'mask',
        priority: 8,
        mask: '?u?l?l?l?l?l?d?d?d?d?s',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_2up',
        name: 'Cap + 7 Lower + Digit + 2 Upper',
        attackMode: 'mask',
        priority: 9,
        mask: '?u?l?l?l?l?l?l?l?d?u?u',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_10l_2d',
        name: 'Cap + 10 Lower + 2 Digits',
        attackMode: 'mask',
        priority: 10,
        mask: '?u?l?l?l?l?l?l?l?l?l?d?d',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_7l_sym',
        name: 'Cap + 7 Lower + Digit + Symbol',
        attackMode: 'mask',
        priority: 11,
        mask: '?u?l?l?l?l?l?l?l?d?s',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_5l_4d_sym',
        name: 'Cap + 5 Lower + 4 Digits + Symbol',
        attackMode: 'mask',
        priority: 12,
        mask: '?u?l?l?l?l?l?d?d?d?d?s',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_3l_4d_sym',
        name: 'Cap + 3 Lower + 4 Digits + Symbol',
        attackMode: 'mask',
        priority: 13,
        mask: '?u?l?l?l?d?d?d?d?s',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_3l_sym',
        name: 'Cap + 3 Lower + Digit + 3 Lower + Symbol',
        attackMode: 'mask',
        priority: 14,
        mask: '?u?l?l?l?d?l?l?l?s',
        markovEnabled: false
      },
      {
        id: 'task_mask_cap_6l_2up',
        name: 'Cap + 6 Lower + Digit + 2 Upper',
        attackMode: 'mask',
        priority: 15,
        mask: '?u?l?l?l?l?l?l?d?u?u',
        markovEnabled: false
      },
      {
        id: 'task_markov',
        name: 'Markov Chain Analysis',
        attackMode: 'mask',
        priority: 16,
        mask: '?l?l?l?l?l?l?l?l',
        markovEnabled: true,
        markovThreshold: 0.01
      }
    ];
    
    this.renderTaskPipeline();
    if (save) {
      this.saveJobSettings();
      this.showToast('Task pipeline reset to defaults', 'info');
    }
  }
  
  initializeDragAndDrop() {
    const items = document.querySelectorAll('.task-pipeline-item');
    items.forEach(item => {
      item.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', e.target.dataset.index);
        e.target.classList.add('dragging');
      });
      
      item.addEventListener('dragend', (e) => {
        e.target.classList.remove('dragging');
      });
      
      item.addEventListener('dragover', (e) => {
        e.preventDefault();
      });
      
      item.addEventListener('drop', (e) => {
        e.preventDefault();
        const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
        const targetIndex = parseInt(e.target.closest('.task-pipeline-item').dataset.index);
        
        if (draggedIndex !== targetIndex) {
          this.reorderTasks(draggedIndex, targetIndex);
        }
      });
    });
  }
  
  reorderTasks(fromIndex, toIndex) {
    const [movedTask] = this.jobSettings.taskPipeline.splice(fromIndex, 1);
    this.jobSettings.taskPipeline.splice(toIndex, 0, movedTask);
    
    // Update priorities
    this.jobSettings.taskPipeline.forEach((task, index) => {
      task.priority = index + 1;
    });
    
    this.renderTaskPipeline();
    this.saveJobSettings();
    this.showToast('Task order updated', 'success');
  }

  // Notification System Methods
  loadNotificationSettings() {
    const stored = localStorage.getItem('notification-settings');
    if (stored) {
      this.notificationSettings = { ...this.notificationSettings, ...JSON.parse(stored) };
    }
    
    // Update UI
    const notificationsEnabled = document.getElementById('notifications-enabled');
    const notificationEmail = document.getElementById('notification-email');
    const notifyJobComplete = document.getElementById('notify-job-complete');
    const notifyHashCracked = document.getElementById('notify-hash-cracked');
    const notifyTaskFailed = document.getElementById('notify-task-failed');
    const notifyAgentOffline = document.getElementById('notify-agent-offline');
    const discordWebhook = document.getElementById('discord-webhook');
    const slackWebhook = document.getElementById('slack-webhook');
    
    if (notificationsEnabled) notificationsEnabled.checked = this.notificationSettings.enabled;
    if (notificationEmail) notificationEmail.value = this.notificationSettings.email;
    if (notifyJobComplete) notifyJobComplete.checked = this.notificationSettings.events.jobComplete;
    if (notifyHashCracked) notifyHashCracked.checked = this.notificationSettings.events.hashCracked;
    if (notifyTaskFailed) notifyTaskFailed.checked = this.notificationSettings.events.taskFailed;
    if (notifyAgentOffline) notifyAgentOffline.checked = this.notificationSettings.events.agentOffline;
    if (discordWebhook) discordWebhook.value = this.notificationSettings.discordWebhook;
    if (slackWebhook) slackWebhook.value = this.notificationSettings.slackWebhook;
  }

  saveNotificationSettings() {
    const enabled = document.getElementById('notifications-enabled').checked;
    const email = document.getElementById('notification-email').value;
    const jobComplete = document.getElementById('notify-job-complete').checked;
    const hashCracked = document.getElementById('notify-hash-cracked').checked;
    const taskFailed = document.getElementById('notify-task-failed').checked;
    const agentOffline = document.getElementById('notify-agent-offline').checked;
    const discordWebhook = document.getElementById('discord-webhook').value;
    const slackWebhook = document.getElementById('slack-webhook').value;
    
    this.notificationSettings = {
      enabled,
      email,
      events: { jobComplete, hashCracked, taskFailed, agentOffline },
      discordWebhook,
      slackWebhook
    };
    
    localStorage.setItem('notification-settings', JSON.stringify(this.notificationSettings));
    this.showToast('Notification settings saved', 'success');
  }

  async testNotifications() {
    if (!this.notificationSettings.enabled) {
      this.showToast('Notifications are disabled', 'warning');
      return;
    }
    
    this.showToast('Testing notifications...', 'info');
    
    const testMessage = {
      title: 'Hashmancer Test Notification',
      message: 'This is a test notification from Hashmancer',
      timestamp: new Date().toISOString(),
      type: 'test'
    };
    
    await this.sendNotification('test', testMessage);
    this.showToast('Test notification sent!', 'success');
  }

  async sendNotification(eventType, data) {
    if (!this.notificationSettings.enabled) return;
    if (!this.notificationSettings.events[eventType] && eventType !== 'test') return;
    
    const notification = {
      title: data.title || 'Hashmancer Notification',
      message: data.message,
      timestamp: data.timestamp || new Date().toISOString(),
      type: eventType,
      color: this.getNotificationColor(eventType)
    };
    
    // Send to Discord
    if (this.notificationSettings.discordWebhook) {
      try {
        await fetch(this.notificationSettings.discordWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            embeds: [{
              title: notification.title,
              description: notification.message,
              color: notification.color,
              timestamp: notification.timestamp,
              footer: { text: 'Hashmancer' }
            }]
          })
        });
      } catch (error) {
        console.error('Discord notification failed:', error);
      }
    }
    
    // Send to Slack
    if (this.notificationSettings.slackWebhook) {
      try {
        await fetch(this.notificationSettings.slackWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: notification.title,
            attachments: [{
              color: notification.color,
              text: notification.message,
              footer: 'Hashmancer',
              ts: Math.floor(new Date(notification.timestamp).getTime() / 1000)
            }]
          })
        });
      } catch (error) {
        console.error('Slack notification failed:', error);
      }
    }
    
    // Browser notification
    if (Notification.permission === 'granted') {
      new Notification(notification.title, {
        body: notification.message,
        icon: '/favicon.ico'
      });
    }
  }

  getNotificationColor(eventType) {
    const colors = {
      test: 0x00FF00,      // Green
      jobComplete: 0x00FF00, // Green
      hashCracked: 0xFFD700, // Gold
      taskFailed: 0xFF0000,  // Red
      agentOffline: 0xFFA500 // Orange
    };
    return colors[eventType] || 0x00FF00;
  }

  // Template System Methods (Supertasks)
  loadTemplates() {
    const stored = localStorage.getItem('task-templates');
    if (stored) {
      this.templates = JSON.parse(stored);
    }
    this.refreshTemplateList();
  }

  saveCurrentPipelineAsTemplate() {
    const name = document.getElementById('template-name').value;
    const description = document.getElementById('template-description').value;
    
    if (!name.trim()) {
      this.showToast('Please enter a template name', 'error');
      return;
    }
    
    const template = {
      id: `template_${Date.now()}`,
      name: name.trim(),
      description: description.trim(),
      pipeline: JSON.parse(JSON.stringify(this.jobSettings.taskPipeline)),
      settings: {
        executionStrategy: this.jobSettings.executionStrategy,
        chunkSize: this.jobSettings.chunkSize,
        benchmarkType: this.jobSettings.benchmarkType,
        maxAgents: this.jobSettings.maxAgents,
        optimizedKernel: this.jobSettings.optimizedKernel,
        smallTasks: this.jobSettings.smallTasks
      },
      created: new Date().toISOString(),
      taskCount: this.jobSettings.taskPipeline.length
    };
    
    this.templates.push(template);
    localStorage.setItem('task-templates', JSON.stringify(this.templates));
    
    // Clear form
    document.getElementById('template-name').value = '';
    document.getElementById('template-description').value = '';
    
    this.refreshTemplateList();
    this.showToast(`Template "${name}" saved successfully`, 'success');
  }

  loadTemplate() {
    if (this.templates.length === 0) {
      this.showToast('No templates available', 'info');
      return;
    }
    
    const templateNames = this.templates.map((t, i) => `${i + 1}. ${t.name} (${t.taskCount} tasks)`).join('\\n');
    const choice = prompt(`Choose a template to load (1-${this.templates.length}):\\n\\n${templateNames}`);
    
    if (choice === null) return;
    
    const index = parseInt(choice) - 1;
    if (isNaN(index) || index < 0 || index >= this.templates.length) {
      this.showToast('Invalid selection', 'error');
      return;
    }
    
    const template = this.templates[index];
    
    // Confirm replacement
    if (!confirm(`Load template "${template.name}"? This will replace your current pipeline.`)) {
      return;
    }
    
    // Load template
    this.jobSettings.taskPipeline = JSON.parse(JSON.stringify(template.pipeline));
    this.jobSettings.executionStrategy = template.settings.executionStrategy;
    this.jobSettings.chunkSize = template.settings.chunkSize;
    this.jobSettings.benchmarkType = template.settings.benchmarkType;
    this.jobSettings.maxAgents = template.settings.maxAgents;
    this.jobSettings.optimizedKernel = template.settings.optimizedKernel;
    this.jobSettings.smallTasks = template.settings.smallTasks;
    
    // Update UI
    this.renderTaskPipeline();
    this.loadJobSettings(); // Refresh all settings in UI
    this.saveJobSettings();
    
    this.showToast(`Template "${template.name}" loaded successfully`, 'success');
  }

  refreshTemplateList() {
    const container = document.getElementById('template-list');
    if (!container) return;
    
    if (this.templates.length === 0) {
      container.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No templates saved</div>';
      return;
    }
    
    container.innerHTML = this.templates.map((template, index) => `
      <div style="background: #2a2a2a; border: 1px solid #444; border-radius: 4px; padding: 10px; margin-bottom: 8px;">
        <div style="display: flex; justify-content: space-between; align-items: start;">
          <div style="flex: 1;">
            <div style="font-weight: 600; color: var(--text-color);">${this.sanitizeHTML(template.name)}</div>
            <div style="font-size: 0.8em; color: #888; margin-top: 2px;">
              ${template.taskCount} tasks • Created ${new Date(template.created).toLocaleDateString()}
            </div>
            ${template.description ? `<div style="font-size: 0.8em; color: #aaa; margin-top: 4px;">${this.sanitizeHTML(template.description)}</div>` : ''}
          </div>
          <div style="display: flex; gap: 5px;">
            <button onclick="app.loadSpecificTemplate(${index})" style="background: #444; border: none; color: #fff; padding: 4px 8px; border-radius: 3px; cursor: pointer;">📂</button>
            <button onclick="app.deleteTemplate(${index})" style="background: #444; border: none; color: #fff; padding: 4px 8px; border-radius: 3px; cursor: pointer;">🗑️</button>
          </div>
        </div>
      </div>
    `).join('');
  }

  loadSpecificTemplate(index) {
    const template = this.templates[index];
    if (!template) return;
    
    if (!confirm(`Load template "${template.name}"? This will replace your current pipeline.`)) {
      return;
    }
    
    // Load template
    this.jobSettings.taskPipeline = JSON.parse(JSON.stringify(template.pipeline));
    Object.assign(this.jobSettings, template.settings);
    
    // Update UI
    this.renderTaskPipeline();
    this.loadJobSettings();
    this.saveJobSettings();
    
    this.showToast(`Template "${template.name}" loaded`, 'success');
  }

  deleteTemplate(index) {
    const template = this.templates[index];
    if (!template) return;
    
    if (!confirm(`Delete template "${template.name}"?`)) return;
    
    this.templates.splice(index, 1);
    localStorage.setItem('task-templates', JSON.stringify(this.templates));
    this.refreshTemplateList();
    this.showToast(`Template "${template.name}" deleted`, 'info');
  }
}

// ============================================================================
// GLOBAL FUNCTIONS AND EVENT HANDLERS
// ============================================================================

let app;

function switchTab(tabName) {
  app.switchTab(tabName);
  
  // Initialize benchmark tab when switched to
  if (tabName === 'benchmarks') {
    setTimeout(() => {
      initializeBenchmarkTab();
    }, 100);
  }
}

function toggleAutoRefresh() {
  app.toggleAutoRefresh();
}

function logout() {
  app.logout();
}

function submitPasskey() {
  app.submitPasskey();
}

function handleLoginKeypress(event) {
  app.handleLoginKeypress(event);
}

function refreshWallOfSheep() {
  app.refreshWallOfSheep();
}

function createMask() {
  return app.createMask();
}

function uploadHashes() {
  return app.uploadHashes();
}

function submitHash() {
  return app.submitHash();
}

function loadLogs() {
  return app.loadLogs();
}

function clearLogs() {
  return app.clearLogs();
}

function downloadLogs() {
  return app.downloadLogs();
}

function trainMarkov() {
  return app.trainMarkov();
}

function changeMarkovLang() {
  return app.changeMarkovLang();
}


function trainLLM() {
  return app.trainLLM();
}

function saveAlgoParams() {
  return app.saveAlgoParams();
}

function saveBroadcastConfig() {
  return app.saveBroadcastConfig();
}

function saveServerConfig() {
  return app.saveServerConfig();
}

// 3rd Party Service Functions
function toggleService(serviceName) {
  return app.toggleService(serviceName);
}

function saveServicesConfig() {
  return app.saveServicesConfig();
}

// Enhanced Vast.ai Functions
function saveVastaiConfig() {
  console.log('saveVastaiConfig called');
  
  const apiKey = document.getElementById('vastai-api-key').value;
  const budget = document.getElementById('vastai-budget').value;
  const autoDestroy = document.getElementById('vastai-auto-destroy').checked;
  
  console.log('API Key:', apiKey ? 'provided' : 'empty');
  console.log('Budget:', budget);
  console.log('Auto Destroy:', autoDestroy);
  
  if (!apiKey) {
    showToast('Please enter your Vast.ai API key', 'error');
    return;
  }
  
  const config = {
    apiKey: apiKey,
    budget: parseFloat(budget),
    autoDestroy: autoDestroy
  };
  
  console.log('Saving config:', config);
  
  try {
    localStorage.setItem('vastai-config', JSON.stringify(config));
    console.log('Config saved to localStorage');
    
    // Verify it was saved
    const saved = localStorage.getItem('vastai-config');
    console.log('Verification - saved config:', saved);
    
    showToast('Vast.ai configuration saved successfully', 'success');
    
    // Refresh instances to show the updated state
    refreshVastaiInstances();
    
    // Test connection after saving
    testVastaiConnection();
  } catch (error) {
    console.error('Error saving config:', error);
    showToast('Failed to save configuration: ' + error.message, 'error');
  }
}

function testVastaiConnection() {
  const apiKey = document.getElementById('vastai-api-key').value;
  if (!apiKey) {
    showToast('Please enter your API key first', 'error');
    return;
  }
  
  showToast('Testing Vast.ai connection...', 'info');
  
  // Mock API test - in real implementation, this would call the Vast.ai API
  setTimeout(() => {
    const isValid = Math.random() > 0.3; // 70% success rate for demo
    if (isValid) {
      showToast('Connection successful! API key is valid', 'success');
      loadVastaiAccountInfo();
    } else {
      showToast('Connection failed. Please check your API key', 'error');
    }
  }, 2000);
}

function loadVastaiAccountInfo() {
  // Mock account data - in real implementation, fetch from Vast.ai API
  const mockData = {
    balance: (Math.random() * 100).toFixed(2),
    activeInstances: Math.floor(Math.random() * 5),
    monthlySpend: (Math.random() * 50).toFixed(2),
    totalHours: Math.floor(Math.random() * 1000)
  };
  
  document.getElementById('vastai-balance').textContent = `$${mockData.balance}`;
  document.getElementById('vastai-active-instances').textContent = mockData.activeInstances;
  document.getElementById('vastai-monthly-spend').textContent = `$${mockData.monthlySpend}`;
  document.getElementById('vastai-total-hours').textContent = `${mockData.totalHours}h`;
}

function refreshVastaiDashboard() {
  showToast('Refreshing Vast.ai dashboard...', 'info');
  loadVastaiAccountInfo();
  refreshVastaiInstances();
  refreshAvailableInstances();
}

function refreshVastaiInstances() {
  // Delegate to the app method which has the proper logic
  if (window.app) {
    window.app.refreshVastaiInstances();
  }
}

function generateMockInstances() {
  // Return empty array - no mock instances, only show real instances from API
  return [];
}

function displayActiveInstances(instances) {
  const container = document.getElementById('vastai-instances');
  
  if (instances.length === 0) {
    container.innerHTML = `
      <div class="no-instances">
        <div class="no-instances-icon">🖥️</div>
        <p>No active instances</p>
        <small>Launch an instance to get started</small>
      </div>
    `;
    return;
  }
  
  const instancesHtml = instances.map(instance => `
    <div class="instance-card" data-id="${instance.id}">
      <div class="instance-header">
        <div class="instance-info">
          <h5>${instance.name}</h5>
          <p>ID: ${instance.id} • ${instance.location}</p>
        </div>
        <div class="instance-status status-${instance.status}">
          <span class="status-indicator status-${instance.status}"></span>
          ${instance.status.charAt(0).toUpperCase() + instance.status.slice(1)}
        </div>
      </div>
      <div class="instance-specs">
        <div class="spec-item">
          <span class="spec-value">${instance.gpu}</span>
          <div class="spec-label">GPU</div>
        </div>
        <div class="spec-item">
          <span class="spec-value">${instance.ram}GB</span>
          <div class="spec-label">RAM</div>
        </div>
        <div class="spec-item">
          <span class="spec-value">${instance.storage}GB</span>
          <div class="spec-label">Storage</div>
        </div>
        <div class="spec-item">
          <span class="spec-value">$${instance.price}/hr</span>
          <div class="spec-label">Price</div>
        </div>
        <div class="spec-item">
          <span class="spec-value">${instance.uptime}</span>
          <div class="spec-label">Uptime</div>
        </div>
        <div class="spec-item">
          <span class="spec-value">${instance.dlPerf}</span>
          <div class="spec-label">DL Perf</div>
        </div>
      </div>
      <div class="instance-actions">
        <button onclick="viewInstanceDetails('${instance.id}')" class="info">📊 Details</button>
        <button onclick="connectToInstance('${instance.id}')" class="success">🔗 Connect</button>
        ${instance.status === 'running' ? 
          '<button onclick="stopInstance(\''+instance.id+'\')" class="warning">⏸️ Stop</button>' :
          '<button onclick="startInstance(\''+instance.id+'\')" class="success">▶️ Start</button>'
        }
        <button onclick="destroyInstance('${instance.id}')" class="danger">🗑️ Destroy</button>
      </div>
    </div>
  `).join('');
  
  container.innerHTML = instancesHtml;
}

function updateInstanceSearch() {
  const gpu = document.getElementById('vastai-search-gpu').value;
  const maxPrice = document.getElementById('vastai-search-max-price').value;
  const ram = document.getElementById('vastai-search-ram').value;
  const storage = document.getElementById('vastai-search-storage').value;
  const location = document.getElementById('vastai-search-location').value;
  
  console.log('Search criteria updated:', { gpu, maxPrice, ram, storage, location });
  // In real implementation, this would trigger a new search
}

function searchAvailableInstances() {
  showToast('Searching for available instances...', 'info');
  
  const container = document.getElementById('vastai-available-instances');
  container.innerHTML = '<div class="loading-placeholder"><div class="spinner"></div><p>Searching available instances...</p></div>';
  
  setTimeout(() => {
    const mockAvailable = generateMockAvailableInstances();
    displayAvailableInstances(mockAvailable);
  }, 2000);
}

function generateMockAvailableInstances() {
  const instances = [];
  const gpuTypes = ['RTX 4090', 'RTX 4080', 'RTX 3090', 'RTX 3080', 'A100', 'H100'];
  const locations = ['US-East', 'US-West', 'EU-Central', 'Asia-Pacific'];
  
  for (let i = 0; i < Math.floor(Math.random() * 10) + 5; i++) {
    instances.push({
      id: `available_${Math.floor(Math.random() * 10000)}`,
      gpu: gpuTypes[Math.floor(Math.random() * gpuTypes.length)],
      price: (Math.random() * 4 + 0.3).toFixed(2),
      location: locations[Math.floor(Math.random() * locations.length)],
      ram: [16, 32, 64, 128][Math.floor(Math.random() * 4)],
      storage: [100, 250, 500, 1000][Math.floor(Math.random() * 4)],
      dlPerf: (Math.random() * 100 + 30).toFixed(1),
      reliability: (Math.random() * 100 + 70).toFixed(1),
      verified: Math.random() > 0.3
    });
  }
  
  return instances.sort((a, b) => parseFloat(a.price) - parseFloat(b.price));
}

function displayAvailableInstances(instances) {
  const container = document.getElementById('vastai-available-instances');
  
  if (instances.length === 0) {
    container.innerHTML = `
      <div class="no-instances">
        <div class="no-instances-icon">🔍</div>
        <p>No instances found</p>
        <small>Try adjusting your search criteria</small>
      </div>
    `;
    return;
  }
  
  const instancesHtml = instances.map(instance => `
    <div class="instance-card" data-id="${instance.id}">
      <div class="instance-header">
        <div class="instance-info">
          <h5>${instance.gpu} - ${instance.location}</h5>
          <p>ID: ${instance.id} ${instance.verified ? '✅ Verified' : ''}</p>
        </div>
        <div class="instance-status status-available">
          <span class="status-indicator status-available"></span>
          Available
        </div>
      </div>
      <div class="instance-specs">
        <div class="spec-item">
          <span class="spec-value">${instance.gpu}</span>
          <div class="spec-label">GPU</div>
        </div>
        <div class="spec-item">
          <span class="spec-value">${instance.ram}GB</span>
          <div class="spec-label">RAM</div>
        </div>
        <div class="spec-item">
          <span class="spec-value">${instance.storage}GB</span>
          <div class="spec-label">Storage</div>
        </div>
        <div class="spec-item">
          <span class="spec-value">$${instance.price}/hr</span>
          <div class="spec-label">Price</div>
        </div>
        <div class="spec-item">
          <span class="spec-value">${instance.dlPerf}</span>
          <div class="spec-label">DL Perf</div>
        </div>
        <div class="spec-item">
          <span class="spec-value">${instance.reliability}%</span>
          <div class="spec-label">Reliability</div>
        </div>
      </div>
      <div class="instance-actions">
        <button onclick="viewAvailableInstanceDetails('${instance.id}')" class="info">📋 Details</button>
        <button onclick="launchSpecificInstance('${instance.id}')" class="success">🚀 Launch</button>
      </div>
    </div>
  `).join('');
  
  container.innerHTML = instancesHtml;
}

function launchTemplate(templateType) {
  const templates = {
    budget: { gpu: 'RTX 3080', price: '0.50', ram: 32, storage: 100 },
    balanced: { gpu: 'RTX 4080', price: '1.20', ram: 32, storage: 250 },
    performance: { gpu: 'RTX 4090', price: '2.50', ram: 64, storage: 500 },
    enterprise: { gpu: 'A100', price: '4.00', ram: 128, storage: 1000 }
  };
  
  const template = templates[templateType];
  if (!template) return;
  
  showToast(`Launching ${templateType} template (${template.gpu})...`, 'info');
  
  // In real implementation, this would call the Vast.ai API
  setTimeout(() => {
    showToast(`${templateType} instance launched successfully!`, 'success');
    refreshVastaiInstances();
  }, 3000);
}

function launchSpecificInstance(instanceId) {
  showToast(`Launching instance ${instanceId}...`, 'info');
  
  setTimeout(() => {
    showToast('Instance launched successfully!', 'success');
    refreshVastaiInstances();
    refreshAvailableInstances();
  }, 2000);
}

function viewInstanceDetails(instanceId) {
  // Mock instance details
  const details = `
    <div style="line-height: 1.6;">
      <h4>Instance ${instanceId}</h4>
      <p><strong>Status:</strong> Running</p>
      <p><strong>GPU:</strong> RTX 4090</p>
      <p><strong>Location:</strong> US-East</p>
      <p><strong>SSH:</strong> ssh root@instance.vast.ai -p 12345</p>
      <p><strong>Jupyter:</strong> https://instance.vast.ai:8888</p>
      <p><strong>Uptime:</strong> 2h 45m</p>
      <p><strong>Cost:</strong> $6.75 total</p>
      <hr style="margin: 16px 0; border: 1px solid var(--border-color);">
      <h5>Resource Usage:</h5>
      <p>GPU Util: 85%</p>
      <p>Memory: 18GB / 24GB</p>
      <p>CPU: 45%</p>
      <p>Network: 125 Mbps</p>
    </div>
  `;
  
  document.getElementById('modal-instance-title').textContent = `Instance Details`;
  document.getElementById('modal-instance-body').innerHTML = details;
  document.getElementById('instance-modal').style.display = 'flex';
}

function viewAvailableInstanceDetails(instanceId) {
  const details = `
    <div style="line-height: 1.6;">
      <h4>Available Instance ${instanceId}</h4>
      <p><strong>GPU:</strong> RTX 4090</p>
      <p><strong>Location:</strong> US-West</p>
      <p><strong>Price:</strong> $2.30/hour</p>
      <p><strong>DL Performance:</strong> 95.2</p>
      <p><strong>Reliability:</strong> 98.5%</p>
      <p><strong>Host Rating:</strong> ⭐⭐⭐⭐⭐ (4.9/5)</p>
      <hr style="margin: 16px 0; border: 1px solid var(--border-color);">
      <h5>Specifications:</h5>
      <p>GPU Memory: 24GB GDDR6X</p>
      <p>System RAM: 64GB DDR4</p>
      <p>Storage: 1TB NVMe SSD</p>
      <p>Network: 10 Gbps</p>
      <p>CUDA Version: 11.8</p>
    </div>
  `;
  
  document.getElementById('modal-instance-title').textContent = `Available Instance`;
  document.getElementById('modal-instance-body').innerHTML = details;
  document.getElementById('instance-modal').style.display = 'flex';
}

function closeInstanceModal() {
  document.getElementById('instance-modal').style.display = 'none';
}

function connectToInstance(instanceId) {
  showToast(`Connecting to instance ${instanceId}...`, 'info');
  // In real implementation, this would establish SSH or other connection
}

function startInstance(instanceId) {
  showToast(`Starting instance ${instanceId}...`, 'info');
  setTimeout(() => {
    showToast('Instance started successfully!', 'success');
    refreshVastaiInstances();
  }, 2000);
}

function stopInstance(instanceId) {
  showToast(`Stopping instance ${instanceId}...`, 'warning');
  setTimeout(() => {
    showToast('Instance stopped successfully!', 'success');
    refreshVastaiInstances();
  }, 2000);
}

function destroyInstance(instanceId) {
  if (!confirm('Are you sure you want to destroy this instance? This action cannot be undone.')) {
    return;
  }
  
  showToast(`Destroying instance ${instanceId}...`, 'warning');
  setTimeout(() => {
    showToast('Instance destroyed successfully!', 'success');
    refreshVastaiInstances();
  }, 2000);
}

function filterInstances() {
  const filter = document.getElementById('instance-filter').value.toLowerCase();
  const statusFilter = document.getElementById('instance-status-filter').value;
  
  const cards = document.querySelectorAll('#vastai-instances .instance-card');
  cards.forEach(card => {
    const text = card.textContent.toLowerCase();
    const status = card.querySelector('.instance-status').textContent.toLowerCase().trim();
    
    const matchesText = !filter || text.includes(filter);
    const matchesStatus = !statusFilter || status.includes(statusFilter);
    
    card.style.display = matchesText && matchesStatus ? 'block' : 'none';
  });
}

function sortAvailableInstances() {
  const sortBy = document.getElementById('vastai-sort').value;
  // In real implementation, this would re-sort and re-display the instances
  showToast(`Sorting by ${sortBy}...`, 'info');
}

function toggleViewMode() {
  const btn = document.getElementById('view-mode-btn');
  if (btn.textContent.includes('List')) {
    btn.innerHTML = '🎛️ Card View';
    // Switch to list view
  } else {
    btn.innerHTML = '📋 List View';
    // Switch to card view
  }
}

function refreshAvailableInstances() {
  searchAvailableInstances();
}

function openVastaiDocs() {
  window.open('https://vast.ai/docs/', '_blank');
}

function showBillingHistory() {
  showToast('Opening billing history...', 'info');
  // In real implementation, this would show billing details
}

// Backwards compatibility with old functions
function launchVastaiInstance() {
  launchTemplate('balanced');
}

// Benchmarking System Functions
let currentBenchmark = null;
let benchmarkResults = [];
let benchmarkHistory = JSON.parse(localStorage.getItem('benchmark_history') || '[]');

function initializeBenchmarkTab() {
  loadBenchmarkStats();
  loadAvailableWorkers();
  loadBenchmarkHistory();
  updateBenchmarkResults();
  loadGPUAnalysis();
}

function loadBenchmarkStats() {
  // Load benchmark statistics from localStorage
  const stats = {
    totalBenchmarks: benchmarkHistory.length,
    activeWorkers: Math.floor(Math.random() * 5) + 1, // Mock data
    bestHashcatSpeed: getBestSpeed('hashcat'),
    bestDarklingSpeed: getBestSpeed('darkling')
  };
  
  document.getElementById('total-benchmarks').textContent = stats.totalBenchmarks;
  document.getElementById('active-workers-bench').textContent = stats.activeWorkers;
  document.getElementById('best-hashcat-speed').textContent = stats.bestHashcatSpeed;
  document.getElementById('best-darkling-speed').textContent = stats.bestDarklingSpeed;
}

function getBestSpeed(application) {
  const appResults = benchmarkHistory.filter(b => b.application === application);
  if (appResults.length === 0) return '0 H/s';
  
  const maxSpeed = Math.max(...appResults.map(b => b.speed));
  return formatSpeed(maxSpeed);
}

function formatSpeed(speed) {
  if (speed >= 1e9) return (speed / 1e9).toFixed(1) + ' GH/s';
  if (speed >= 1e6) return (speed / 1e6).toFixed(1) + ' MH/s';
  if (speed >= 1e3) return (speed / 1e3).toFixed(1) + ' KH/s';
  return speed.toFixed(0) + ' H/s';
}

function loadAvailableWorkers() {
  const workerList = document.getElementById('worker-list');
  const mockWorkers = [
    { id: 'worker-001', name: 'Mining Rig Alpha', gpu: 'RTX 4090' },
    { id: 'worker-002', name: 'Compute Node Beta', gpu: 'RTX 4080' },
    { id: 'worker-003', name: 'Hash Station Gamma', gpu: 'RTX 3090' },
    { id: 'worker-004', name: 'Cracking Unit Delta', gpu: 'A100' }
  ];
  
  workerList.innerHTML = mockWorkers.map(worker => `
    <label>
      <input type="checkbox" value="${worker.id}" checked>
      ${worker.name} (${worker.gpu})
    </label>
  `).join('');
}

function toggleAllWorkers() {
  const selectAll = document.getElementById('select-all-workers').checked;
  const workerCheckboxes = document.querySelectorAll('#worker-list input[type="checkbox"]');
  
  workerCheckboxes.forEach(checkbox => {
    checkbox.checked = selectAll;
  });
}

function runQuickBenchmark() {
  const config = {
    workers: ['worker-001'],
    applications: ['hashcat', 'darkling'],
    hashTypes: ['0', '1400'],
    duration: 30,
    attackMode: '3'
  };
  
  startBenchmark(config, 'Quick Benchmark');
}

function runFullBenchmark() {
  const selectedWorkers = getSelectedWorkers();
  if (selectedWorkers.length === 0) {
    showToast('Please select at least one worker', 'error');
    return;
  }
  
  const config = {
    workers: selectedWorkers,
    applications: ['hashcat', 'darkling'],
    hashTypes: ['0', '100', '1400', '1700', '22000', '1000'],
    duration: 300,
    attackMode: '3'
  };
  
  startBenchmark(config, 'Full Benchmark Suite');
}

function startCustomBenchmark() {
  const selectedWorkers = getSelectedWorkers();
  if (selectedWorkers.length === 0) {
    showToast('Please select at least one worker', 'error');
    return;
  }
  
  const applications = [];
  if (document.getElementById('test-hashcat').checked) applications.push('hashcat');
  if (document.getElementById('test-darkling').checked) applications.push('darkling');
  
  if (applications.length === 0) {
    showToast('Please select at least one application to test', 'error');
    return;
  }
  
  const hashType = document.getElementById('benchmark-hash-type').value;
  const hashTypes = hashType === 'all' ? ['0', '100', '1400', '1700'] : [hashType];
  
  const config = {
    workers: selectedWorkers,
    applications: applications,
    hashTypes: hashTypes,
    duration: parseInt(document.getElementById('benchmark-duration').value),
    attackMode: document.getElementById('benchmark-attack-mode').value,
    saveLog: document.getElementById('save-benchmark-log').checked
  };
  
  startBenchmark(config, 'Custom Benchmark');
}

function getSelectedWorkers() {
  const checkboxes = document.querySelectorAll('#worker-list input[type="checkbox"]:checked');
  return Array.from(checkboxes).map(cb => cb.value);
}

function startBenchmark(config, name) {
  if (currentBenchmark) {
    showToast('A benchmark is already running', 'warning');
    return;
  }
  
  currentBenchmark = {
    name: name,
    config: config,
    startTime: new Date(),
    progress: 0,
    currentTest: null,
    results: []
  };
  
  showToast(`Starting ${name}...`, 'info');
  
  // Show progress section
  document.getElementById('benchmark-progress-section').style.display = 'block';
  
  // Start the benchmark simulation
  simulateBenchmark();
}

function simulateBenchmark() {
  if (!currentBenchmark) return;
  
  const config = currentBenchmark.config;
  const totalTests = config.workers.length * config.applications.length * config.hashTypes.length;
  let completedTests = 0;
  
  function runNextTest() {
    if (completedTests >= totalTests) {
      completeBenchmark();
      return;
    }
    
    const workerIndex = Math.floor(completedTests / (config.applications.length * config.hashTypes.length));
    const appIndex = Math.floor((completedTests % (config.applications.length * config.hashTypes.length)) / config.hashTypes.length);
    const hashIndex = completedTests % config.hashTypes.length;
    
    const worker = config.workers[workerIndex];
    const application = config.applications[appIndex];
    const hashType = config.hashTypes[hashIndex];
    
    currentBenchmark.currentTest = {
      worker: worker,
      application: application,
      hashType: hashType
    };
    
    // Update UI
    document.getElementById('current-test-name').textContent = `${application} - Hash Type ${hashType}`;
    document.getElementById('current-worker').textContent = worker;
    document.getElementById('current-app').textContent = application;
    
    // Simulate test running
    const testDuration = Math.min(config.duration * 1000, 10000); // Max 10 seconds for demo
    const updateInterval = 100;
    let elapsed = 0;
    
    const testInterval = setInterval(() => {
      elapsed += updateInterval;
      const testProgress = Math.min(elapsed / testDuration, 1);
      const overallProgress = (completedTests + testProgress) / totalTests;
      
      // Generate mock speed
      const baseSpeed = getBaseSpeed(application, hashType);
      const variation = 0.8 + Math.random() * 0.4; // ±20% variation
      const currentSpeed = Math.floor(baseSpeed * variation);
      
      document.getElementById('current-speed').textContent = formatSpeed(currentSpeed);
      updateBenchmarkProgress(overallProgress * 100);
      
      if (testProgress >= 1) {
        clearInterval(testInterval);
        
        // Save test result
        const result = {
          timestamp: new Date(),
          worker: worker,
          application: application,
          hashType: hashType,
          speed: currentSpeed,
          duration: config.duration
        };
        
        currentBenchmark.results.push(result);
        completedTests++;
        
        setTimeout(runNextTest, 500); // Brief pause between tests
      }
    }, updateInterval);
  }
  
  runNextTest();
}

function getBaseSpeed(application, hashType) {
  const speedMultipliers = {
    'hashcat': {
      '0': 50000000000,    // MD5 - 50 GH/s
      '100': 25000000000,  // SHA1 - 25 GH/s
      '1400': 12000000000, // SHA256 - 12 GH/s
      '1700': 4000000000,  // SHA512 - 4 GH/s
      '22000': 1000000,    // WPA2 - 1 MH/s
      '1000': 45000000000  // NTLM - 45 GH/s
    },
    'darkling': {
      '0': 55000000000,    // MD5 - 55 GH/s (10% faster)
      '100': 28000000000,  // SHA1 - 28 GH/s (12% faster)
      '1400': 14000000000, // SHA256 - 14 GH/s (17% faster)
      '1700': 4500000000,  // SHA512 - 4.5 GH/s (12% faster)
      '22000': 1200000,    // WPA2 - 1.2 MH/s (20% faster)
      '1000': 50000000000  // NTLM - 50 GH/s (11% faster)
    }
  };
  
  return speedMultipliers[application]?.[hashType] || 1000000;
}

function updateBenchmarkProgress(percentage) {
  const progressBar = document.getElementById('benchmark-progress-bar');
  const progressText = document.getElementById('benchmark-progress-text');
  
  progressBar.style.width = percentage + '%';
  progressText.textContent = Math.round(percentage) + '% Complete';
}

function completeBenchmark() {
  if (!currentBenchmark) return;
  
  // Save to history
  const benchmarkRecord = {
    id: Date.now(),
    name: currentBenchmark.name,
    timestamp: currentBenchmark.startTime,
    duration: (new Date() - currentBenchmark.startTime) / 1000,
    config: currentBenchmark.config,
    results: currentBenchmark.results
  };
  
  benchmarkHistory.unshift(benchmarkRecord);
  
  // Keep only last 100 benchmarks
  if (benchmarkHistory.length > 100) {
    benchmarkHistory = benchmarkHistory.slice(0, 100);
  }
  
  // Save to localStorage
  localStorage.setItem('benchmark_history', JSON.stringify(benchmarkHistory));
  
  // Add results to current session
  benchmarkResults = benchmarkResults.concat(currentBenchmark.results);
  
  showToast(`Benchmark completed! Tested ${currentBenchmark.results.length} configurations`, 'success');
  
  // Hide progress section
  document.getElementById('benchmark-progress-section').style.display = 'none';
  
  // Update UI
  loadBenchmarkStats();
  loadBenchmarkHistory();
  updateBenchmarkResults();
  loadGPUAnalysis();
  
  currentBenchmark = null;
}

function cancelBenchmark() {
  if (!currentBenchmark) return;
  
  currentBenchmark = null;
  document.getElementById('benchmark-progress-section').style.display = 'none';
  showToast('Benchmark cancelled', 'warning');
}

function loadBenchmarkHistory() {
  const container = document.getElementById('recent-benchmarks');
  
  if (benchmarkHistory.length === 0) {
    container.innerHTML = `
      <div class="no-benchmarks">
        <p>No recent benchmarks</p>
        <small>Run a benchmark to see results here</small>
      </div>
    `;
    return;
  }
  
  const recentBenchmarks = benchmarkHistory.slice(0, 5);
  
  container.innerHTML = recentBenchmarks.map(benchmark => {
    const avgSpeed = benchmark.results.reduce((sum, r) => sum + r.speed, 0) / benchmark.results.length;
    return `
      <div class="benchmark-history-item" onclick="viewBenchmarkDetails('${benchmark.id}')">
        <div class="history-item-header">
          <div class="history-item-title">${benchmark.name}</div>
          <div class="history-item-date">${new Date(benchmark.timestamp).toLocaleDateString()}</div>
        </div>
        <div class="history-item-details">
          ${benchmark.results.length} tests • Avg: ${formatSpeed(avgSpeed)}
        </div>
      </div>
    `;
  }).join('');
}

function updateBenchmarkResults() {
  const tbody = document.getElementById('benchmark-results-body');
  
  if (benchmarkResults.length === 0) {
    tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; opacity: 0.7;">No benchmark results yet</td></tr>';
    return;
  }
  
  const sortedResults = [...benchmarkResults].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  
  tbody.innerHTML = sortedResults.map(result => {
    const improvement = calculateImprovement(result);
    const improvementClass = improvement > 0 ? 'improvement-positive' : improvement < 0 ? 'improvement-negative' : 'improvement-neutral';
    const improvementText = improvement !== 0 ? (improvement > 0 ? '+' : '') + improvement.toFixed(1) + '%' : 'Baseline';
    
    return `
      <tr>
        <td>${new Date(result.timestamp).toLocaleDateString()}</td>
        <td>${result.worker}</td>
        <td>RTX 4090</td>
        <td>${result.application}</td>
        <td>${getHashTypeName(result.hashType)}</td>
        <td>${formatSpeed(result.speed)}</td>
        <td><span class="gpu-improvement ${improvementClass}">${improvementText}</span></td>
        <td>
          <button onclick="viewResultDetails('${result.timestamp}')" class="info" style="padding: 4px 8px; font-size: 0.8rem;">Details</button>
        </td>
      </tr>
    `;
  }).join('');
}

function calculateImprovement(result) {
  // Find previous result for same worker/app/hashtype combination
  const previousResults = benchmarkResults.filter(r => 
    r.worker === result.worker && 
    r.application === result.application && 
    r.hashType === result.hashType &&
    new Date(r.timestamp) < new Date(result.timestamp)
  );
  
  if (previousResults.length === 0) return 0;
  
  const latestPrevious = previousResults.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];
  return ((result.speed - latestPrevious.speed) / latestPrevious.speed) * 100;
}

function getHashTypeName(hashType) {
  const names = {
    '0': 'MD5',
    '100': 'SHA1',
    '1400': 'SHA256',
    '1700': 'SHA512',
    '22000': 'WPA2',
    '1000': 'NTLM'
  };
  return names[hashType] || hashType;
}

function loadGPUAnalysis() {
  const container = document.getElementById('gpu-analysis');
  
  if (benchmarkResults.length === 0) {
    container.innerHTML = `
      <div class="analysis-placeholder">
        <div class="analysis-icon">🖥️</div>
        <p>GPU analysis will appear after benchmarks</p>
      </div>
    `;
    return;
  }
  
  // Group results by GPU
  const gpuGroups = {};
  benchmarkResults.forEach(result => {
    const gpu = 'RTX 4090'; // Mock GPU data
    if (!gpuGroups[gpu]) gpuGroups[gpu] = { hashcat: [], darkling: [] };
    gpuGroups[gpu][result.application].push(result);
  });
  
  container.innerHTML = Object.entries(gpuGroups).map(([gpu, data]) => {
    const hashcatAvg = data.hashcat.reduce((sum, r) => sum + r.speed, 0) / data.hashcat.length || 0;
    const darklingAvg = data.darkling.reduce((sum, r) => sum + r.speed, 0) / data.darkling.length || 0;
    const improvement = hashcatAvg > 0 ? ((darklingAvg - hashcatAvg) / hashcatAvg) * 100 : 0;
    
    return `
      <div class="gpu-comparison-card">
        <div class="gpu-comparison-header">
          <div class="gpu-name">${gpu}</div>
          <div class="gpu-improvement ${improvement > 0 ? 'improvement-positive' : improvement < 0 ? 'improvement-negative' : 'improvement-neutral'}">
            ${improvement > 0 ? '+' : ''}${improvement.toFixed(1)}% Darkling vs Hashcat
          </div>
        </div>
        <div class="gpu-speeds">
          <div class="speed-comparison">
            <div class="speed-label">Hashcat Average</div>
            <div class="speed-value">${formatSpeed(hashcatAvg)}</div>
          </div>
          <div class="speed-comparison">
            <div class="speed-label">Darkling Average</div>
            <div class="speed-value">${formatSpeed(darklingAvg)}</div>
          </div>
        </div>
      </div>
    `;
  }).join('');
}

function runHashcatOnly() {
  const config = {
    workers: getSelectedWorkers().slice(0, 1),
    applications: ['hashcat'],
    hashTypes: ['0', '1400'],
    duration: 60,
    attackMode: '3'
  };
  startBenchmark(config, 'Hashcat Performance Test');
}

function runDarklingOnly() {
  const config = {
    workers: getSelectedWorkers().slice(0, 1),
    applications: ['darkling'],
    hashTypes: ['0', '1400'],
    duration: 60,
    attackMode: '3'
  };
  startBenchmark(config, 'Darkling Performance Test');
}

function runComparison() {
  const config = {
    workers: getSelectedWorkers().slice(0, 1),
    applications: ['hashcat', 'darkling'],
    hashTypes: ['0', '1400'],
    duration: 60,
    attackMode: '3'
  };
  startBenchmark(config, 'Head-to-Head Comparison');
}

function runGPUTest() {
  const config = {
    workers: getSelectedWorkers(),
    applications: ['hashcat', 'darkling'],
    hashTypes: ['0'],
    duration: 300,
    attackMode: '3'
  };
  startBenchmark(config, 'GPU Stress Test');
}

function exportBenchmarkData() {
  const data = {
    history: benchmarkHistory,
    results: benchmarkResults,
    exported: new Date().toISOString()
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `hashmancer-benchmarks-${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  showToast('Benchmark data exported successfully', 'success');
}

function viewBenchmarkDetails(benchmarkId) {
  const benchmark = benchmarkHistory.find(b => b.id.toString() === benchmarkId);
  if (!benchmark) return;
  
  const details = `
    <div style="line-height: 1.6;">
      <h4>${benchmark.name}</h4>
      <p><strong>Date:</strong> ${new Date(benchmark.timestamp).toLocaleString()}</p>
      <p><strong>Duration:</strong> ${benchmark.duration.toFixed(1)} seconds</p>
      <p><strong>Workers:</strong> ${benchmark.config.workers.join(', ')}</p>
      <p><strong>Applications:</strong> ${benchmark.config.applications.join(', ')}</p>
      <p><strong>Hash Types:</strong> ${benchmark.config.hashTypes.map(getHashTypeName).join(', ')}</p>
      <hr style="margin: 16px 0; border: 1px solid var(--border-color);">
      <h5>Results Summary:</h5>
      <p>Total Tests: ${benchmark.results.length}</p>
      <p>Average Speed: ${formatSpeed(benchmark.results.reduce((sum, r) => sum + r.speed, 0) / benchmark.results.length)}</p>
      <p>Best Performance: ${formatSpeed(Math.max(...benchmark.results.map(r => r.speed)))}</p>
    </div>
  `;
  
  document.getElementById('modal-benchmark-title').textContent = 'Benchmark Details';
  document.getElementById('modal-benchmark-body').innerHTML = details;
  document.getElementById('benchmark-modal').style.display = 'flex';
}

function closeBenchmarkModal() {
  document.getElementById('benchmark-modal').style.display = 'none';
}

function viewFullHistory() {
  showToast('Opening full benchmark history...', 'info');
  // In real implementation, this would open a detailed history view
}

function filterResults() {
  const searchTerm = document.getElementById('results-search').value.toLowerCase();
  const rows = document.querySelectorAll('#benchmark-results-body tr');
  
  rows.forEach(row => {
    const text = row.textContent.toLowerCase();
    row.style.display = text.includes(searchTerm) ? '' : 'none';
  });
}

function sortResults() {
  const sortBy = document.getElementById('results-sort').value;
  showToast(`Sorting results by ${sortBy}...`, 'info');
  updateBenchmarkResults(); // Re-render with new sort
}

function saveHashescomConfig() {
  return app.saveHashescomConfig();
}

function testHashescomConnection() {
  return app.testHashescomConnection();
}

function saveSaladaiConfig() {
  return app.saveSaladaiConfig();
}

function saveGrokConfig() {
  return app.saveGrokConfig();
}

// Enhanced Hashes.com Functions
function savePaymentFilters() {
  return app.savePaymentFilters();
}

function fetchHashescomJobs() {
  return app.fetchHashescomJobs();
}

function startJobPolling() {
  return app.startJobPolling();
}

function stopJobPolling() {
  return app.stopJobPolling();
}

function clearCompletedJobs() {
  return app.clearCompletedJobs();
}

function resetHashescomStats() {
  return app.resetHashescomStats();
}

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
  app = new HashmancerPortal();
  
  // Load Vast.ai configuration
  const vastaiConfig = localStorage.getItem('vastai-config');
  if (vastaiConfig) {
    const config = JSON.parse(vastaiConfig);
    if (config.apiKey && document.getElementById('vastai-api-key')) {
      document.getElementById('vastai-api-key').value = config.apiKey;
    }
    if (config.budget && document.getElementById('vastai-budget')) {
      document.getElementById('vastai-budget').value = config.budget;
    }
    if (typeof config.autoDestroy !== 'undefined' && document.getElementById('vastai-auto-destroy')) {
      document.getElementById('vastai-auto-destroy').checked = config.autoDestroy;
    }
  }
  
  // Initialize Vast.ai data if tab is visible
  setTimeout(() => {
    if (document.getElementById('vastai-tab') && document.getElementById('vastai-tab').style.display !== 'none') {
      refreshVastaiDashboard();
    }
    
    // Initialize benchmarks tab if visible
    if (document.getElementById('benchmarks-tab') && document.getElementById('benchmarks-tab').style.display !== 'none') {
      initializeBenchmarkTab();
    }
  }, 1000);
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && app?.autoRefresh) {
    app.startRefreshTimer();
  } else if (app) {
    app.stopRefreshTimer();
  }
});

// Handle beforeunload to clean up WebSocket
window.addEventListener('beforeunload', () => {
  if (app?.wsConnection) {
    app.wsConnection.close();
  }
});

</script>

</body>
</html>