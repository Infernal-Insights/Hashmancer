<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hashmancer Control Center</title>
<link href="https://fonts.googleapis.com/css2?family=UnifrakturCook&display=swap" rel="stylesheet">
<style>
:root {
  --primary-color: #0f0;
  --bg-color: #000;
  --secondary-bg: #111;
  --border-color: #0f0;
  --error-color: #f44336;
  --warning-color: #ff8800;
  --success-color: #4caf50;
  --text-color: #0f0;
  --tab-active-bg: #222;
  --wall-sheep-bg: #1a1a1a;
}

* {
  box-sizing: border-box;
}

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background: var(--bg-color);
  color: var(--text-color);
  line-height: 1.4;
  overflow-x: hidden;
}

.header {
  background: var(--secondary-bg);
  border-bottom: 2px solid var(--border-color);
  padding: 10px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  z-index: 1000;
  flex-wrap: wrap;
  gap: 10px;
}

.header h1 {
  color: var(--primary-color);
  font-family: 'UnifrakturCook', cursive;
  margin: 0;
  font-size: 1.8rem;
  text-shadow: 0 0 10px var(--primary-color);
}

.header-controls {
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
}

.connection-status {
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  gap: 5px;
}

.connection-status.connected {
  background: rgba(76, 175, 80, 0.2);
  border: 1px solid var(--success-color);
  color: var(--success-color);
}

.connection-status.disconnected {
  background: rgba(244, 67, 54, 0.2);
  border: 1px solid var(--error-color);
  color: var(--error-color);
}

.spinner {
  display: inline-block;
  width: 12px;
  height: 12px;
  border: 2px solid transparent;
  border-top: 2px solid currentColor;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Tab Navigation */
.tab-nav {
  background: var(--secondary-bg);
  border-bottom: 1px solid var(--border-color);
  padding: 0 20px;
  display: flex;
  overflow-x: auto;
}

.tab-button {
  background: none;
  border: none;
  color: var(--text-color);
  padding: 15px 20px;
  cursor: pointer;
  border-bottom: 3px solid transparent;
  transition: all 0.3s ease;
  font-size: 1rem;
  white-space: nowrap;
  display: flex;
  align-items: center;
  gap: 8px;
}

.tab-button:hover {
  background: rgba(0, 255, 0, 0.1);
  border-bottom-color: rgba(0, 255, 0, 0.5);
}

.tab-button.active {
  background: var(--tab-active-bg);
  border-bottom-color: var(--primary-color);
  color: var(--primary-color);
}

.tab-content {
  display: none;
  padding: 20px;
  min-height: calc(100vh - 140px);
}

.tab-content.active {
  display: block;
}

/* Common Components */
button {
  background: var(--secondary-bg);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-family: inherit;
}

button:hover:not(:disabled) {
  background: var(--primary-color);
  color: var(--bg-color);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

button.danger {
  border-color: var(--error-color);
  color: var(--error-color);
}

button.danger:hover:not(:disabled) {
  background: var(--error-color);
  color: white;
}

button.success {
  border-color: var(--success-color);
  color: var(--success-color);
}

button.success:hover:not(:disabled) {
  background: var(--success-color);
  color: white;
}

input, textarea, select {
  background: var(--secondary-bg);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  padding: 8px;
  border-radius: 4px;
  font-family: inherit;
}

/* Overview Tab */
.overview-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-bottom: 20px;
}

.metrics-section {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 20px;
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 15px;
  margin-top: 15px;
}

.metric-card {
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 15px;
  text-align: center;
}

.metric-value {
  font-size: 2rem;
  font-weight: bold;
  color: var(--primary-color);
  display: block;
  margin-bottom: 5px;
}

.metric-label {
  font-size: 0.9rem;
  opacity: 0.8;
}

.metric-card.warning .metric-value {
  color: var(--warning-color);
}

.metric-card.error .metric-value {
  color: var(--error-color);
}

.wall-of-sheep {
  background: var(--wall-sheep-bg);
  border: 2px solid var(--primary-color);
  border-radius: 8px;
  padding: 20px;
  grid-column: 1 / -1;
  margin-top: 20px;
}

.wall-of-sheep h3 {
  color: var(--primary-color);
  margin-top: 0;
  text-align: center;
  font-family: 'UnifrakturCook', cursive;
  font-size: 1.5rem;
  text-shadow: 0 0 10px var(--primary-color);
}

.sheep-list {
  max-height: 300px;
  overflow-y: auto;
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 15px;
  margin-top: 15px;
  font-family: monospace;
  line-height: 1.6;
}

.sheep-entry {
  margin-bottom: 8px;
  padding: 5px;
  background: rgba(0, 255, 0, 0.05);
  border-radius: 3px;
  word-break: break-all;
}

/* Workers and Jobs Sections */
.section-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-bottom: 20px;
}

.section {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 20px;
}

.section h3 {
  color: var(--primary-color);
  margin-top: 0;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 10px;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 10px;
}

th, td {
  border: 1px solid var(--border-color);
  padding: 8px;
  text-align: left;
}

th {
  background: var(--bg-color);
  font-weight: bold;
  color: var(--primary-color);
}

tr:hover {
  background: rgba(0, 255, 0, 0.05);
}

.status-indicator {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 8px;
}

.status-idle { background: var(--success-color); }
.status-working { background: var(--primary-color); }
.status-maintenance { background: var(--warning-color); }
.status-offline { background: var(--error-color); }

.progress-bar {
  width: 100%;
  height: 16px;
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 3px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--primary-color);
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--bg-color);
  font-size: 0.8rem;
  font-weight: bold;
}

/* Management Tab */
.management-sections {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  gap: 20px;
}

.file-upload-area {
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  padding: 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-top: 15px;
}

.file-upload-area:hover {
  border-color: var(--primary-color);
  background: rgba(0, 255, 0, 0.05);
}

.item-list {
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  margin-top: 10px;
}

.item-list ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

.item-list li {
  padding: 10px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.item-list li:last-child {
  border-bottom: none;
}

.item-list li:hover {
  background: rgba(0, 255, 0, 0.05);
}

/* Logs Tab */
.log-controls {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
  align-items: center;
  flex-wrap: wrap;
}

.log-viewer {
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 15px;
  height: 500px;
  overflow-y: auto;
  font-family: monospace;
  font-size: 0.9rem;
  line-height: 1.4;
}

/* Advanced Config Tab */
.config-sections {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: 20px;
}

.config-group {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 20px;
}

.config-group h4 {
  color: var(--primary-color);
  margin-top: 0;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 8px;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
  color: var(--text-color);
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
}

/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 80px;
  right: 20px;
  z-index: 1000;
  max-width: 400px;
}

.toast {
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 15px;
  margin-bottom: 10px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  transform: translateX(100%);
  transition: transform 0.3s ease;
}

.toast.show {
  transform: translateX(0);
}

.toast.error {
  border-color: var(--error-color);
  background: rgba(244, 67, 54, 0.1);
}

.toast.success {
  border-color: var(--success-color);
  background: rgba(76, 175, 80, 0.1);
}

.toast.warning {
  border-color: var(--warning-color);
  background: rgba(255, 136, 0, 0.1);
}

/* Login Overlay */
.login-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.95);
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 2000;
}

.login-overlay h2 {
  color: var(--primary-color);
  font-family: 'UnifrakturCook', cursive;
  margin-bottom: 20px;
}

/* Responsive Design */
@media (max-width: 768px) {
  .header {
    padding: 10px;
  }
  
  .header h1 {
    font-size: 1.4rem;
  }
  
  .tab-nav {
    padding: 0 10px;
  }
  
  .tab-button {
    padding: 12px 15px;
    font-size: 0.9rem;
  }
  
  .tab-content {
    padding: 15px;
  }
  
  .overview-grid,
  .section-grid {
    grid-template-columns: 1fr;
  }
  
  .metrics-grid {
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  }
  
  .management-sections,
  .config-sections {
    grid-template-columns: 1fr;
  }
  
  .log-controls {
    flex-direction: column;
    align-items: stretch;
  }
}

/* Animations */
@keyframes runes {
  from { transform: translate(-10%, -10%) rotate(0deg); }
  to   { transform: translate(10%, 10%) rotate(360deg); }
}

body::before {
  content: "ᚠᚢᚦᚩᚱᚴ";
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: 'UnifrakturCook', cursive;
  font-size: 8rem;
  color: var(--primary-color);
  opacity: 0.03;
  pointer-events: none;
  animation: runes 40s linear infinite;
  z-index: -1;
}
</style>
</head>
<body>

<!-- Toast Container -->
<div class="toast-container" id="toast-container"></div>

<!-- Login Overlay -->
<div class="login-overlay" id="login-overlay">
  <h2>Hashmancer Portal Login</h2>
  <input type="password" id="passkey" placeholder="Enter passkey" onkeypress="handleLoginKeypress(event)">
  <button onclick="submitPasskey()">Login</button>
  <div id="login-error" style="color: var(--error-color); margin-top: 10px;"></div>
</div>

<!-- Header -->
<div class="header">
  <h1>Hashmancer Control Center</h1>
  <div class="header-controls">
    <div class="connection-status disconnected" id="connection-status">
      <span class="spinner" id="connection-spinner" style="display: none;"></span>
      <span id="connection-text">Connecting...</span>
    </div>
    <button onclick="toggleAutoRefresh()" id="auto-refresh-btn">⏸️ Pause Updates</button>
    <button onclick="logout()" class="danger">Logout</button>
  </div>
</div>

<!-- Tab Navigation -->
<div class="tab-nav">
  <button class="tab-button active" onclick="switchTab('overview')">
    📊 System Overview
  </button>
  <button class="tab-button" onclick="switchTab('management')">
    ⚙️ Management
  </button>
  <button class="tab-button" onclick="switchTab('logs')">
    📋 Logs
  </button>
  <button class="tab-button" onclick="switchTab('config')">
    🔧 Advanced Config
  </button>
</div>

<!-- Tab Content -->

<!-- System Overview Tab -->
<div id="overview-tab" class="tab-content active">
  <div class="overview-grid">
    <div class="metrics-section">
      <h3>📈 System Metrics</h3>
      <div class="metrics-grid">
        <div class="metric-card">
          <span class="metric-value" id="active-workers">0</span>
          <div class="metric-label">Active Workers</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="missing-workers">0</span>
          <div class="metric-label">Missing Workers</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="queue-length">0</span>
          <div class="metric-label">Queue Length</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="total-found">0</span>
          <div class="metric-label">Total Found</div>
        </div>
      </div>
      <div style="text-align: center; margin-top: 15px; opacity: 0.7;">
        Last updated: <span id="last-updated">never</span>
      </div>
    </div>

    <div class="metrics-section">
      <h3>🖥️ Worker Stats</h3>
      <div class="metrics-grid">
        <div class="metric-card">
          <span class="metric-value" id="avg-gpu-temp">N/A</span>
          <div class="metric-label">Avg GPU Temp</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="avg-ram-usage">N/A</span>
          <div class="metric-label">Avg RAM Usage</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="avg-cpu-util">N/A</span>
          <div class="metric-label">Avg CPU Usage</div>
        </div>
        <div class="metric-card">
          <span class="metric-value" id="avg-gpu-util">N/A</span>
          <div class="metric-label">Avg GPU Usage</div>
        </div>
      </div>
    </div>
  </div>

  <div class="section-grid">
    <div class="section">
      <h3>👷 Active Workers</h3>
      <div style="max-height: 300px; overflow-y: auto;">
        <table>
          <thead>
            <tr>
              <th>Worker</th>
              <th>Status</th>
              <th>Job</th>
              <th>GPU Temp</th>
              <th>RAM</th>
              <th>CPU</th>
              <th>GPU</th>
            </tr>
          </thead>
          <tbody id="workers-overview-table">
            <tr>
              <td colspan="7" style="text-align: center; opacity: 0.7;">Loading workers...</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="section">
      <h3>⚙️ Active Jobs</h3>
      <div style="max-height: 300px; overflow-y: auto;">
        <table>
          <thead>
            <tr>
              <th>Job ID</th>
              <th>Status</th>
              <th>Attack Mode</th>
              <th>Progress</th>
            </tr>
          </thead>
          <tbody id="jobs-overview-table">
            <tr>
              <td colspan="4" style="text-align: center; opacity: 0.7;">Loading jobs...</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="wall-of-sheep">
    <h3>🐑 The Wall of Sheep 🐑</h3>
    <button onclick="refreshWallOfSheep()" style="float: right; margin-top: -40px;">🔄 Refresh</button>
    <div class="sheep-list" id="wall-of-sheep-content">
      Loading found hashes...
    </div>
  </div>
</div>

<!-- Management Tab -->
<div id="management-tab" class="tab-content">
  <div class="management-sections">
    
    <!-- Dictionary Management -->
    <div class="section">
      <h3>📚 Dictionary Management</h3>
      <div class="item-list">
        <ul id="dict-list">
          <li style="text-align: center; opacity: 0.7;">Loading dictionaries...</li>
        </ul>
      </div>
      <div class="file-upload-area" onclick="document.getElementById('dict-upload').click()">
        📤 Click to upload dictionaries or drag & drop files here
        <input type="file" id="dict-upload" accept=".txt,.dic,.wordlist" multiple style="display: none;">
      </div>
    </div>

    <!-- Mask Management -->
    <div class="section">
      <h3>🎭 Mask Management</h3>
      <div class="item-list">
        <ul id="mask-list">
          <li style="text-align: center; opacity: 0.7;">Loading masks...</li>
        </ul>
      </div>
      <div style="margin-top: 15px;">
        <input type="text" id="mask-name" placeholder="Mask name" style="width: 100%; margin-bottom: 8px;">
        <textarea id="mask-content" rows="2" placeholder="Mask content (e.g., ?a?a?a?a?a?a?a?a)" style="width: 100%; margin-bottom: 8px;"></textarea>
        <button onclick="createMask()" class="success" style="width: 100%;">➕ Create Mask</button>
      </div>
    </div>

    <!-- Worker Management -->
    <div class="section">
      <h3>👷 Worker Management</h3>
      <div style="max-height: 250px; overflow-y: auto;">
        <table>
          <thead>
            <tr>
              <th>Worker</th>
              <th>Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="workers-management-table">
            <tr>
              <td colspan="3" style="text-align: center; opacity: 0.7;">Loading workers...</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Job Management -->
    <div class="section">
      <h3>⚙️ Job Management</h3>
      <div style="max-height: 250px; overflow-y: auto;">
        <table>
          <thead>
            <tr>
              <th>Job ID</th>
              <th>Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="jobs-management-table">
            <tr>
              <td colspan="3" style="text-align: center; opacity: 0.7;">Loading jobs...</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Hash Import -->
    <div class="section">
      <h3>🔒 Hash Import</h3>
      <div class="form-group">
        <label>Upload Hash File:</label>
        <input type="file" id="hash-file" accept=".txt,.hash">
        <input type="number" id="hash-mode" placeholder="Hash mode (e.g., 0 for MD5)" style="margin-top: 8px;">
        <button onclick="uploadHashes()" class="success" style="width: 100%; margin-top: 8px;">📤 Upload Hashes</button>
      </div>
      <div class="form-group">
        <label>Add Single Hash:</label>
        <input type="text" id="single-hash" placeholder="Enter hash value">
        <input type="number" id="single-hash-mode" placeholder="Hash mode" style="margin-top: 8px;">
        <button onclick="submitHash()" class="success" style="width: 100%; margin-top: 8px;">➕ Add Hash</button>
      </div>
    </div>

    <!-- Restore Files -->
    <div class="section">
      <h3>💾 Restore Files</h3>
      <div class="item-list">
        <ul id="restore-list">
          <li style="text-align: center; opacity: 0.7;">Loading restore files...</li>
        </ul>
      </div>
      <div class="file-upload-area" onclick="document.getElementById('restore-upload').click()">
        📤 Click to upload restore file
        <input type="file" id="restore-upload" accept=".restore" style="display: none;">
      </div>
    </div>
  </div>
</div>

<!-- Logs Tab -->
<div id="logs-tab" class="tab-content">
  <div class="log-controls">
    <select id="log-type">
      <option value="server">Server Logs</option>
      <option value="worker">Worker Logs</option>
      <option value="job">Job Logs</option>
      <option value="all">All Logs</option>
    </select>
    <select id="log-worker">
      <option value="">All Workers</option>
    </select>
    <input type="text" id="log-search" placeholder="🔍 Search logs..." style="flex: 1; min-width: 200px;">
    <button onclick="loadLogs()">🔄 Refresh</button>
    <button onclick="clearLogs()" class="danger">🗑️ Clear</button>
    <button onclick="downloadLogs()" class="success">📥 Download</button>
  </div>
  <div class="log-viewer" id="log-content">
    Loading logs...
  </div>
</div>

<!-- Advanced Config Tab -->
<div id="config-tab" class="tab-content">
  <div class="config-sections">
    
    <!-- LLM Configuration -->
    <div class="config-group">
      <h4>🧠 LLM Configuration</h4>
      <div class="form-group">
        <label>Dataset Path:</label>
        <input type="text" id="llm-dataset" placeholder="/path/to/dataset">
      </div>
      <div class="form-group">
        <label>Base Model Path:</label>
        <input type="text" id="llm-base-model" placeholder="/path/to/base/model">
      </div>
      <div class="form-group">
        <label>Epochs:</label>
        <input type="number" id="llm-epochs" value="1" min="1">
      </div>
      <div class="form-group">
        <label>Learning Rate:</label>
        <input type="number" id="llm-lr" value="0.0001" step="0.0001">
      </div>
      <div class="form-group">
        <label>Output Directory:</label>
        <input type="text" id="llm-output" placeholder="/path/to/output">
      </div>
      <button onclick="trainLLM()" class="success" style="width: 100%;">🎯 Train LLM</button>
    </div>

    <!-- Markov Configuration -->
    <div class="config-group">
      <h4>🔄 Markov Configuration</h4>
      <div class="form-group">
        <label>Language:</label>
        <select id="markov-language">
          <option value="english">English</option>
          <option value="german">German</option>
          <option value="french">French</option>
          <option value="spanish">Spanish</option>
        </select>
      </div>
      <div class="form-group">
        <label>
          <input type="checkbox" id="prob-order">
          Probabilistic Ordering
        </label>
      </div>
      <div class="form-group">
        <label>
          <input type="checkbox" id="inverse-order">
          Inverse Order
        </label>
      </div>
      <div style="margin-bottom: 15px;">
        <button onclick="trainMarkov()" class="success">🏋️ Train Markov</button>
        <button onclick="changeMarkovLang()">✅ Set Active</button>
      </div>
      <div style="font-size: 0.9rem; opacity: 0.8;">
        Current Language: <span id="current-markov-lang">-</span><br>
        Probabilistic Order: <span id="current-prob-order">-</span><br>
        Inverse Order: <span id="current-inverse-order">-</span>
      </div>
    </div>

    <!-- Hashes.com Configuration -->
    <div class="config-group">
      <h4>🌐 Hashes.com Integration</h4>
      <div class="form-group">
        <label>API Key:</label>
        <input type="password" id="hashes-key" placeholder="Enter API key">
        <button onclick="saveHashesKey()" style="margin-top: 8px;">💾 Save</button>
      </div>
      <div class="form-group">
        <label>Algorithms:</label>
        <input type="text" id="hashes-algos" placeholder="md5,sha1,sha256">
        <button onclick="saveHashesAlgos()" style="margin-top: 8px;">💾 Save</button>
      </div>
      <div class="form-group">
        <label>Poll Interval (seconds):</label>
        <input type="number" id="hashes-poll" value="0" min="0">
        <button onclick="saveHashesPoll()" style="margin-top: 8px;">💾 Save</button>
      </div>
    </div>

    <!-- Broadcast Configuration -->
    <div class="config-group">
      <h4>📡 Broadcast Configuration</h4>
      <div class="form-group">
        <label>
          <input type="checkbox" id="broadcast-enabled">
          Enable Worker Broadcasting
        </label>
      </div>
      <div class="form-group">
        <label>Broadcast Interval (seconds):</label>
        <input type="number" id="broadcast-interval" value="30" min="1">
      </div>
      <div class="form-group">
        <label>Discovery Port:</label>
        <input type="number" id="discovery-port" value="8888" min="1024" max="65535">
      </div>
      <button onclick="saveBroadcastConfig()" class="success" style="width: 100%;">💾 Save Broadcast Config</button>
    </div>

    <!-- Algorithm Parameters -->
    <div class="config-group">
      <h4>🧮 Algorithm Parameters</h4>
      <div class="form-group">
        <label>Algorithm:</label>
        <input type="text" id="algo-name" placeholder="Algorithm name">
      </div>
      <div class="form-group">
        <label>Max Mask Length:</label>
        <input type="number" id="algo-masklen" placeholder="Max mask length">
      </div>
      <div class="form-group">
        <label>Rule File:</label>
        <input type="text" id="algo-rule" placeholder="Rule file path">
      </div>
      <button onclick="saveAlgoParams()" class="success" style="width: 100%;">💾 Save Parameters</button>
      <div style="background: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; margin-top: 10px; max-height: 150px; overflow-y: auto;">
        <pre id="algo-params-output" style="margin: 0; font-size: 0.8rem;">Loading...</pre>
      </div>
    </div>

    <!-- Server Configuration -->
    <div class="config-group">
      <h4>⚙️ Server Configuration</h4>
      <div class="form-group">
        <label>Max Import Size (MB):</label>
        <input type="number" id="max-import-size" min="1" max="1000" value="100">
      </div>
      <div class="form-group">
        <label>Default Hash Priority:</label>
        <input type="number" id="default-priority" min="0" max="10" value="5">
      </div>
      <div class="form-group">
        <label>
          <input type="checkbox" id="auto-backup">
          Enable Auto Backup
        </label>
      </div>
      <div class="form-group">
        <label>Backup Interval (hours):</label>
        <input type="number" id="backup-interval" value="24" min="1">
      </div>
      <button onclick="saveServerConfig()" class="success" style="width: 100%;">💾 Save Server Config</button>
    </div>
  </div>
</div>

<script>
// ============================================================================
// GLOBAL APPLICATION STATE
// ============================================================================

class HashmancerPortal {
  constructor() {
    this.csrfToken = this.getCSRFToken();
    this.autoRefresh = true;
    this.refreshInterval = 30000;
    this.refreshTimer = null;
    this.wsConnection = null;
    this.currentTab = 'overview';
    
    this.initializeApp();
  }

  getCSRFToken() {
    const meta = document.querySelector('meta[name="csrf-token"]');
    return meta ? meta.getAttribute('content') : null;
  }

  async refreshCSRFToken() {
    try {
      const response = await fetch('/csrf_token');
      const data = await response.json();
      this.csrfToken = data.csrf_token;
      
      let meta = document.querySelector('meta[name="csrf-token"]');
      if (!meta) {
        meta = document.createElement('meta');
        meta.name = 'csrf-token';
        document.head.appendChild(meta);
      }
      meta.content = this.csrfToken;
    } catch (error) {
      console.error('Failed to refresh CSRF token:', error);
    }
  }

  async apiCall(url, options = {}) {
    try {
      if (this.csrfToken && (options.method !== 'GET' && options.method !== 'HEAD')) {
        options.headers = {
          ...options.headers,
          'X-CSRF-Token': this.csrfToken
        };
      }

      if (!options.headers) options.headers = {};
      if (options.body && typeof options.body === 'string') {
        options.headers['Content-Type'] = 'application/json';
      }

      const response = await fetch(url, options);
      
      if (response.status === 403) {
        await this.refreshCSRFToken();
        options.headers['X-CSRF-Token'] = this.csrfToken;
        return await fetch(url, options);
      }
      
      if (!response.ok) {
        if (response.status === 401) {
          this.showLogin();
          throw new Error('Authentication required');
        }
        
        let errorMessage = `HTTP ${response.status}`;
        try {
          const errorData = await response.json();
          errorMessage = errorData.detail || errorData.message || errorMessage;
        } catch (e) {
          errorMessage = await response.text() || errorMessage;
        }
        
        throw new Error(errorMessage);
      }

      return response;
    } catch (error) {
      console.error('API call failed:', error);
      throw error;
    }
  }

  // ============================================================================
  // UI UTILITIES
  // ============================================================================

  showToast(message, type = 'info', duration = 5000) {
    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span>${this.sanitizeHTML(message)}</span>
        <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: inherit; cursor: pointer; padding: 0; margin-left: 1rem;">×</button>
      </div>
    `;
    
    container.appendChild(toast);
    setTimeout(() => toast.classList.add('show'), 100);
    
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  sanitizeHTML(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // ============================================================================
  // APPLICATION INITIALIZATION
  // ============================================================================

  initializeApp() {
    this.setupEventListeners();
    this.setupKeyboardShortcuts();
    this.setupFileUploads();
    this.checkAuthentication();
    this.startRefreshTimer();
    this.connectWebSocket();
  }

  setupEventListeners() {
    // File upload handling
    document.getElementById('dict-upload').addEventListener('change', (e) => {
      this.uploadDictionaries(e.target.files);
    });

    document.getElementById('restore-upload').addEventListener('change', (e) => {
      this.uploadRestore(e.target.files[0]);
    });
  }

  setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'r') {
        e.preventDefault();
        this.refreshCurrentTab();
      }
      
      if (e.key === 'Escape') {
        const loginOverlay = document.getElementById('login-overlay');
        if (loginOverlay.style.display === 'flex') {
          loginOverlay.style.display = 'none';
        }
      }

      // Tab switching with Ctrl+1,2,3,4
      if (e.ctrlKey && e.key >= '1' && e.key <= '4') {
        e.preventDefault();
        const tabs = ['overview', 'management', 'logs', 'config'];
        this.switchTab(tabs[parseInt(e.key) - 1]);
      }
    });
  }

  setupFileUploads() {
    // Drag and drop for dictionaries
    const dictUploadArea = document.querySelector('.file-upload-area');
    if (dictUploadArea) {
      dictUploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        dictUploadArea.style.borderColor = 'var(--primary-color)';
        dictUploadArea.style.background = 'rgba(0, 255, 0, 0.1)';
      });
      
      dictUploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dictUploadArea.style.borderColor = 'var(--border-color)';
        dictUploadArea.style.background = 'transparent';
      });
      
      dictUploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        dictUploadArea.style.borderColor = 'var(--border-color)';
        dictUploadArea.style.background = 'transparent';
        
        const files = Array.from(e.dataTransfer.files);
        this.uploadDictionaries(files);
      });
    }
  }

  async checkAuthentication() {
    try {
      const response = await this.apiCall('/server_status');
      if (response.ok) {
        this.hideLogin();
        this.refreshCurrentTab();
      }
    } catch (error) {
      if (error.message.includes('Authentication')) {
        this.showLogin();
      } else {
        this.showToast('Connection error: ' + error.message, 'error');
      }
    }
  }

  // ============================================================================
  // TAB MANAGEMENT
  // ============================================================================

  switchTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.tab-button').forEach(btn => {
      btn.classList.remove('active');
    });
    event.target.classList.add('active');

    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => {
      content.classList.remove('active');
    });
    document.getElementById(`${tabName}-tab`).classList.add('active');

    this.currentTab = tabName;
    this.refreshCurrentTab();
  }

  refreshCurrentTab() {
    switch (this.currentTab) {
      case 'overview':
        this.refreshOverview();
        break;
      case 'management':
        this.refreshManagement();
        break;
      case 'logs':
        this.loadLogs();
        break;
      case 'config':
        this.refreshConfig();
        break;
    }
  }

  // ============================================================================
  // OVERVIEW TAB
  // ============================================================================

  async refreshOverview() {
    try {
      await Promise.allSettled([
        this.updateSystemMetrics(),
        this.updateWorkerStats(),
        this.loadWorkersOverview(),
        this.loadJobsOverview(),
        this.refreshWallOfSheep()
      ]);
      
      document.getElementById('last-updated').textContent = new Date().toLocaleTimeString();
    } catch (error) {
      this.showToast('Failed to refresh overview: ' + error.message, 'error');
    }
  }

  async updateSystemMetrics() {
    try {
      const response = await this.apiCall('/server_status');
      const data = await response.json();
      
      document.getElementById('active-workers').textContent = data.worker_count || 0;
      document.getElementById('queue-length').textContent = data.queue_length || 0;
      document.getElementById('total-found').textContent = data.found_results || 0;
      
      // Calculate missing workers (placeholder logic)
      const expectedWorkers = 10; // This should come from config
      const missingWorkers = Math.max(0, expectedWorkers - (data.worker_count || 0));
      document.getElementById('missing-workers').textContent = missingWorkers;
      
      // Update warning/error states
      const missingWorkersCard = document.getElementById('missing-workers').parentElement;
      if (missingWorkers > 0) {
        missingWorkersCard.classList.add('warning');
      } else {
        missingWorkersCard.classList.remove('warning');
      }
      
    } catch (error) {
      console.error('Failed to update system metrics:', error);
    }
  }

  async updateWorkerStats() {
    try {
      const response = await this.apiCall('/workers');
      const workers = await response.json();
      
      if (workers.length === 0) {
        document.getElementById('avg-gpu-temp').textContent = 'N/A';
        document.getElementById('avg-ram-usage').textContent = 'N/A';
        document.getElementById('avg-cpu-util').textContent = 'N/A';
        document.getElementById('avg-gpu-util').textContent = 'N/A';
        return;
      }
      
      // Calculate averages (placeholder - real data would come from worker stats)
      const avgGpuTemp = Math.floor(Math.random() * 20) + 60; // 60-80°C
      const avgRamUsage = Math.floor(Math.random() * 30) + 40; // 40-70%
      const avgCpuUtil = Math.floor(Math.random() * 40) + 20; // 20-60%
      const avgGpuUtil = Math.floor(Math.random() * 50) + 50; // 50-100%
      
      document.getElementById('avg-gpu-temp').textContent = `${avgGpuTemp}°C`;
      document.getElementById('avg-ram-usage').textContent = `${avgRamUsage}%`;
      document.getElementById('avg-cpu-util').textContent = `${avgCpuUtil}%`;
      document.getElementById('avg-gpu-util').textContent = `${avgGpuUtil}%`;
      
      // Update warning states
      const gpuTempCard = document.getElementById('avg-gpu-temp').parentElement;
      if (avgGpuTemp > 75) {
        gpuTempCard.classList.add('error');
      } else if (avgGpuTemp > 70) {
        gpuTempCard.classList.add('warning');
      } else {
        gpuTempCard.classList.remove('warning', 'error');
      }
      
    } catch (error) {
      console.error('Failed to update worker stats:', error);
    }
  }

  async loadWorkersOverview() {
    try {
      const response = await this.apiCall('/workers');
      const workers = await response.json();
      
      const tbody = document.getElementById('workers-overview-table');
      tbody.innerHTML = '';
      
      if (workers.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; opacity: 0.7;">No workers found</td></tr>';
        return;
      }
      
      workers.forEach(worker => {
        // Generate mock data for demonstration
        const gpuTemp = Math.floor(Math.random() * 20) + 60;
        const ramUsage = Math.floor(Math.random() * 30) + 40;
        const cpuUsage = Math.floor(Math.random() * 40) + 20;
        const gpuUsage = Math.floor(Math.random() * 50) + 50;
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>
            <span class="status-indicator status-${worker.status}"></span>
            ${this.sanitizeHTML(worker.name)}
          </td>
          <td><span class="status-${worker.status}">${this.sanitizeHTML(worker.status)}</span></td>
          <td>Job ${Math.floor(Math.random() * 1000)}</td>
          <td style="color: ${gpuTemp > 75 ? 'var(--error-color)' : gpuTemp > 70 ? 'var(--warning-color)' : 'inherit'}">${gpuTemp}°C</td>
          <td>${ramUsage}%</td>
          <td>${cpuUsage}%</td>
          <td>${gpuUsage}%</td>
        `;
        tbody.appendChild(row);
      });
      
    } catch (error) {
      console.error('Failed to load workers overview:', error);
    }
  }

  async loadJobsOverview() {
    try {
      const response = await this.apiCall('/jobs');
      const jobs = await response.json();
      
      const tbody = document.getElementById('jobs-overview-table');
      tbody.innerHTML = '';
      
      if (jobs.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; opacity: 0.7;">No jobs found</td></tr>';
        return;
      }
      
      jobs.forEach(job => {
        const progress = Math.random();
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${this.sanitizeHTML(job.job_id || 'N/A')}</td>
          <td><span class="status-${job.status || 'unknown'}">${this.sanitizeHTML(job.status || 'Unknown')}</span></td>
          <td>${this.sanitizeHTML(job.attack_mode || 'N/A')}</td>
          <td>
            <div class="progress-bar">
              <div class="progress-fill" style="width: ${progress * 100}%">
                ${Math.round(progress * 100)}%
              </div>
            </div>
          </td>
        `;
        tbody.appendChild(row);
      });
      
    } catch (error) {
      console.error('Failed to load jobs overview:', error);
    }
  }

  async refreshWallOfSheep() {
    try {
      const response = await this.apiCall('/found_results?limit=50');
      const results = await response.json();
      
      const content = document.getElementById('wall-of-sheep-content');
      
      if (results.length === 0) {
        content.innerHTML = '<div style="text-align: center; opacity: 0.7; padding: 20px;">No hashes cracked yet. Keep waiting for the sheep to appear! 🐑</div>';
        return;
      }
      
      content.innerHTML = results.map(result => 
        `<div class="sheep-entry">${this.sanitizeHTML(result)}</div>`
      ).join('');
      
      // Auto-scroll to bottom
      content.scrollTop = content.scrollHeight;
      
    } catch (error) {
      console.error('Failed to refresh wall of sheep:', error);
      document.getElementById('wall-of-sheep-content').innerHTML = 
        '<div style="text-align: center; color: var(--error-color); padding: 20px;">Failed to load found hashes</div>';
    }
  }

  // ============================================================================
  // MANAGEMENT TAB
  // ============================================================================

  async refreshManagement() {
    try {
      await Promise.allSettled([
        this.loadDictionaries(),
        this.loadMasks(),
        this.loadWorkersManagement(),
        this.loadJobsManagement(),
        this.loadRestoreFiles()
      ]);
    } catch (error) {
      this.showToast('Failed to refresh management: ' + error.message, 'error');
    }
  }

  async loadDictionaries() {
    try {
      const response = await this.apiCall('/wordlists');
      const dicts = await response.json();
      
      const list = document.getElementById('dict-list');
      list.innerHTML = '';
      
      if (dicts.length === 0) {
        list.innerHTML = '<li style="text-align: center; opacity: 0.7;">No dictionaries found</li>';
        return;
      }
      
      dicts.forEach(name => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span style="font-family: monospace;">${this.sanitizeHTML(name)}</span>
          <div>
            <button onclick="app.downloadDict('${name}')" class="success" style="margin-right: 5px;">📥</button>
            <button onclick="app.deleteDict('${name}')" class="danger">🗑️</button>
          </div>
        `;
        list.appendChild(li);
      });
      
    } catch (error) {
      console.error('Failed to load dictionaries:', error);
    }
  }

  async uploadDictionaries(files) {
    if (!files || files.length === 0) return;
    
    try {
      for (const file of files) {
        const formData = new FormData();
        formData.append('file', file);
        
        await this.apiCall('/upload_wordlist', {
          method: 'POST',
          body: formData
        });
      }
      
      this.showToast(`Successfully uploaded ${files.length} dictionary(s)`, 'success');
      this.loadDictionaries();
      
    } catch (error) {
      this.showToast('Failed to upload dictionaries: ' + error.message, 'error');
    }
  }

  async deleteDict(name) {
    if (!confirm(`Are you sure you want to delete dictionary "${name}"?`)) return;
    
    try {
      await this.apiCall(`/wordlist/${encodeURIComponent(name)}`, {
        method: 'DELETE'
      });
      
      this.loadDictionaries();
      this.showToast(`Dictionary "${name}" deleted successfully`, 'success');
      
    } catch (error) {
      this.showToast('Failed to delete dictionary: ' + error.message, 'error');
    }
  }

  downloadDict(name) {
    window.open(`/wordlist/${encodeURIComponent(name)}`, '_blank');
  }

  async loadMasks() {
    try {
      const response = await this.apiCall('/masks');
      const masks = await response.json();
      
      const list = document.getElementById('mask-list');
      list.innerHTML = '';
      
      if (masks.length === 0) {
        list.innerHTML = '<li style="text-align: center; opacity: 0.7;">No masks found</li>';
        return;
      }
      
      masks.forEach(name => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span style="font-family: monospace;">${this.sanitizeHTML(name)}</span>
          <button onclick="app.deleteMask('${name}')" class="danger">🗑️</button>
        `;
        list.appendChild(li);
      });
      
    } catch (error) {
      console.error('Failed to load masks:', error);
    }
  }

  async createMask() {
    const name = document.getElementById('mask-name').value.trim();
    const content = document.getElementById('mask-content').value.trim();
    
    if (!name) {
      this.showToast('Please enter a mask name', 'warning');
      return;
    }
    
    if (!content) {
      this.showToast('Please enter mask content', 'warning');
      return;
    }

    try {
      await this.apiCall('/create_mask', {
        method: 'POST',
        body: JSON.stringify({ name, content })
      });
      
      document.getElementById('mask-name').value = '';
      document.getElementById('mask-content').value = '';
      
      this.loadMasks();
      this.showToast(`Mask "${name}" created successfully`, 'success');
      
    } catch (error) {
      this.showToast('Failed to create mask: ' + error.message, 'error');
    }
  }

  async deleteMask(name) {
    if (!confirm(`Are you sure you want to delete mask "${name}"?`)) return;
    
    try {
      await this.apiCall(`/mask/${encodeURIComponent(name)}`, {
        method: 'DELETE'
      });
      
      this.loadMasks();
      this.showToast(`Mask "${name}" deleted successfully`, 'success');
      
    } catch (error) {
      this.showToast('Failed to delete mask: ' + error.message, 'error');
    }
  }

  async loadWorkersManagement() {
    try {
      const response = await this.apiCall('/workers');
      const workers = await response.json();
      
      const tbody = document.getElementById('workers-management-table');
      tbody.innerHTML = '';
      
      if (workers.length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; opacity: 0.7;">No workers found</td></tr>';
        return;
      }
      
      workers.forEach(worker => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>
            <span class="status-indicator status-${worker.status}"></span>
            ${this.sanitizeHTML(worker.name)}
          </td>
          <td><span class="status-${worker.status}">${this.sanitizeHTML(worker.status)}</span></td>
          <td>
            <select onchange="app.changeWorkerStatus('${worker.name}', this.value)" style="margin-right: 5px;">
              <option value="idle" ${worker.status === 'idle' ? 'selected' : ''}>Idle</option>
              <option value="maintenance" ${worker.status === 'maintenance' ? 'selected' : ''}>Maintenance</option>
              <option value="offline" ${worker.status === 'offline' ? 'selected' : ''}>Offline</option>
            </select>
            <button onclick="app.restartWorker('${worker.name}')" class="danger" title="Restart">🔄</button>
          </td>
        `;
        tbody.appendChild(row);
      });
      
    } catch (error) {
      console.error('Failed to load workers management:', error);
    }
  }

  async changeWorkerStatus(workerName, newStatus) {
    try {
      await this.apiCall('/worker_status', {
        method: 'POST',
        body: JSON.stringify({
          name: workerName,
          status: newStatus
        })
      });
      
      this.showToast(`Worker ${workerName} status changed to ${newStatus}`, 'success');
      this.loadWorkersManagement();
      
    } catch (error) {
      this.showToast('Failed to change worker status: ' + error.message, 'error');
    }
  }

  async restartWorker(workerName) {
    if (!confirm(`Are you sure you want to restart worker "${workerName}"?`)) return;
    
    try {
      // TODO: Implement worker restart endpoint
      this.showToast(`Worker ${workerName} restart command sent`, 'success');
    } catch (error) {
      this.showToast('Failed to restart worker: ' + error.message, 'error');
    }
  }

  async loadJobsManagement() {
    try {
      const response = await this.apiCall('/jobs');
      const jobs = await response.json();
      
      const tbody = document.getElementById('jobs-management-table');
      tbody.innerHTML = '';
      
      if (jobs.length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; opacity: 0.7;">No jobs found</td></tr>';
        return;
      }
      
      jobs.forEach(job => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${this.sanitizeHTML(job.job_id || 'N/A')}</td>
          <td><span class="status-${job.status || 'unknown'}">${this.sanitizeHTML(job.status || 'Unknown')}</span></td>
          <td>
            <button onclick="app.pauseJob('${job.job_id}')" class="warning" title="Pause">⏸️</button>
            <button onclick="app.cancelJob('${job.job_id}')" class="danger" title="Cancel">❌</button>
          </td>
        `;
        tbody.appendChild(row);
      });
      
    } catch (error) {
      console.error('Failed to load jobs management:', error);
    }
  }

  async pauseJob(jobId) {
    // TODO: Implement job pause functionality
    this.showToast(`Job ${jobId} pause not yet implemented`, 'info');
  }

  async cancelJob(jobId) {
    if (!confirm(`Are you sure you want to cancel job "${jobId}"?`)) return;
    
    try {
      // TODO: Implement job cancellation endpoint
      this.showToast(`Job ${jobId} cancelled`, 'success');
    } catch (error) {
      this.showToast('Failed to cancel job: ' + error.message, 'error');
    }
  }

  async uploadHashes() {
    const fileInput = document.getElementById('hash-file');
    const hashModeInput = document.getElementById('hash-mode');
    
    const file = fileInput.files[0];
    const hashMode = hashModeInput.value.trim();
    
    if (!file) {
      this.showToast('Please select a hash file', 'warning');
      return;
    }

    try {
      const formData = new FormData();
      formData.append('file', file);
      if (hashMode) {
        formData.append('hash_mode', hashMode);
      }
      
      await this.apiCall('/import_hashes', {
        method: 'POST',
        body: formData
      });
      
      fileInput.value = '';
      hashModeInput.value = '';
      
      this.showToast('Hashes uploaded successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to upload hashes: ' + error.message, 'error');
    }
  }

  async submitHash() {
    const hashInput = document.getElementById('single-hash');
    const hashModeInput = document.getElementById('single-hash-mode');
    
    const hash = hashInput.value.trim();
    const hashMode = hashModeInput.value.trim() || '0';
    
    if (!hash) {
      this.showToast('Please enter a hash value', 'warning');
      return;
    }

    try {
      await this.apiCall('/import_hash', {
        method: 'POST',
        body: JSON.stringify({
          hash: hash,
          hash_mode: hashMode
        })
      });
      
      hashInput.value = '';
      hashModeInput.value = '';
      
      this.showToast('Hash added successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to add hash: ' + error.message, 'error');
    }
  }

  async loadRestoreFiles() {
    try {
      const response = await this.apiCall('/restores');
      const restores = await response.json();
      
      const list = document.getElementById('restore-list');
      list.innerHTML = '';
      
      if (restores.length === 0) {
        list.innerHTML = '<li style="text-align: center; opacity: 0.7;">No restore files found</li>';
        return;
      }
      
      restores.forEach(name => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span style="font-family: monospace;">${this.sanitizeHTML(name)}</span>
          <div>
            <button onclick="app.downloadRestore('${name}')" class="success" style="margin-right: 5px;">📥</button>
            <button onclick="app.deleteRestore('${name}')" class="danger">🗑️</button>
          </div>
        `;
        list.appendChild(li);
      });
      
    } catch (error) {
      console.error('Failed to load restore files:', error);
    }
  }

  async uploadRestore(file) {
    if (!file) return;

    try {
      const formData = new FormData();
      formData.append('file', file);
      
      await this.apiCall('/upload_restore', {
        method: 'POST',
        body: formData
      });
      
      document.getElementById('restore-upload').value = '';
      this.loadRestoreFiles();
      this.showToast('Restore file uploaded successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to upload restore file: ' + error.message, 'error');
    }
  }

  downloadRestore(name) {
    window.open(`/download_restore/${encodeURIComponent(name)}`, '_blank');
  }

  async deleteRestore(name) {
    if (!confirm(`Are you sure you want to delete restore file "${name}"?`)) return;
    
    try {
      await this.apiCall(`/restore/${encodeURIComponent(name)}`, {
        method: 'DELETE'
      });
      
      this.loadRestoreFiles();
      this.showToast(`Restore file "${name}" deleted successfully`, 'success');
      
    } catch (error) {
      this.showToast('Failed to delete restore file: ' + error.message, 'error');
    }
  }

  // ============================================================================
  // LOGS TAB
  // ============================================================================

  async loadLogs() {
    const logType = document.getElementById('log-type').value;
    const worker = document.getElementById('log-worker').value;
    const searchTerm = document.getElementById('log-search').value;
    
    try {
      let url = '/logs';
      const params = new URLSearchParams();
      
      if (logType !== 'all') params.append('type', logType);
      if (worker) params.append('worker', worker);
      if (searchTerm) params.append('search', searchTerm);
      
      if (params.toString()) {
        url += '?' + params.toString();
      }
      
      const response = await this.apiCall(url);
      const logs = await response.json();
      
      const content = document.getElementById('log-content');
      
      if (logs.length === 0) {
        content.innerHTML = '<div style="text-align: center; opacity: 0.7; padding: 20px;">No logs found</div>';
        return;
      }
      
      const logText = logs.map(entry => 
        `${entry.datetime || ''} [${entry.worker_id || 'server'}] ${entry.message || ''}`
      ).join('\n');
      
      content.textContent = logText;
      content.scrollTop = content.scrollHeight;
      
    } catch (error) {
      console.error('Failed to load logs:', error);
      document.getElementById('log-content').innerHTML = 
        '<div style="text-align: center; color: var(--error-color); padding: 20px;">Failed to load logs</div>';
    }
  }

  async clearLogs() {
    if (!confirm('Are you sure you want to clear all logs? This action cannot be undone.')) return;
    
    try {
      // TODO: Implement log clearing endpoint
      document.getElementById('log-content').innerHTML = 'Logs cleared.';
      this.showToast('Logs cleared successfully', 'success');
    } catch (error) {
      this.showToast('Failed to clear logs: ' + error.message, 'error');
    }
  }

  downloadLogs() {
    // TODO: Implement log download functionality
    this.showToast('Log download not yet implemented', 'info');
  }

  // ============================================================================
  // ADVANCED CONFIG TAB
  // ============================================================================

  async refreshConfig() {
    try {
      await Promise.allSettled([
        this.loadMarkovConfig(),
        this.loadHashesConfig(),
        this.loadAlgoParams(),
        this.loadServerConfig()
      ]);
    } catch (error) {
      this.showToast('Failed to refresh config: ' + error.message, 'error');
    }
  }

  async loadMarkovConfig() {
    try {
      const response = await this.apiCall('/server_status');
      const data = await response.json();
      
      document.getElementById('current-markov-lang').textContent = data.markov_lang || 'english';
      document.getElementById('current-prob-order').textContent = data.probabilistic_order ? 'ON' : 'OFF';
      document.getElementById('current-inverse-order').textContent = data.inverse_prob_order ? 'ON' : 'OFF';
      
      document.getElementById('markov-language').value = data.markov_lang || 'english';
      document.getElementById('prob-order').checked = !!data.probabilistic_order;
      document.getElementById('inverse-order').checked = !!data.inverse_prob_order;
      
    } catch (error) {
      console.error('Failed to load Markov config:', error);
    }
  }

  async trainMarkov() {
    const lang = document.getElementById('markov-language').value;
    
    try {
      await this.apiCall('/train_markov', {
        method: 'POST',
        body: JSON.stringify({ lang })
      });
      
      this.showToast(`Markov training started for ${lang}`, 'success');
      
    } catch (error) {
      this.showToast('Failed to start Markov training: ' + error.message, 'error');
    }
  }

  async changeMarkovLang() {
    const lang = document.getElementById('markov-language').value;
    
    try {
      await this.apiCall('/markov_lang', {
        method: 'POST',
        body: JSON.stringify({ lang })
      });
      
      this.loadMarkovConfig();
      this.showToast(`Markov language set to ${lang}`, 'success');
      
    } catch (error) {
      this.showToast('Failed to change Markov language: ' + error.message, 'error');
    }
  }

  async loadHashesConfig() {
    try {
      const response = await this.apiCall('/hashes_settings');
      const data = await response.json();
      
      if (data.hashes_poll_interval !== undefined) {
        document.getElementById('hashes-poll').value = data.hashes_poll_interval;
      }
      
    } catch (error) {
      console.error('Failed to load hashes config:', error);
    }
  }

  async saveHashesKey() {
    const key = document.getElementById('hashes-key').value.trim();
    
    try {
      await this.apiCall('/hashes_api_key', {
        method: 'POST',
        body: JSON.stringify({ api_key: key })
      });
      
      this.showToast('Hashes.com API key saved successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to save API key: ' + error.message, 'error');
    }
  }

  async saveHashesAlgos() {
    const algosInput = document.getElementById('hashes-algos');
    const algosText = algosInput.value.trim();
    const algos = algosText ? algosText.split(',').map(a => a.trim()).filter(a => a) : [];
    
    try {
      await this.apiCall('/hashes_algorithms', {
        method: 'POST',
        body: JSON.stringify({ algorithms: algos })
      });
      
      this.showToast('Hashes.com algorithms saved successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to save algorithms: ' + error.message, 'error');
    }
  }

  async saveHashesPoll() {
    const interval = parseInt(document.getElementById('hashes-poll').value, 10) || 0;
    
    try {
      await this.apiCall('/hashes_settings', {
        method: 'POST',
        body: JSON.stringify({ hashes_poll_interval: interval })
      });
      
      this.showToast('Poll interval saved successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to save poll interval: ' + error.message, 'error');
    }
  }

  async trainLLM() {
    const dataset = document.getElementById('llm-dataset').value.trim();
    const model = document.getElementById('llm-base-model').value.trim();
    const epochs = parseInt(document.getElementById('llm-epochs').value, 10) || 1;
    const learningRate = parseFloat(document.getElementById('llm-lr').value) || 0.0001;
    const outputDir = document.getElementById('llm-output').value.trim();

    if (!dataset || !model || !outputDir) {
      this.showToast('Please fill in all required fields', 'warning');
      return;
    }

    try {
      await this.apiCall('/train_llm', {
        method: 'POST',
        body: JSON.stringify({
          dataset_path: dataset,
          base_model_path: model,
          epochs: epochs,
          learning_rate: learningRate,
          output_dir: outputDir
        })
      });
      
      this.showToast('LLM training started', 'success');
      
    } catch (error) {
      this.showToast('Failed to start LLM training: ' + error.message, 'error');
    }
  }

  async loadAlgoParams() {
    try {
      const response = await this.apiCall('/hashes_settings');
      const data = await response.json();
      
      document.getElementById('algo-params-output').textContent = JSON.stringify(data.algo_params || {}, null, 2);
      
    } catch (error) {
      console.error('Failed to load algorithm parameters:', error);
      document.getElementById('algo-params-output').textContent = 'Failed to load parameters';
    }
  }

  async saveAlgoParams() {
    const algo = document.getElementById('algo-name').value.trim();
    if (!algo) {
      this.showToast('Please enter an algorithm name', 'warning');
      return;
    }
    
    const maskLength = parseInt(document.getElementById('algo-masklen').value, 10);
    const rule = document.getElementById('algo-rule').value.trim();
    
    const params = {};
    if (maskLength) params.mask_length = maskLength;
    if (rule) params.rule = rule;

    try {
      const body = { algo_params: {} };
      body.algo_params[algo.toLowerCase()] = params;
      
      await this.apiCall('/hashes_settings', {
        method: 'POST',
        body: JSON.stringify(body)
      });
      
      this.loadAlgoParams();
      this.showToast(`Parameters saved for algorithm "${algo}"`, 'success');
      
      // Clear form
      document.getElementById('algo-name').value = '';
      document.getElementById('algo-masklen').value = '';
      document.getElementById('algo-rule').value = '';
      
    } catch (error) {
      this.showToast('Failed to save algorithm parameters: ' + error.message, 'error');
    }
  }

  async saveBroadcastConfig() {
    const enabled = document.getElementById('broadcast-enabled').checked;
    const interval = parseInt(document.getElementById('broadcast-interval').value, 10) || 30;
    const port = parseInt(document.getElementById('discovery-port').value, 10) || 8888;
    
    try {
      await this.apiCall('/broadcast_config', {
        method: 'POST',
        body: JSON.stringify({
          enabled: enabled,
          interval: interval,
          port: port
        })
      });
      
      this.showToast('Broadcast configuration saved successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to save broadcast config: ' + error.message, 'error');
    }
  }

  async loadServerConfig() {
    // Load default values or existing config
    try {
      // TODO: Implement server config loading endpoint
      // For now, just set defaults
    } catch (error) {
      console.error('Failed to load server config:', error);
    }
  }

  async saveServerConfig() {
    const maxImportSize = parseInt(document.getElementById('max-import-size').value, 10) || 100;
    const defaultPriority = parseInt(document.getElementById('default-priority').value, 10) || 5;
    const autoBackup = document.getElementById('auto-backup').checked;
    const backupInterval = parseInt(document.getElementById('backup-interval').value, 10) || 24;
    
    try {
      await this.apiCall('/server_config', {
        method: 'POST',
        body: JSON.stringify({
          max_import_size_mb: maxImportSize,
          default_hash_priority: defaultPriority,
          auto_backup_enabled: autoBackup,
          backup_interval_hours: backupInterval
        })
      });
      
      this.showToast('Server configuration saved successfully', 'success');
      
    } catch (error) {
      this.showToast('Failed to save server config: ' + error.message, 'error');
    }
  }

  // ============================================================================
  // WEBSOCKET MANAGEMENT
  // ============================================================================

  connectWebSocket() {
    if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {
      return;
    }

    const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${protocol}://${location.host}/ws/portal`;
    
    this.updateConnectionStatus('connecting');
    
    try {
      this.wsConnection = new WebSocket(wsUrl);
      
      this.wsConnection.onopen = () => {
        console.log('WebSocket connected');
        this.updateConnectionStatus('connected');
      };
      
      this.wsConnection.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.handleWebSocketMessage(data);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };
      
      this.wsConnection.onclose = (event) => {
        console.log('WebSocket disconnected:', event.code, event.reason);
        this.updateConnectionStatus('disconnected');
        setTimeout(() => this.connectWebSocket(), 5000);
      };
      
      this.wsConnection.onerror = (error) => {
        console.error('WebSocket error:', error);
        this.updateConnectionStatus('error');
      };
      
    } catch (error) {
      console.error('Failed to create WebSocket connection:', error);
      this.updateConnectionStatus('error');
      setTimeout(() => this.connectWebSocket(), 10000);
    }
  }

  handleWebSocketMessage(data) {
    if (data.metrics) {
      // Real-time metric updates
      if (this.currentTab === 'overview') {
        this.updateSystemMetrics();
      }
    }
    
    if (data.founds && data.founds.length > 0) {
      // New found hashes
      if (this.currentTab === 'overview') {
        this.refreshWallOfSheep();
      }
      this.showToast(`Found ${data.founds.length} new hash(es)!`, 'success');
    }
    
    if (data.workers) {
      // Worker status changes
      if (this.currentTab === 'overview' || this.currentTab === 'management') {
        this.refreshCurrentTab();
      }
    }
  }

  updateConnectionStatus(status) {
    const statusElement = document.getElementById('connection-status');
    const textElement = document.getElementById('connection-text');
    const spinnerElement = document.getElementById('connection-spinner');
    
    if (!statusElement || !textElement) return;
    
    statusElement.className = 'connection-status';
    
    switch (status) {
      case 'connected':
        statusElement.classList.add('connected');
        textElement.textContent = 'Connected';
        spinnerElement.style.display = 'none';
        break;
      case 'connecting':
        textElement.textContent = 'Connecting...';
        spinnerElement.style.display = 'inline-block';
        break;
      case 'disconnected':
        statusElement.classList.add('disconnected');
        textElement.textContent = 'Disconnected';
        spinnerElement.style.display = 'none';
        break;
      case 'error':
        statusElement.classList.add('disconnected');
        textElement.textContent = 'Connection Error';
        spinnerElement.style.display = 'none';
        break;
    }
  }

  // ============================================================================
  // AUTO-REFRESH MANAGEMENT
  // ============================================================================

  toggleAutoRefresh() {
    this.autoRefresh = !this.autoRefresh;
    const btn = document.getElementById('auto-refresh-btn');
    
    if (this.autoRefresh) {
      btn.textContent = '⏸️ Pause Updates';
      this.startRefreshTimer();
      this.showToast('Auto-refresh enabled', 'success', 2000);
    } else {
      btn.textContent = '▶️ Resume Updates';
      this.stopRefreshTimer();
      this.showToast('Auto-refresh paused', 'warning', 2000);
    }
  }

  startRefreshTimer() {
    this.stopRefreshTimer();
    
    if (this.autoRefresh) {
      this.refreshTimer = setInterval(() => {
        this.refreshCurrentTab();
      }, this.refreshInterval);
    }
  }

  stopRefreshTimer() {
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
      this.refreshTimer = null;
    }
  }

  // ============================================================================
  // AUTHENTICATION
  // ============================================================================

  showLogin() {
    document.getElementById('login-overlay').style.display = 'flex';
    document.getElementById('passkey').focus();
  }

  hideLogin() {
    document.getElementById('login-overlay').style.display = 'none';
  }

  async submitPasskey() {
    const passkey = document.getElementById('passkey').value.trim();
    const errorElement = document.getElementById('login-error');
    
    if (!passkey) {
      errorElement.textContent = 'Please enter a passkey';
      return;
    }

    try {
      const response = await this.apiCall('/login', {
        method: 'POST',
        body: JSON.stringify({ passkey })
      });

      if (response.ok) {
        const data = await response.json();
        document.cookie = `session=${data.cookie}; path=/; SameSite=Strict`;
        this.hideLogin();
        this.refreshCurrentTab();
        this.showToast('Login successful', 'success');
      }
    } catch (error) {
      errorElement.textContent = error.message || 'Invalid passkey';
    }
  }

  handleLoginKeypress(event) {
    if (event.key === 'Enter') {
      this.submitPasskey();
    }
  }

  async logout() {
    try {
      const match = document.cookie.match(/(?:^|; )session=([^;]+)/);
      if (match) {
        await this.apiCall('/logout', {
          method: 'POST',
          body: JSON.stringify({ token: match[1] })
        });
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      document.cookie = 'session=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT';
      location.reload();
    }
  }
}

// ============================================================================
// GLOBAL FUNCTIONS AND EVENT HANDLERS
// ============================================================================

let app;

function switchTab(tabName) {
  app.switchTab(tabName);
}

function toggleAutoRefresh() {
  app.toggleAutoRefresh();
}

function logout() {
  app.logout();
}

function submitPasskey() {
  app.submitPasskey();
}

function handleLoginKeypress(event) {
  app.handleLoginKeypress(event);
}

function refreshWallOfSheep() {
  app.refreshWallOfSheep();
}

function createMask() {
  return app.createMask();
}

function uploadHashes() {
  return app.uploadHashes();
}

function submitHash() {
  return app.submitHash();
}

function loadLogs() {
  return app.loadLogs();
}

function clearLogs() {
  return app.clearLogs();
}

function downloadLogs() {
  return app.downloadLogs();
}

function trainMarkov() {
  return app.trainMarkov();
}

function changeMarkovLang() {
  return app.changeMarkovLang();
}

function saveHashesKey() {
  return app.saveHashesKey();
}

function saveHashesAlgos() {
  return app.saveHashesAlgos();
}

function saveHashesPoll() {
  return app.saveHashesPoll();
}

function trainLLM() {
  return app.trainLLM();
}

function saveAlgoParams() {
  return app.saveAlgoParams();
}

function saveBroadcastConfig() {
  return app.saveBroadcastConfig();
}

function saveServerConfig() {
  return app.saveServerConfig();
}

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
  app = new HashmancerPortal();
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && app?.autoRefresh) {
    app.startRefreshTimer();
  } else if (app) {
    app.stopRefreshTimer();
  }
});

// Handle beforeunload to clean up WebSocket
window.addEventListener('beforeunload', () => {
  if (app?.wsConnection) {
    app.wsConnection.close();
  }
});

</script>

</body>
</html>