<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hashmancer Portal</title>
<link href="https://fonts.googleapis.com/css2?family=UnifrakturCook&display=swap" rel="stylesheet">
<style>
body { font-family: Arial, sans-serif; margin:10px; background:#000; color:#0f0; }
h1 { color:#0f0; text-align:center; font-family:'UnifrakturCook', cursive; }
section { margin-bottom:1.2em; }
table { width:100%; border-collapse:collapse; margin-top:0.5em; }
th,td { border:1px solid #0f0; padding:4px; text-align:center; }
input, textarea, select { background:#111; color:#0f0; border:1px solid #0f0; }
button { margin-top:4px; }
pre { background:#111; color:#0f0; padding:5px; overflow:auto; max-height:200px; }
#logo { border:none; background:none; margin:0; font-family:monospace; white-space:pre; text-align:center; }

@keyframes runes {
  from { transform: translate(-10%, -10%) rotate(0deg); }
  to   { transform: translate(10%, 10%) rotate(360deg); }
}
body::before {
  content: "ᚠᚢᚦᚩᚱᚴ";
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: 'UnifrakturCook', cursive;
  font-size: 8rem;
  color: #0f0;
  opacity: 0.03;
  pointer-events: none;
  animation: runes 40s linear infinite;
}
</style>
</head>
<body>
<h1>Hashmancer Portal</h1>
<pre id="logo">██╗  ██╗ █████╗ ███████╗██╗  ██╗███╗   ███╗ █████╗ ███╗   ██╗ ██████╗███████╗███
███╗
██║  ██║██╔══██╗██╔════╝██║  ██║████╗ ████║██╔══██╗████╗  ██║██╔════╝██╔════╝██╔
══██╗
███████║███████║███████╗███████║██╔████╔██║███████║██╔██╗ ██║██║     █████╗  ███
███╔╝
██╔══██║██╔══██║╚════██║██╔══██║██║╚██╔╝██║██╔══██║██║╚██╗██║██║     ██╔══╝  ██╔
══██╗
██║  ██║██║  ██║███████║██║  ██║██║ ╚═╝ ██║██║  ██║██║ ╚████║╚██████╗███████╗██║
  ██║
╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝╚══════╝╚═╝
  ╚═╝</pre>

<section id="metrics">
<div>Workers: <span id="workers">0</span></div>
<div>Queue Length: <span id="queue">0</span></div>
<div>Found Results: <span id="results">0</span></div>
<div>GPU Temps: <span id="gpu">N/A</span></div>
<div id="updated">Updated: never</div>
</section>

<section id="founds">
<h2>Found Hashes</h2>
<pre id="found-output"></pre>
</section>

<section id="all-founds">
<h2>All Found Results</h2>
<button onclick="loadAllFounds()">Refresh</button>
<pre id="all-found-output"></pre>
</section>

<section id="restores">
<h2>Restore Files</h2>
<ul id="restore-list"></ul>
<input type="file" id="restore-upload">
<button onclick="uploadRestore()">Upload</button>
</section>

<section id="dicts">
<h2>Dictionaries</h2>
<ul id="dict-list"></ul>
<input type="file" id="dict-upload">
<button onclick="uploadDict()">Upload</button>
</section>

<section id="masks">
<h2>Masks</h2>
<ul id="mask-list"></ul>
<input type="text" id="mask-name" placeholder="mask name">
<textarea id="mask-content" rows="2" placeholder="mask content"></textarea>
<button onclick="createMask()">Create</button>
</section>

<section id="workers">
<h2>Workers</h2>
<table><thead><tr><th>Worker</th><th>Status</th><th>Change</th></tr></thead>
<tbody id="worker-body"></tbody></table>
</section>

<section id="logs">
<h2>Logs</h2>
<select id="log-worker" onchange="loadLogs()"></select>
<pre id="log-output"></pre>
</section>

<section id="jobs">
<h2>Jobs</h2>
<table><thead><tr><th>ID</th><th>Status</th><th>Attack</th></tr></thead>
<tbody id="job-body"></tbody></table>
</section>

<script>
function applyMetrics(data){
  document.getElementById('workers').textContent = data.worker_count;
  document.getElementById('queue').textContent = data.queue_length;
  document.getElementById('results').textContent = data.found_results;
  document.getElementById('gpu').textContent = (data.gpu_temps || []).join(',');
  document.getElementById('updated').textContent = 'Updated: ' + new Date().toLocaleTimeString();
}
async function updateMetrics(){
  const res = await fetch('/server_status');
  const data = await res.json();
  applyMetrics(data);
}

async function loadDicts(){
  const res = await fetch('/wordlists');
  const data = await res.json();
  const list = document.getElementById('dict-list');
  list.innerHTML='';
  for(const name of data){
    const li=document.createElement('li');
    const btn=document.createElement('button');
    btn.textContent='Delete';
    btn.onclick=async()=>{ await fetch(`/wordlist/${encodeURIComponent(name)}`,{method:'DELETE'}); loadDicts(); };
    li.textContent=name+' ';
    li.appendChild(btn);
    list.appendChild(li);
  }
}

async function uploadDict(){
  const file=document.getElementById('dict-upload').files[0];
  if(!file) return;
  const fd=new FormData();
  fd.append('file',file);
  await fetch('/upload_wordlist',{method:'POST',body:fd});
  document.getElementById('dict-upload').value='';
  loadDicts();
}

async function loadRestores(){
  const res=await fetch('/restores');
  const data=await res.json();
  const list=document.getElementById('restore-list');
  list.innerHTML='';
  for(const name of data){
    const li=document.createElement('li');
    const del=document.createElement('button');
    del.textContent='Delete';
    del.onclick=async()=>{ await fetch(`/restore/${encodeURIComponent(name)}`,{method:'DELETE'}); loadRestores(); };
    const dl=document.createElement('a');
    dl.textContent='Download';
    dl.href=`/download_restore/${encodeURIComponent(name)}`;
    dl.style.color='#0f0';
    li.textContent=name+' ';
    li.appendChild(del);
    li.appendChild(document.createTextNode(' '));
    li.appendChild(dl);
    list.appendChild(li);
  }
}

async function uploadRestore(){
  const file=document.getElementById('restore-upload').files[0];
  if(!file) return;
  const fd=new FormData();
  fd.append('file',file);
  await fetch('/upload_restore',{method:'POST',body:fd});
  document.getElementById('restore-upload').value='';
  loadRestores();
}

async function loadAllFounds(){
  const res=await fetch('/found_results?limit=1000');
  const data=await res.json();
  document.getElementById('all-found-output').textContent=data.join('\n');
}

async function loadMasks(){
  const res=await fetch('/masks');
  const data=await res.json();
  const list=document.getElementById('mask-list');
  list.innerHTML='';
  for(const name of data){
    const li=document.createElement('li');
    const btn=document.createElement('button');
    btn.textContent='Delete';
    btn.onclick=async()=>{ await fetch(`/mask/${encodeURIComponent(name)}`,{method:'DELETE'}); loadMasks(); };
    li.textContent=name+' ';
    li.appendChild(btn);
    list.appendChild(li);
  }
}

async function createMask(){
  const name=document.getElementById('mask-name').value.trim();
  const content=document.getElementById('mask-content').value;
  if(!name) return;
  await fetch('/create_mask',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({name,content})});
  document.getElementById('mask-name').value='';
  document.getElementById('mask-content').value='';
  loadMasks();
}

async function loadWorkers(){
  const res=await fetch('/workers');
  const workers=await res.json();
  const tbody=document.getElementById('worker-body');
  const sel=document.getElementById('log-worker');
  tbody.innerHTML=''; sel.innerHTML='<option value="">All</option>';
  for(const w of workers){
    const tr=document.createElement('tr');
    const nameTd=document.createElement('td');
    nameTd.textContent=w.name;
    const statusTd=document.createElement('td');
    statusTd.textContent=w.status;
    const actionTd=document.createElement('td');
    const select=document.createElement('select');
    for(const opt of ['idle','maintenance','offline']){
      const o=document.createElement('option');
      o.value=opt; o.textContent=opt;
      if(opt===w.status) o.selected=true;
      select.appendChild(o);
    }
    select.onchange=async()=>{
      await fetch('/worker_status',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({name:w.name,status:select.value})});
      statusTd.textContent=select.value;
    };
    actionTd.appendChild(select);
    tr.appendChild(nameTd); tr.appendChild(statusTd); tr.appendChild(actionTd);
    tbody.appendChild(tr);

    const option=document.createElement('option');
    option.value=w.name; option.textContent=w.name;
    sel.appendChild(option);
  }
}

async function loadLogs(){
  const worker=document.getElementById('log-worker').value;
  const url=worker?`/logs?worker=${encodeURIComponent(worker)}`:'/logs';
  const res=await fetch(url);
  const data=await res.json();
  const pre=document.getElementById('log-output');
  pre.textContent=data.map(e=>`${e.datetime} [${e.worker_id}] ${e.message}`).join('\n');
}

async function loadJobs(){
  const res=await fetch('/jobs');
  const jobs=await res.json();
  const tbody=document.getElementById('job-body');
  tbody.innerHTML='';
  for(const j of jobs){
    const tr=document.createElement('tr');
    const idTd=document.createElement('td');
    idTd.textContent=j.job_id;
    const statusTd=document.createElement('td');
    statusTd.textContent=j.status;
    const modeTd=document.createElement('td');
    modeTd.textContent=j.attack_mode||'';
    tr.appendChild(idTd); tr.appendChild(statusTd); tr.appendChild(modeTd);
    tbody.appendChild(tr);
  }
}

function tick(){
  loadDicts();
  loadMasks();
  loadRestores();
  loadWorkers();
  loadJobs();
  loadLogs();
}

function startWS(){
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  const ws = new WebSocket(`${proto}://${location.host}/ws/portal`);
  ws.onmessage = ev => {
    const msg = JSON.parse(ev.data);
    if(msg.metrics) applyMetrics(msg.metrics);
    if(msg.founds && msg.founds.length){
      const pre=document.getElementById('found-output');
      pre.textContent += msg.founds.join('\n')+'\n';
    }
    if(msg.workers) loadWorkers();
  };
  ws.onclose = () => setTimeout(startWS, 1000);
}

setInterval(tick,30000);
tick();
startWS();
</script>
</body>
</html>

